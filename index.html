<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="The Clojure programming language" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>clojure -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">clojure</h1><h2 class="project-version">1.4.0</h2><br /><p>The Clojure programming language</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.4.0</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table><tr><td class="dep-name">lein-marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.7.1</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#clojure.core">clojure.core</a></li><li><a href="#clojure.core.protocols">clojure.core.protocols</a></li><li><a href="#clojure.core.reducers">clojure.core.reducers</a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#clojure.data">clojure.data</a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#clojure.inspector">clojure.inspector</a></li><li><a href="#clojure.instant">clojure.instant</a></li><li><a href="#clojure.java.browse">clojure.java.browse</a></li><li><a href="#clojure.java.browse-ui">clojure.java.browse-ui</a></li><li><a href="#clojure.java.io">clojure.java.io</a></li><li><a href="#clojure.java.javadoc">clojure.java.javadoc</a></li><li><a href="#clojure.java.shell">clojure.java.shell</a></li><li><a href="#clojure.main">clojure.main</a></li><li><a href="#clojure.parallel">clojure.parallel</a></li><li><a href="#clojure.pprint">clojure.pprint</a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#clojure.reflect">clojure.reflect</a></li><li><a href="#"></a></li><li><a href="#clojure.repl">clojure.repl</a></li><li><a href="#clojure.set">clojure.set</a></li><li><a href="#clojure.stacktrace">clojure.stacktrace</a></li><li><a href="#clojure.string">clojure.string</a></li><li><a href="#clojure.template">clojure.template</a></li><li><a href="#clojure.test">clojure.test</a></li><li><a href="#clojure.test.junit">clojure.test.junit</a></li><li><a href="#clojure.test.tap">clojure.test.tap</a></li><li><a href="#clojure.uuid">clojure.uuid</a></li><li><a href="#clojure.walk">clojure.walk</a></li><li><a href="#clojure.xml">clojure.xml</a></li><li><a href="#clojure.zip">clojure.zip</a></li><li><a href="#clojure.test-clojure">clojure.test-clojure</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.core" name="clojure.core"><h1 class="project-name">clojure.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The core Clojure language.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
  clojure.core)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def unquote)
(def unquote-splicing)</pre></td></tr><tr><td class="docs"><p>Creates a new list containing the items.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([&amp; items])
   :doc 
   :added &quot;1.0&quot;}
  list (. clojure.lang.PersistentList creator))</pre></td></tr><tr><td class="docs"><p>Returns a new seq where x is the first element and seq is
    the rest.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x seq])
    :doc 
   :added &quot;1.0&quot;
   :static true}
 cons (fn* ^:static cons [x seq] (. clojure.lang.RT (cons x seq))))</pre></td></tr><tr><td class="docs"><p>during bootstrap we don't have destructuring let, loop or fn, will redefine later</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:macro true
    :added &quot;1.0&quot;}
  let (fn* let [&amp;form &amp;env &amp; decl] (cons 'let* decl)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:macro true
   :added &quot;1.0&quot;}
 loop (fn* loop [&amp;form &amp;env &amp; decl] (cons 'loop* decl)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:macro true
   :added &quot;1.0&quot;}
 fn (fn* fn [&amp;form &amp;env &amp; decl] 
         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) 
                    (.meta ^clojure.lang.IMeta &amp;form))))</pre></td></tr><tr><td class="docs"><p>Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([coll])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 first (fn ^:static first [coll] (. clojure.lang.RT (first coll))))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([coll])
   :tag clojure.lang.ISeq
   :doc 
   :added &quot;1.0&quot;
   :static true}  
 next (fn ^:static next [x] (. clojure.lang.RT (next x))))</pre></td></tr><tr><td class="docs"><p>Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([coll])
   :tag clojure.lang.ISeq
   :doc 
   :added &quot;1.0&quot;
   :static true}  
 rest (fn ^:static rest [x] (. clojure.lang.RT (more x))))</pre></td></tr><tr><td class="docs"><p>conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([coll x] [coll x &amp; xs])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 conj (fn ^:static conj 
        ([coll x] (. clojure.lang.RT (conj coll x)))
        ([coll x &amp; xs]
         (if xs
           (recur (conj coll x) (first xs) (next xs))
           (conj coll x)))))</pre></td></tr><tr><td class="docs"><p>Same as (first (next x))</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([x])
   :added &quot;1.0&quot;
   :static true}
 second (fn ^:static second [x] (first (next x))))</pre></td></tr><tr><td class="docs"><p>Same as (first (first x))</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([x])
   :added &quot;1.0&quot;
   :static true}
 ffirst (fn ^:static ffirst [x] (first (first x))))</pre></td></tr><tr><td class="docs"><p>Same as (next (first x))</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([x])
   :added &quot;1.0&quot;
   :static true}
 nfirst (fn ^:static nfirst [x] (next (first x))))</pre></td></tr><tr><td class="docs"><p>Same as (first (next x))</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([x])
   :added &quot;1.0&quot;
   :static true}
 fnext (fn ^:static fnext [x] (first (next x))))</pre></td></tr><tr><td class="docs"><p>Same as (next (next x))</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([x])
   :added &quot;1.0&quot;
   :static true}
 nnext (fn ^:static nnext [x] (next (next x))))</pre></td></tr><tr><td class="docs"><p>Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '(^clojure.lang.ISeq [coll])
   :doc 
   :tag clojure.lang.ISeq
   :added &quot;1.0&quot;
   :static true}
 seq (fn ^:static seq ^clojure.lang.ISeq [coll] (. clojure.lang.RT (seq coll))))</pre></td></tr><tr><td class="docs"><p>Evaluates x and tests if it is an instance of the class
    c. Returns true or false</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([^Class c x])
   :doc 
   :added &quot;1.0&quot;}
 instance? (fn instance? [^Class c x] (. c (isInstance x))))</pre></td></tr><tr><td class="docs"><p>Return true if x implements ISeq</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 seq? (fn ^:static seq? [x] (instance? clojure.lang.ISeq x)))</pre></td></tr><tr><td class="docs"><p>Return true if x is a Character</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 char? (fn ^:static char? [x] (instance? Character x)))</pre></td></tr><tr><td class="docs"><p>Return true if x is a String</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 string? (fn ^:static string? [x] (instance? String x)))</pre></td></tr><tr><td class="docs"><p>Return true if x implements IPersistentMap</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 map? (fn ^:static map? [x] (instance? clojure.lang.IPersistentMap x)))</pre></td></tr><tr><td class="docs"><p>Return true if x implements IPersistentVector</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([x])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 vector? (fn ^:static vector? [x] (instance? clojure.lang.IPersistentVector x)))</pre></td></tr><tr><td class="docs"><p>assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([map key val] [map key val &amp; kvs])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 assoc
 (fn ^:static assoc
   ([map key val] (. clojure.lang.RT (assoc map key val)))
   ([map key val &amp; kvs]
    (let [ret (assoc map key val)]
      (if kvs
        (recur ret (first kvs) (second kvs) (nnext kvs))
        ret)))))</pre></td></tr><tr><td class="docs"><p>Returns the metadata of obj, returns nil if there is no metadata.</p>

<p>metadata ;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([obj])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 meta (fn ^:static meta [x]
        (if (instance? clojure.lang.IMeta x)
          (. ^clojure.lang.IMeta x (meta)))))</pre></td></tr><tr><td class="docs"><p>Returns an object of the same type and value as obj, with
    map m as its metadata.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:arglists '([^clojure.lang.IObj obj m])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 with-meta (fn ^:static with-meta [^clojure.lang.IObj x m]
             (. x (withMeta m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true :dynamic true}
  assert-valid-fdecl (fn [fdecl]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:private true}
 sigs
 (fn [fdecl]
   (assert-valid-fdecl fdecl)
   (let [asig 
         (fn [fdecl]
           (let [arglist (first fdecl)
                 ;elide implicit macro args
                 arglist (if (clojure.lang.Util/equals '&amp;form (first arglist)) 
                           (clojure.lang.RT/subvec arglist 2 (clojure.lang.RT/count arglist))
                           arglist)
                 body (next fdecl)]
             (if (map? (first body))
               (if (next body)
                 (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))
                 arglist)
               arglist)))]
     (if (seq? (first fdecl))
       (loop [ret [] fdecls fdecl]
         (if fdecls
           (recur (conj ret (asig (first fdecls))) (next fdecls))
           (seq ret)))
       (list (asig fdecl))))))</pre></td></tr><tr><td class="docs"><p>Return the last item in coll, in linear time</p>
</td><td class="codes"><pre class="brush: clojure">(def 
 ^{:arglists '([coll])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 last (fn ^:static last [s]
        (if (next s)
          (recur (next s))
          (first s))))</pre></td></tr><tr><td class="docs"><p>Return a seq of all but the last item in coll, in linear time</p>
</td><td class="codes"><pre class="brush: clojure">(def 
 ^{:arglists '([coll])
   :doc 
   :added &quot;1.0&quot;
   :static true}
 butlast (fn ^:static butlast [s]
           (loop [ret [] s s]
             (if (next s)
               (recur (conj ret (first s)) (next s))
               (seq ret)))))</pre></td></tr><tr><td class="docs"><p>Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
 ^{:doc 
   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]
                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])
   :added &quot;1.0&quot;}
 defn (fn defn [&amp;form &amp;env name &amp; fdecl]
        (let [m (if (string? (first fdecl))
                  {:doc (first fdecl)}
                  {})
              fdecl (if (string? (first fdecl))
                      (next fdecl)
                      fdecl)
              m (if (map? (first fdecl))
                  (conj m (first fdecl))
                  m)
              fdecl (if (map? (first fdecl))
                      (next fdecl)
                      fdecl)
              fdecl (if (vector? (first fdecl))
                      (list fdecl)
                      fdecl)
              m (if (map? (last fdecl))
                  (conj m (last fdecl))
                  m)
              fdecl (if (map? (last fdecl))
                      (butlast fdecl)
                      fdecl)
              m (conj {:arglists (list 'quote (sigs fdecl))} m)
              m (let [inline (:inline m)
                      ifn (first inline)
                      iname (second inline)]
                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)
                  (if (if (clojure.lang.Util/equiv 'fn ifn)
                        (if (instance? clojure.lang.Symbol iname) false true))
                    ;; inserts the same fn name to the inline fn if it does not have one
                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) &quot;__inliner&quot;))
                                                     (next inline))))
                    m))
              m (conj (if (meta name) (meta name) {}) m)]
          (list 'def (with-meta name m)
                ;;todo - restore propagation of fn name
                ;;must figure out how to convey primitive hints to self calls first
                (cons `fn fdecl) ))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(. (var defn) (setMacro))</pre></td></tr><tr><td class="docs"><p>Throws a ClassCastException if x is not a c, else returns x.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cast
  {:added &quot;1.0&quot;
   :static true}
  [^Class c x] 
  (. c (cast x)))</pre></td></tr><tr><td class="docs"><p>Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().</p>
</td><td class="codes"><pre class="brush: clojure">(defn to-array
  {:tag &quot;[Ljava.lang.Object;&quot;
   :added &quot;1.0&quot;
   :static true}
  [coll] (. clojure.lang.RT (toArray coll)))</pre></td></tr><tr><td class="docs"><p>Creates a new vector containing the args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn vector
  {:added &quot;1.0&quot;
   :static true}
  ([] [])
  ([a] [a])
  ([a b] [a b])
  ([a b c] [a b c])
  ([a b c d] [a b c d])
  ([a b c d &amp; args]
     (. clojure.lang.LazilyPersistentVector (create (cons a (cons b (cons c (cons d args))))))))</pre></td></tr><tr><td class="docs"><p>Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.</p>
</td><td class="codes"><pre class="brush: clojure">(defn vec
  {:added &quot;1.0&quot;
   :static true}
  ([coll]
   (if (instance? java.util.Collection coll)
     (clojure.lang.LazilyPersistentVector/create coll)
     (. clojure.lang.LazilyPersistentVector (createOwning (to-array coll))))))</pre></td></tr><tr><td class="docs"><p>keyval => key val
  Returns a new hash map with supplied mappings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn hash-map
  {:added &quot;1.0&quot;
   :static true}
  ([] {})
  ([&amp; keyvals]
   (. clojure.lang.PersistentHashMap (createWithCheck keyvals))))</pre></td></tr><tr><td class="docs"><p>Returns a new hash set with supplied keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn hash-set
  {:added &quot;1.0&quot;
   :static true}
  ([] #{})
  ([&amp; keys]
   (clojure.lang.PersistentHashSet/createWithCheck keys)))</pre></td></tr><tr><td class="docs"><p>keyval => key val
  Returns a new sorted map with supplied mappings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sorted-map
  {:added &quot;1.0&quot;
   :static true}
  ([&amp; keyvals]
   (clojure.lang.PersistentTreeMap/create keyvals)))</pre></td></tr><tr><td class="docs"><p>keyval => key val
  Returns a new sorted map with supplied mappings, using the supplied comparator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sorted-map-by
  {:added &quot;1.0&quot;
   :static true}
  ([comparator &amp; keyvals]
   (clojure.lang.PersistentTreeMap/create comparator keyvals)))</pre></td></tr><tr><td class="docs"><p>Returns a new sorted set with supplied keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sorted-set
  {:added &quot;1.0&quot;
   :static true}
  ([&amp; keys]
   (clojure.lang.PersistentTreeSet/create keys)))</pre></td></tr><tr><td class="docs"><p>Returns a new sorted set with supplied keys, using the supplied comparator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sorted-set-by
  {:added &quot;1.1&quot;
   :static true} 
  ([comparator &amp; keys]
   (clojure.lang.PersistentTreeSet/create comparator keys)))</pre></td></tr><tr><td class="docs"><p>Returns true if x is nil, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nil?
  {:tag Boolean
   :added &quot;1.0&quot;
   :static true
   :inline (fn [x] (list 'clojure.lang.Util/identical x nil))}
  [x] (clojure.lang.Util/identical x nil))</pre></td></tr><tr><td class="docs"><p>Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:doc 
   :arglists '([name doc-string? attr-map? [params*] body]
                 [name doc-string? attr-map? ([params*] body)+ attr-map?])
   :added &quot;1.0&quot;}
 defmacro (fn [&amp;form &amp;env 
                name &amp; args]
             (let [prefix (loop [p (list name) args args]
                            (let [f (first args)]
                              (if (string? f)
                                (recur (cons f p) (next args))
                                (if (map? f)
                                  (recur (cons f p) (next args))
                                  p))))
                   fdecl (loop [fd args]
                           (if (string? (first fd))
                             (recur (next fd))
                             (if (map? (first fd))
                               (recur (next fd))
                               fd)))
                   fdecl (if (vector? (first fdecl))
                           (list fdecl)
                           fdecl)
                   add-implicit-args (fn [fd]
                             (let [args (first fd)]
                               (cons (vec (cons '&amp;form (cons '&amp;env args))) (next fd))))
                   add-args (fn [acc ds]
                              (if (nil? ds)
                                acc
                                (let [d (first ds)]
                                  (if (map? d)
                                    (conj acc d)
                                    (recur (conj acc (add-implicit-args d)) (next ds))))))
                   fdecl (seq (add-args [] fdecl))
                   decl (loop [p prefix d fdecl]
                          (if p
                            (recur (next p) (cons (first p) d))
                            d))]
               (list 'do
                     (cons `defn decl)
                     (list '. (list 'var name) '(setMacro))
                     (list 'var name)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(. (var defmacro) (setMacro))</pre></td></tr><tr><td class="docs"><p>Evaluates test. If logical true, evaluates body in an implicit do.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when
  {:added &quot;1.0&quot;}
  [test &amp; body]
  (list 'if test (cons 'do body)))</pre></td></tr><tr><td class="docs"><p>Evaluates test. If logical false, evaluates body in an implicit do.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when-not
  {:added &quot;1.0&quot;}
  [test &amp; body]
    (list 'if test nil (cons 'do body)))</pre></td></tr><tr><td class="docs"><p>Returns true if x is the value false, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn false?
  {:tag Boolean,
   :added &quot;1.0&quot;
   :static true}
  [x] (clojure.lang.Util/identical x false))</pre></td></tr><tr><td class="docs"><p>Returns true if x is the value true, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn true?
  {:tag Boolean,
   :added &quot;1.0&quot;
   :static true}
  [x] (clojure.lang.Util/identical x true))</pre></td></tr><tr><td class="docs"><p>Returns true if x is logical false, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn not
  {:tag Boolean
   :added &quot;1.0&quot;
   :static true}
  [x] (if x false true))</pre></td></tr><tr><td class="docs"><p>With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn str
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  (^String [] &quot;&quot;)
  (^String [^Object x]
   (if (nil? x) &quot;&quot; (. x (toString))))
  (^String [x &amp; ys]
     ((fn [^StringBuilder sb more]
          (if more
            (recur (. sb  (append (str (first more)))) (next more))
            (str sb)))
      (new StringBuilder (str x)) ys)))</pre></td></tr><tr><td class="docs"><p>Return true if x is a Symbol</p>
</td><td class="codes"><pre class="brush: clojure">(defn symbol?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.Symbol x))</pre></td></tr><tr><td class="docs"><p>Return true if x is a Keyword</p>
</td><td class="codes"><pre class="brush: clojure">(defn keyword?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.Keyword x))</pre></td></tr><tr><td class="docs"><p>Returns a Symbol with the given namespace and name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn symbol
  {:tag clojure.lang.Symbol
   :added &quot;1.0&quot;
   :static true}
  ([name] (if (symbol? name) name (clojure.lang.Symbol/intern name)))
  ([ns name] (clojure.lang.Symbol/intern ns name)))</pre></td></tr><tr><td class="docs"><p>Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is 'G__'.</p>
</td><td class="codes"><pre class="brush: clojure">(defn gensym
  {:added &quot;1.0&quot;
   :static true}
  ([] (gensym &quot;G__&quot;))
  ([prefix-string] (. clojure.lang.Symbol (intern (str prefix-string (str (. clojure.lang.RT (nextID))))))))</pre></td></tr><tr><td class="docs"><p>Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro cond
  {:added &quot;1.0&quot;}
  [&amp; clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         &quot;cond requires an even number of forms&quot;)))
            (cons 'clojure.core/cond (next (next clauses))))))</pre></td></tr><tr><td class="docs"><p>Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keyword
  {:tag clojure.lang.Keyword
   :added &quot;1.0&quot;
   :static true}
  ([name] (cond (keyword? name) name
                (symbol? name) (clojure.lang.Keyword/intern ^clojure.lang.Symbol name)
                (string? name) (clojure.lang.Keyword/intern ^String name)))
  ([ns name] (clojure.lang.Keyword/intern ns name)))</pre></td></tr><tr><td class="docs"><p>Returns a Keyword with the given namespace and name if one already
  exists.  This function will not intern a new keyword. If the keyword
  has not already been interned, it will return nil.  Do not use :
  in the keyword strings, it will be added automatically.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-keyword
  {:tag clojure.lang.Keyword
   :added &quot;1.3&quot;
   :static true}
  ([name] (cond (keyword? name) name
                (symbol? name) (clojure.lang.Keyword/find ^clojure.lang.Symbol name)
                (string? name) (clojure.lang.Keyword/find ^String name)))
  ([ns name] (clojure.lang.Keyword/find ns name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn spread
  {:private true
   :static true}
  [arglist]
  (cond
   (nil? arglist) nil
   (nil? (next arglist)) (seq (first arglist))
   :else (cons (first arglist) (spread (next arglist)))))</pre></td></tr><tr><td class="docs"><p>Creates a new list containing the items prepended to the rest, the
  last of which will be treated as a sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn list*
  {:added &quot;1.0&quot;
   :static true}
  ([args] (seq args))
  ([a args] (cons a args))
  ([a b args] (cons a (cons b args)))
  ([a b c args] (cons a (cons b (cons c args))))
  ([a b c d &amp; more]
     (cons a (cons b (cons c (cons d (spread more)))))))</pre></td></tr><tr><td class="docs"><p>Applies fn f to the argument list formed by prepending intervening arguments to args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply
  {:added &quot;1.0&quot;
   :static true}
  ([^clojure.lang.IFn f args]
     (. f (applyTo (seq args))))
  ([^clojure.lang.IFn f x args]
     (. f (applyTo (list* x args))))
  ([^clojure.lang.IFn f x y args]
     (. f (applyTo (list* x y args))))
  ([^clojure.lang.IFn f x y z args]
     (. f (applyTo (list* x y z args))))
  ([^clojure.lang.IFn f a b c d &amp; args]
     (. f (applyTo (cons a (cons b (cons c (cons d (spread args)))))))))</pre></td></tr><tr><td class="docs"><p>Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.</p>
</td><td class="codes"><pre class="brush: clojure">(defn vary-meta
 {:added &quot;1.0&quot;
   :static true}
 [obj f &amp; args]
  (with-meta obj (apply f (meta obj) args)))</pre></td></tr><tr><td class="docs"><p>Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro lazy-seq
  {:added &quot;1.0&quot;}
  [&amp; body]
  (list 'new 'clojure.lang.LazySeq (list* '^{:once true} fn* [] body)))    </pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static ^clojure.lang.ChunkBuffer chunk-buffer ^clojure.lang.ChunkBuffer [capacity]
  (clojure.lang.ChunkBuffer. capacity))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static chunk-append [^clojure.lang.ChunkBuffer b x]
  (.add b x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static ^clojure.lang.IChunk chunk [^clojure.lang.ChunkBuffer b]
  (.chunk b))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static  ^clojure.lang.IChunk chunk-first ^clojure.lang.IChunk [^clojure.lang.IChunkedSeq s]
  (.chunkedFirst s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static ^clojure.lang.ISeq chunk-rest ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]
  (.chunkedMore s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static ^clojure.lang.ISeq chunk-next ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]
  (.chunkedNext s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static chunk-cons [chunk rest]
  (if (clojure.lang.Numbers/isZero (clojure.lang.RT/count chunk))
    rest
    (clojure.lang.ChunkedCons. chunk rest)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static chunked-seq? [s]
  (instance? clojure.lang.IChunkedSeq s))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq representing the concatenation of the elements in the supplied colls.</p>
</td><td class="codes"><pre class="brush: clojure">(defn concat
  {:added &quot;1.0&quot;
   :static true}
  ([] (lazy-seq nil))
  ([x] (lazy-seq x))
  ([x y]
    (lazy-seq
      (let [s (seq x)]
        (if s
          (if (chunked-seq? s)
            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))
            (cons (first s) (concat (rest s) y)))
          y))))
  ([x y &amp; zs]
     (let [cat (fn cat [xys zs]
                 (lazy-seq
                   (let [xys (seq xys)]
                     (if xys
                       (if (chunked-seq? xys)
                         (chunk-cons (chunk-first xys)
                                     (cat (chunk-rest xys) zs))
                         (cons (first xys) (cat (rest xys) zs)))
                       (when zs
                         (cat (first zs) (next zs)))))))]
       (cat (concat x y) zs))))</pre></td></tr><tr><td class="docs"><p>Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?</p>

<p>at this point all the support for syntax-quote exists;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro delay
  {:added &quot;1.0&quot;}
  [&amp; body]
    (list 'new 'clojure.lang.Delay (list* `^{:once true} fn* [] body)))</pre></td></tr><tr><td class="docs"><p>returns true if x is a Delay created with delay</p>
</td><td class="codes"><pre class="brush: clojure">(defn delay?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.Delay x))</pre></td></tr><tr><td class="docs"><p>If x is a Delay, returns the (possibly cached) value of its expression, else returns x</p>
</td><td class="codes"><pre class="brush: clojure">(defn force
  {:added &quot;1.0&quot;
   :static true}
  [x] (. clojure.lang.Delay (force x)))</pre></td></tr><tr><td class="docs"><p>Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro if-not
  {:added &quot;1.0&quot;}
  ([test then] `(if-not ~test ~then nil))
  ([test then else]
   `(if (not ~test) ~then ~else)))</pre></td></tr><tr><td class="docs"><p>Tests if 2 arguments are the same object</p>
</td><td class="codes"><pre class="brush: clojure">(defn identical?
  {:inline (fn [x y] `(. clojure.lang.Util identical ~x ~y))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x y] (clojure.lang.Util/identical x y)))</pre></td></tr><tr><td class="docs"><p>Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.</p>

<p>equiv-based</p>
</td><td class="codes"><pre class="brush: clojure">(defn =
  {:inline (fn [x y] `(. clojure.lang.Util equiv ~x ~y))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (clojure.lang.Util/equiv x y))
  ([x y &amp; more]
   (if (clojure.lang.Util/equiv x y)
     (if (next more)
       (recur y (first more) (next more))
       (clojure.lang.Util/equiv y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Same as (not (= obj1 obj2))</p>

<p>equals-based</p>
</td><td class="codes"><pre class="brush: clojure">#_(defn =
  &quot;Equality. Returns true if x equals y, false if not. Same as Java
  x.equals(y) except it also works for nil. Boxed numbers must have
  same type. Clojure's immutable data structures define equals() (and
  thus =) as a value, not an identity, comparison.&quot;
  {:inline (fn [x y] `(. clojure.lang.Util equals ~x ~y))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (clojure.lang.Util/equals x y))
  ([x y &amp; more]
   (if (= x y)
     (if (next more)
       (recur y (first more) (next more))
       (= y (first more)))
     false)))
(defn not=
  {:tag Boolean
   :added &quot;1.0&quot;
   :static true}
  ([x] false)
  ([x y] (not (= x y)))
  ([x y &amp; more]
   (not (apply = x y more))))</pre></td></tr><tr><td class="docs"><p>Comparator. Returns a negative number, zero, or a positive number
  when x is logically 'less than', 'equal to', or 'greater than'
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable</p>
</td><td class="codes"><pre class="brush: clojure">(defn compare
  {
   :inline (fn [x y] `(. clojure.lang.Util compare ~x ~y))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Util (compare x y)))</pre></td></tr><tr><td class="docs"><p>Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro and
  {:added &quot;1.0&quot;}
  ([] true)
  ([x] x)
  ([x &amp; next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))</pre></td></tr><tr><td class="docs"><p>Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro or
  {:added &quot;1.0&quot;}
  ([] nil)
  ([x] x)
  ([x &amp; next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))</pre></td></tr><tr><td class="docs"><p>Returns true if num is zero, else false</p>

<p>sequence fns  ;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn zero?
  {
   :inline (fn [x] `(. clojure.lang.Numbers (isZero ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (isZero x)))</pre></td></tr><tr><td class="docs"><p>Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps</p>
</td><td class="codes"><pre class="brush: clojure">(defn count
  {
   :inline (fn  [x] `(. clojure.lang.RT (count ~x)))
   :added &quot;1.0&quot;}
  [coll] (clojure.lang.RT/count coll))</pre></td></tr><tr><td class="docs"><p>Coerce to int</p>
</td><td class="codes"><pre class="brush: clojure">(defn int
  {
   :inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedIntCast 'intCast) ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.RT (intCast x)))</pre></td></tr><tr><td class="docs"><p>Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nth
  {:inline (fn  [c i &amp; nf] `(. clojure.lang.RT (nth ~c ~i ~@nf)))
   :inline-arities #{2 3}
   :added &quot;1.0&quot;}
  ([coll index] (. clojure.lang.RT (nth coll index)))
  ([coll index not-found] (. clojure.lang.RT (nth coll index not-found))))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if nums are in monotonically increasing order,
  otherwise false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &lt;
  {:inline (fn [x y] `(. clojure.lang.Numbers (lt ~x ~y)))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (. clojure.lang.Numbers (lt x y)))
  ([x y &amp; more]
   (if (&lt; x y)
     (if (next more)
       (recur y (first more) (next more))
       (&lt; y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Returns a number one greater than num. Supports arbitrary precision.
  See also: inc</p>
</td><td class="codes"><pre class="brush: clojure">(defn inc'
  {:inline (fn [x] `(. clojure.lang.Numbers (incP ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (incP x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc'</p>
</td><td class="codes"><pre class="brush: clojure">(defn inc
  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_inc 'inc) ~x)))
   :added &quot;1.2&quot;}
  [x] (. clojure.lang.Numbers (inc x)))</pre></td></tr><tr><td class="docs"><p>reduce is defined again later after InternalReduce loads</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private ^:static
  reduce1
       ([f coll]
             (let [s (seq coll)]
               (if s
         (reduce1 f (first s) (next s))
                 (f))))
       ([f val coll]
          (let [s (seq coll)]
            (if s
              (if (chunked-seq? s)
                (recur f 
                       (.reduce (chunk-first s) f val)
                       (chunk-next s))
                (recur f (f val (first s)) (next s)))
         val))))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the items in coll in reverse order. Not lazy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reverse
  {:added &quot;1.0&quot;
   :static true}
  [coll]
    (reduce1 conj () coll))</pre></td></tr><tr><td class="docs"><p>math stuff</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private nary-inline
  ([op] (nary-inline op op))
  ([op unchecked-op]
     (fn
       ([x] (let [op (if *unchecked-math* unchecked-op op)]
              `(. clojure.lang.Numbers (~op ~x))))
       ([x y] (let [op (if *unchecked-math* unchecked-op op)]
                `(. clojure.lang.Numbers (~op ~x ~y))))
       ([x y &amp; more]
          (let [op (if *unchecked-math* unchecked-op op)]
            (reduce1
             (fn [a b] `(. clojure.lang.Numbers (~op ~a ~b)))
             `(. clojure.lang.Numbers (~op ~x ~y)) more))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:private &gt;1? [n] (clojure.lang.Numbers/gt n 1))
(defn ^:private &gt;0? [n] (clojure.lang.Numbers/gt n 0))</pre></td></tr><tr><td class="docs"><p>Returns the sum of nums. (+) returns 0. Supports arbitrary precision.
  See also: +</p>
</td><td class="codes"><pre class="brush: clojure">(defn +'
  {:inline (nary-inline 'addP)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;}
  ([] 0)
  ([x] (cast Number x))
  ([x y] (. clojure.lang.Numbers (addP x y)))
  ([x y &amp; more]
   (reduce1 +' (+' x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +'</p>
</td><td class="codes"><pre class="brush: clojure">(defn +
  {:inline (nary-inline 'add 'unchecked_add)
   :inline-arities &gt;1?
   :added &quot;1.2&quot;}
  ([] 0)
  ([x] (cast Number x))
  ([x y] (. clojure.lang.Numbers (add x y)))
  ([x y &amp; more]
     (reduce1 + (+ x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns the product of nums. (*) returns 1. Supports arbitrary precision.
  See also: *</p>
</td><td class="codes"><pre class="brush: clojure">(defn *'
  {:inline (nary-inline 'multiplyP)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;}
  ([] 1)
  ([x] (cast Number x))
  ([x y] (. clojure.lang.Numbers (multiplyP x y)))
  ([x y &amp; more]
   (reduce1 *' (*' x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *'</p>
</td><td class="codes"><pre class="brush: clojure">(defn *
  {:inline (nary-inline 'multiply 'unchecked_multiply)
   :inline-arities &gt;1?
   :added &quot;1.2&quot;}
  ([] 1)
  ([x] (cast Number x))
  ([x y] (. clojure.lang.Numbers (multiply x y)))
  ([x y &amp; more]
     (reduce1 * (* x y) more)))</pre></td></tr><tr><td class="docs"><p>If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.</p>
</td><td class="codes"><pre class="brush: clojure">(defn /
  {:inline (nary-inline 'divide)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;}
  ([x] (/ 1 x))
  ([x y] (. clojure.lang.Numbers (divide x y)))
  ([x y &amp; more]
   (reduce1 / (/ x y) more)))</pre></td></tr><tr><td class="docs"><p>If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -</p>
</td><td class="codes"><pre class="brush: clojure">(defn -'
  {:inline (nary-inline 'minusP)
   :inline-arities &gt;0?
   :added &quot;1.0&quot;}
  ([x] (. clojure.lang.Numbers (minusP x)))
  ([x y] (. clojure.lang.Numbers (minusP x y)))
  ([x y &amp; more]
   (reduce1 -' (-' x y) more)))</pre></td></tr><tr><td class="docs"><p>If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -'</p>
</td><td class="codes"><pre class="brush: clojure">(defn -
  {:inline (nary-inline 'minus 'unchecked_minus)
   :inline-arities &gt;0?
   :added &quot;1.2&quot;}
  ([x] (. clojure.lang.Numbers (minus x)))
  ([x y] (. clojure.lang.Numbers (minus x y)))
  ([x y &amp; more]
     (reduce1 - (- x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &lt;=
  {:inline (fn [x y] `(. clojure.lang.Numbers (lte ~x ~y)))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (. clojure.lang.Numbers (lte x y)))
  ([x y &amp; more]
   (if (&lt;= x y)
     (if (next more)
       (recur y (first more) (next more))
       (&lt;= y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &gt;
  {:inline (fn [x y] `(. clojure.lang.Numbers (gt ~x ~y)))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (. clojure.lang.Numbers (gt x y)))
  ([x y &amp; more]
   (if (&gt; x y)
     (if (next more)
       (recur y (first more) (next more))
       (&gt; y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn &gt;=
  {:inline (fn [x y] `(. clojure.lang.Numbers (gte ~x ~y)))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (. clojure.lang.Numbers (gte x y)))
  ([x y &amp; more]
   (if (&gt;= x y)
     (if (next more)
       (recur y (first more) (next more))
       (&gt;= y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false</p>
</td><td class="codes"><pre class="brush: clojure">(defn ==
  {:inline (fn [x y] `(. clojure.lang.Numbers (equiv ~x ~y)))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([x] true)
  ([x y] (. clojure.lang.Numbers (equiv x y)))
  ([x y &amp; more]
   (if (== x y)
     (if (next more)
       (recur y (first more) (next more))
       (== y (first more)))
     false)))</pre></td></tr><tr><td class="docs"><p>Returns the greatest of the nums.</p>
</td><td class="codes"><pre class="brush: clojure">(defn max
  {:added &quot;1.0&quot;
   :inline-arities &gt;1?
   :inline (nary-inline 'max)}
  ([x] x)
  ([x y] (. clojure.lang.Numbers (max x y)))
  ([x y &amp; more]
   (reduce1 max (max x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns the least of the nums.</p>
</td><td class="codes"><pre class="brush: clojure">(defn min
  {:added &quot;1.0&quot;
   :inline-arities &gt;1?
   :inline (nary-inline 'min)}
  ([x] x)
  ([x y] (. clojure.lang.Numbers (min x y)))
  ([x y &amp; more]
   (reduce1 min (min x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns a number one less than num. Supports arbitrary precision.
  See also: dec</p>
</td><td class="codes"><pre class="brush: clojure">(defn dec'
  {:inline (fn [x] `(. clojure.lang.Numbers (decP ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (decP x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec'</p>
</td><td class="codes"><pre class="brush: clojure">(defn dec
  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_dec 'dec) ~x)))
   :added &quot;1.2&quot;}
  [x] (. clojure.lang.Numbers (dec x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one greater than x, an int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-inc-int
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_inc ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_int_inc x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-inc
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_inc ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_inc x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one less than x, an int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-dec-int
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_dec ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_int_dec x)))</pre></td></tr><tr><td class="docs"><p>Returns a number one less than x, a long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-dec
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_dec ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_dec x)))</pre></td></tr><tr><td class="docs"><p>Returns the negation of x, an int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-negate-int
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_negate ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_int_negate x)))</pre></td></tr><tr><td class="docs"><p>Returns the negation of x, a long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-negate
  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_minus ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (unchecked_minus x)))</pre></td></tr><tr><td class="docs"><p>Returns the sum of x and y, both int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-add-int
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_add ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_int_add x y)))</pre></td></tr><tr><td class="docs"><p>Returns the sum of x and y, both long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-add
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_add ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_add x y)))</pre></td></tr><tr><td class="docs"><p>Returns the difference of x and y, both int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-subtract-int
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_subtract ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_int_subtract x y)))</pre></td></tr><tr><td class="docs"><p>Returns the difference of x and y, both long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-subtract
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_minus ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_minus x y)))</pre></td></tr><tr><td class="docs"><p>Returns the product of x and y, both int.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-multiply-int
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_multiply ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_int_multiply x y)))</pre></td></tr><tr><td class="docs"><p>Returns the product of x and y, both long.
  Note - uses a primitive operator subject to overflow.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-multiply
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_multiply ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_multiply x y)))</pre></td></tr><tr><td class="docs"><p>Returns the division of x by y, both int.
  Note - uses a primitive operator subject to truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-divide-int
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_divide ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_int_divide x y)))</pre></td></tr><tr><td class="docs"><p>Returns the remainder of division of x by y, both int.
  Note - uses a primitive operator subject to truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-remainder-int
  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_remainder ~x ~y)))
   :added &quot;1.0&quot;}
  [x y] (. clojure.lang.Numbers (unchecked_int_remainder x y)))</pre></td></tr><tr><td class="docs"><p>Returns true if num is greater than zero, else false</p>
</td><td class="codes"><pre class="brush: clojure">(defn pos?
  {
   :inline (fn [x] `(. clojure.lang.Numbers (isPos ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (isPos x)))</pre></td></tr><tr><td class="docs"><p>Returns true if num is less than zero, else false</p>
</td><td class="codes"><pre class="brush: clojure">(defn neg?
  {
   :inline (fn [x] `(. clojure.lang.Numbers (isNeg ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (isNeg x)))</pre></td></tr><tr><td class="docs"><p>quot[ient] of dividing numerator by denominator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn quot
  {:added &quot;1.0&quot;
   :static true
   :inline (fn [x y] `(. clojure.lang.Numbers (quotient ~x ~y)))}
  [num div]
    (. clojure.lang.Numbers (quotient num div)))</pre></td></tr><tr><td class="docs"><p>remainder of dividing numerator by denominator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn rem
  {:added &quot;1.0&quot;
   :static true
   :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}
  [num div]
    (. clojure.lang.Numbers (remainder num div)))</pre></td></tr><tr><td class="docs"><p>returns the rational value of num</p>
</td><td class="codes"><pre class="brush: clojure">(defn rationalize
  {:added &quot;1.0&quot;
   :static true}
  [num]
  (. clojure.lang.Numbers (rationalize num)))</pre></td></tr><tr><td class="docs"><p>Bit ops</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Bitwise complement</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-not
  {:inline (fn [x] `(. clojure.lang.Numbers (not ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers not x))</pre></td></tr><tr><td class="docs"><p>Bitwise and</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-and
   {:inline (nary-inline 'and)
    :inline-arities &gt;1?
    :added &quot;1.0&quot;}
   ([x y] (. clojure.lang.Numbers and x y))
   ([x y &amp; more]
      (reduce1 bit-and (bit-and x y) more)))</pre></td></tr><tr><td class="docs"><p>Bitwise or</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-or
  {:inline (nary-inline 'or)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;}
  ([x y] (. clojure.lang.Numbers or x y))
  ([x y &amp; more]
    (reduce1 bit-or (bit-or x y) more)))</pre></td></tr><tr><td class="docs"><p>Bitwise exclusive or</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-xor
  {:inline (nary-inline 'xor)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;}
  ([x y] (. clojure.lang.Numbers xor x y))
  ([x y &amp; more]
    (reduce1 bit-xor (bit-xor x y) more)))</pre></td></tr><tr><td class="docs"><p>Bitwise and with complement</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-and-not
  {:inline (nary-inline 'andNot)
   :inline-arities &gt;1?
   :added &quot;1.0&quot;
   :static true}
  ([x y] (. clojure.lang.Numbers andNot x y))
  ([x y &amp; more]
    (reduce1 bit-and-not (bit-and-not x y) more)))</pre></td></tr><tr><td class="docs"><p>Clear bit at index n</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-clear
  {:added &quot;1.0&quot;
   :static true}
  [x n] (. clojure.lang.Numbers clearBit x n))</pre></td></tr><tr><td class="docs"><p>Set bit at index n</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-set
  {:added &quot;1.0&quot;
   :static true}
  [x n] (. clojure.lang.Numbers setBit x n))</pre></td></tr><tr><td class="docs"><p>Flip bit at index n</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-flip
  {:added &quot;1.0&quot;
   :static true}
  [x n] (. clojure.lang.Numbers flipBit x n))</pre></td></tr><tr><td class="docs"><p>Test bit at index n</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-test
  {:added &quot;1.0&quot;
   :static true}
  [x n] (. clojure.lang.Numbers testBit x n))</pre></td></tr><tr><td class="docs"><p>Bitwise shift left</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-shift-left
  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftLeft ~x ~n)))
   :added &quot;1.0&quot;}
  [x n] (. clojure.lang.Numbers shiftLeft x n))</pre></td></tr><tr><td class="docs"><p>Bitwise shift right</p>
</td><td class="codes"><pre class="brush: clojure">(defn bit-shift-right
  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftRight ~x ~n)))
   :added &quot;1.0&quot;}
  [x n] (. clojure.lang.Numbers shiftRight x n))</pre></td></tr><tr><td class="docs"><p>Returns true if n is an integer</p>
</td><td class="codes"><pre class="brush: clojure">(defn integer?
  {:added &quot;1.0&quot;
   :static true}
  [n]
  (or (instance? Integer n)
      (instance? Long n)
      (instance? clojure.lang.BigInt n)
      (instance? BigInteger n)
      (instance? Short n)
      (instance? Byte n)))</pre></td></tr><tr><td class="docs"><p>Returns true if n is even, throws an exception if n is not an integer</p>
</td><td class="codes"><pre class="brush: clojure">(defn even?
  {:added &quot;1.0&quot;
   :static true}
   [n] (if (integer? n)
        (zero? (bit-and (clojure.lang.RT/uncheckedLongCast n) 1))
        (throw (IllegalArgumentException. (str &quot;Argument must be an integer: &quot; n)))))</pre></td></tr><tr><td class="docs"><p>Returns true if n is odd, throws an exception if n is not an integer</p>
</td><td class="codes"><pre class="brush: clojure">(defn odd?
  {:added &quot;1.0&quot;
   :static true}
  [n] (not (even? n)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn complement
  {:added &quot;1.0&quot;
   :static true}
  [f] 
  (fn 
    ([] (not (f)))
    ([x] (not (f x)))
    ([x y] (not (f x y)))
    ([x y &amp; zs] (not (apply f x y zs)))))</pre></td></tr><tr><td class="docs"><p>Returns a function that takes any number of arguments and returns x.</p>
</td><td class="codes"><pre class="brush: clojure">(defn constantly
  {:added &quot;1.0&quot;
   :static true}
  [x] (fn [&amp; args] x))</pre></td></tr><tr><td class="docs"><p>Returns its argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn identity
  {:added &quot;1.0&quot;
   :static true}
  [x] x)</pre></td></tr><tr><td class="docs"><p>Collection stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.</p>

<p>list stuff</p>
</td><td class="codes"><pre class="brush: clojure">(defn peek
  {:added &quot;1.0&quot;
   :static true}
  [coll] (. clojure.lang.RT (peek coll)))</pre></td></tr><tr><td class="docs"><p>For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pop
  {:added &quot;1.0&quot;
   :static true}
  [coll] (. clojure.lang.RT (pop coll)))</pre></td></tr><tr><td class="docs"><p>map stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. 'contains?' operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also 'some'.</p>
</td><td class="codes"><pre class="brush: clojure">(defn contains?
  {:added &quot;1.0&quot;
   :static true}
  [coll key] (. clojure.lang.RT (contains coll key)))</pre></td></tr><tr><td class="docs"><p>Returns the value mapped to key, not-found or nil if key not present.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get
  {:inline (fn  [m k &amp; nf] `(. clojure.lang.RT (get ~m ~k ~@nf)))
   :inline-arities #{2 3}
   :added &quot;1.0&quot;}
  ([map key]
   (. clojure.lang.RT (get map key)))
  ([map key not-found]
   (. clojure.lang.RT (get map key not-found))))</pre></td></tr><tr><td class="docs"><p>dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).</p>
</td><td class="codes"><pre class="brush: clojure">(defn dissoc
  {:added &quot;1.0&quot;
   :static true}
  ([map] map)
  ([map key]
   (. clojure.lang.RT (dissoc map key)))
  ([map key &amp; ks]
   (let [ret (dissoc map key)]
     (if ks
       (recur ret (first ks) (next ks))
       ret))))</pre></td></tr><tr><td class="docs"><p>disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).</p>
</td><td class="codes"><pre class="brush: clojure">(defn disj
  {:added &quot;1.0&quot;
   :static true}
  ([set] set)
  ([^clojure.lang.IPersistentSet set key]
   (when set
     (. set (disjoin key))))
  ([set key &amp; ks]
   (when set
     (let [ret (disj set key)]
       (if ks
         (recur ret (first ks) (next ks))
         ret)))))</pre></td></tr><tr><td class="docs"><p>Returns the map entry for key, or nil if key not present.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find
  {:added &quot;1.0&quot;
   :static true}
  [map key] (. clojure.lang.RT (find map key)))</pre></td></tr><tr><td class="docs"><p>Returns a map containing only those entries in map whose key is in keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-keys
  {:added &quot;1.0&quot;
   :static true}
  [map keyseq]
    (loop [ret {} keys (seq keyseq)]
      (if keys
        (let [entry (. clojure.lang.RT (find map (first keys)))]
          (recur
           (if entry
             (conj ret entry)
             ret)
           (next keys)))
        ret)))</pre></td></tr><tr><td class="docs"><p>Returns a sequence of the map's keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keys
  {:added &quot;1.0&quot;
   :static true}
  [map] (. clojure.lang.RT (keys map)))</pre></td></tr><tr><td class="docs"><p>Returns a sequence of the map's values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn vals
  {:added &quot;1.0&quot;
   :static true}
  [map] (. clojure.lang.RT (vals map)))</pre></td></tr><tr><td class="docs"><p>Returns the key of the map entry.</p>
</td><td class="codes"><pre class="brush: clojure">(defn key
  {:added &quot;1.0&quot;
   :static true}
  [^java.util.Map$Entry e]
    (. e (getKey)))</pre></td></tr><tr><td class="docs"><p>Returns the value in the map entry.</p>
</td><td class="codes"><pre class="brush: clojure">(defn val
  {:added &quot;1.0&quot;
   :static true}
  [^java.util.Map$Entry e]
    (. e (getValue)))</pre></td></tr><tr><td class="docs"><p>Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil</p>
</td><td class="codes"><pre class="brush: clojure">(defn rseq
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Reversible rev]
    (. rev (rseq)))</pre></td></tr><tr><td class="docs"><p>Returns the name String of a string, symbol or keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defn name
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [x]
  (if (string? x) x (. ^clojure.lang.Named x (getName))))</pre></td></tr><tr><td class="docs"><p>Returns the namespace String of a symbol or keyword, or nil if not present.</p>
</td><td class="codes"><pre class="brush: clojure">(defn namespace
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Named x]
    (. x (getNamespace)))</pre></td></tr><tr><td class="docs"><p>Executes exprs in an implicit do, while holding the monitor of x.
  Will release the monitor of x in all circumstances.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro locking
  {:added &quot;1.0&quot;}
  [x &amp; body]
  `(let [lockee# ~x]
     (try
      (monitor-enter lockee#)
      ~@body
      (finally
       (monitor-exit lockee#)))))</pre></td></tr><tr><td class="docs"><p>form => fieldName-symbol or (instanceMethodName-symbol args*)</p>

<p>  Expands into a member access (.) of the first member on the first
  argument, followed by the next member on the result, etc. For
  instance:</p>

<p>  (.. System (getProperties) (get "os.name"))</p>

<p>  expands to:</p>

<p>  (. (. System (getProperties)) (get "os.name"))</p>

<p>  but is easier to write, read, and understand.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ..
  {:added &quot;1.0&quot;}
  ([x form] `(. ~x ~form))
  ([x form &amp; more] `(.. (. ~x ~form) ~@more)))</pre></td></tr><tr><td class="docs"><p>Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro -&gt;
  {:added &quot;1.0&quot;}
  ([x] x)
  ([x form] (if (seq? form)
              (with-meta `(~(first form) ~x ~@(next form)) (meta form))
              (list form x)))
  ([x form &amp; more] `(-&gt; (-&gt; ~x ~form) ~@more)))</pre></td></tr><tr><td class="docs"><p>Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro -&gt;&gt;
  {:added &quot;1.1&quot;} 
  ([x form] (if (seq? form)
              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
              (list form x)))
  ([x form &amp; more] `(-&gt;&gt; (-&gt;&gt; ~x ~form) ~@more)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def map)</pre></td></tr><tr><td class="docs"><p>Throws an exception if the given option map contains keys not listed
  as valid, else returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private check-valid-options
  [options &amp; valid-keys]
  (when (seq (apply disj (apply hash-set (keys options)) valid-keys))
    (throw
      (IllegalArgumentException.
        (apply str &quot;Only these options are valid: &quot;
          (first valid-keys)
          (map #(str &quot;, &quot; %) (rest valid-keys)))))))</pre></td></tr><tr><td class="docs"><p>multimethods</p>
</td><td class="codes"><pre class="brush: clojure">(def global-hierarchy)</pre></td></tr><tr><td class="docs"><p>Creates a new multimethod with the associated dispatch function.
  The docstring and attribute-map are optional.</p>

<p>  Options are key-value pairs and may be one of:
    :default    the default dispatch value, defaults to :default
    :hierarchy  the isa? hierarchy to use for dispatching
                defaults to the global hierarchy</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmulti
  {:arglists '([name docstring? attr-map? dispatch-fn &amp; options])
   :added &quot;1.0&quot;}
  [mm-name &amp; options]
  (let [docstring   (if (string? (first options))
                      (first options)
                      nil)
        options     (if (string? (first options))
                      (next options)
                      options)
        m           (if (map? (first options))
                      (first options)
                      {})
        options     (if (map? (first options))
                      (next options)
                      options)
        dispatch-fn (first options)
        options     (next options)
        m           (if docstring
                      (assoc m :doc docstring)
                      m)
        m           (if (meta mm-name)
                      (conj (meta mm-name) m)
                      m)]
    (when (= (count options) 1)
      (throw (Exception. &quot;The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)&quot;)))
    (let [options   (apply hash-map options)
          default   (get options :default :default)
          hierarchy (get options :hierarchy #'global-hierarchy)]
      (check-valid-options options :default :hierarchy)
      `(let [v# (def ~mm-name)]
         (when-not (and (.hasRoot v#) (instance? clojure.lang.MultiFn (deref v#)))
           (def ~(with-meta mm-name m)
                (new clojure.lang.MultiFn ~(name mm-name) ~dispatch-fn ~default ~hierarchy)))))))</pre></td></tr><tr><td class="docs"><p>Creates and installs a new method of multimethod associated with dispatch-value. </p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmethod
  {:added &quot;1.0&quot;}
  [multifn dispatch-val &amp; fn-tail]
  `(. ~(with-meta multifn {:tag 'clojure.lang.MultiFn}) addMethod ~dispatch-val (fn ~@fn-tail)))</pre></td></tr><tr><td class="docs"><p>Removes all of the methods of multimethod.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-all-methods
  {:added &quot;1.2&quot;
   :static true} 
 [^clojure.lang.MultiFn multifn]
 (.reset multifn))</pre></td></tr><tr><td class="docs"><p>Removes the method of multimethod associated with dispatch-value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-method
  {:added &quot;1.0&quot;
   :static true}
 [^clojure.lang.MultiFn multifn dispatch-val]
 (. multifn removeMethod dispatch-val))</pre></td></tr><tr><td class="docs"><p>Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y 
   when there is a conflict</p>
</td><td class="codes"><pre class="brush: clojure">(defn prefer-method
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.MultiFn multifn dispatch-val-x dispatch-val-y]
  (. multifn preferMethod dispatch-val-x dispatch-val-y))</pre></td></tr><tr><td class="docs"><p>Given a multimethod, returns a map of dispatch values -> dispatch fns</p>
</td><td class="codes"><pre class="brush: clojure">(defn methods
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.MultiFn multifn] (.getMethodTable multifn))</pre></td></tr><tr><td class="docs"><p>Given a multimethod and a dispatch value, returns the dispatch fn
  that would apply to that value, or nil if none apply and no default</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-method
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.MultiFn multifn dispatch-val] (.getMethod multifn dispatch-val))</pre></td></tr><tr><td class="docs"><p>Given a multimethod, returns a map of preferred value -> set of other values</p>
</td><td class="codes"><pre class="brush: clojure">(defn prefers
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.MultiFn multifn] (.getPreferTable multifn))</pre></td></tr><tr><td class="docs"><p>var stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} assert-args
  [&amp; pairs]
  `(do (when-not ~(first pairs)
         (throw (IllegalArgumentException.
                  (str (first ~'&amp;form) &quot; requires &quot; ~(second pairs) &quot; in &quot; ~'*ns* &quot;:&quot; (:line (meta ~'&amp;form))))))
     ~(let [more (nnext pairs)]
        (when more
          (list* `assert-args more)))))</pre></td></tr><tr><td class="docs"><p>bindings => binding-form test</p>

<p>  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro if-let
  {:added &quot;1.0&quot;}
  ([bindings then]
   `(if-let ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (nil? oldform) &quot;1 or 2 forms after binding vector&quot;
     (= 2 (count bindings)) &quot;exactly 2 forms in binding vector&quot;)
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))</pre></td></tr><tr><td class="docs"><p>bindings => binding-form test</p>

<p>  When test is true, evaluates body with binding-form bound to the value of test</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when-let
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (= 2 (count bindings)) &quot;exactly 2 forms in binding vector&quot;)
   (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (when temp#
         (let [~form temp#]
           ~@body)))))</pre></td></tr><tr><td class="docs"><p>WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.</p>

<p>  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call <em>MUST</em> be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!</p>

<pre><code>  (push-thread-bindings bindings)
  (try
    ...
    (finally
      (pop-thread-bindings)))
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn push-thread-bindings
  {:added &quot;1.1&quot;
   :static true} 
  [bindings]
  (clojure.lang.Var/pushThreadBindings bindings))</pre></td></tr><tr><td class="docs"><p>Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pop-thread-bindings
  {:added &quot;1.1&quot;
   :static true}
  []
  (clojure.lang.Var/popThreadBindings))</pre></td></tr><tr><td class="docs"><p>Get a map with the Var/value pairs which is currently in effect for the
  current thread.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-thread-bindings
  {:added &quot;1.1&quot;
   :static true}
  []
  (clojure.lang.Var/getThreadBindings))</pre></td></tr><tr><td class="docs"><p>binding => var-symbol init-expr</p>

<p>  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro binding
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (assert-args
    (vector? bindings) &quot;a vector for its binding&quot;
    (even? (count bindings)) &quot;an even number of forms in binding vector&quot;)
  (let [var-ize (fn [var-vals]
                  (loop [ret [] vvs (seq var-vals)]
                    (if vvs
                      (recur  (conj (conj ret `(var ~(first vvs))) (second vvs))
                             (next (next vvs)))
                      (seq ret))))]
    `(let []
       (push-thread-bindings (hash-map ~@(var-ize bindings)))
       (try
         ~@body
         (finally
           (pop-thread-bindings))))))</pre></td></tr><tr><td class="docs"><p>Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.</p>
</td><td class="codes"><pre class="brush: clojure">(defn with-bindings*
  {:added &quot;1.1&quot;
   :static true}
  [binding-map f &amp; args]
  (push-thread-bindings binding-map)
  (try
    (apply f args)
    (finally
      (pop-thread-bindings))))</pre></td></tr><tr><td class="docs"><p>Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. The executes body. Pops the installed
  bindings after body was evaluated. Returns the value of body.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-bindings
  {:added &quot;1.1&quot;}
  [binding-map &amp; body]
  `(with-bindings* ~binding-map (fn [] ~@body)))</pre></td></tr><tr><td class="docs"><p>Returns a function, which will install the same bindings in effect as in
  the thread at the time bound-fn* was called and then call f with any given
  arguments. This may be used to define a helper function which runs on a
  different thread, but needs the same bindings in place.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bound-fn*
  {:added &quot;1.1&quot;
   :static true}
  [f]
  (let [bindings (get-thread-bindings)]
    (fn [&amp; args]
      (apply with-bindings* bindings f args))))</pre></td></tr><tr><td class="docs"><p>Returns a function defined by the given fntail, which will install the
  same bindings in effect as in the thread at the time bound-fn was called.
  This may be used to define a helper function which runs on a different
  thread, but needs the same bindings in place.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro bound-fn
  {:added &quot;1.1&quot;}
  [&amp; fntail]
  `(bound-fn* (fn ~@fntail)))</pre></td></tr><tr><td class="docs"><p>Returns the global var named by the namespace-qualified symbol, or
  nil if no var with that name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-var
  {:added &quot;1.0&quot;
   :static true}
  [sym] (. clojure.lang.Var (find sym)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn binding-conveyor-fn
  {:private true
   :added &quot;1.3&quot;}
  [f]
  (let [frame (clojure.lang.Var/cloneThreadBindingFrame)]
    (fn 
      ([]
         (clojure.lang.Var/resetThreadBindingFrame frame)
         (f))
      ([x]
         (clojure.lang.Var/resetThreadBindingFrame frame)
         (f x))
      ([x y]
         (clojure.lang.Var/resetThreadBindingFrame frame)
         (f x y))
      ([x y z]
         (clojure.lang.Var/resetThreadBindingFrame frame)
         (f x y z))
      ([x y z &amp; args] 
         (clojure.lang.Var/resetThreadBindingFrame frame)
         (apply f x y z args)))))</pre></td></tr><tr><td class="docs"><p>Refs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:private true}
  setup-reference [^clojure.lang.ARef r options]
  (let [opts (apply hash-map options)]
    (when (:meta opts)
      (.resetMeta r (:meta opts)))
    (when (:validator opts)
      (.setValidator r (:validator opts)))
    r))</pre></td></tr><tr><td class="docs"><p>Creates and returns an agent with an initial value of state and
  zero or more options (in any order):</p>

<p>  :meta metadata-map</p>

<p>  :validator validate-fn</p>

<p>  :error-handler handler-fn</p>

<p>  :error-mode mode-keyword</p>

<p>  If metadata-map is supplied, it will be come the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent
  {:added &quot;1.0&quot;
   :static true
   }
  ([state &amp; options]
     (let [a (new clojure.lang.Agent state)
           opts (apply hash-map options)]
       (setup-reference a options)
       (when (:error-handler opts)
         (.setErrorHandler a (:error-handler opts)))
       (.setErrorMode a (or (:error-mode opts)
                            (if (:error-handler opts) :continue :fail)))
       a)))</pre></td></tr><tr><td class="docs"><p>Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:</p>

<p>  (apply action-fn state-of-agent args)</p>
</td><td class="codes"><pre class="brush: clojure">(defn send
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Agent a f &amp; args]
  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args false))</pre></td></tr><tr><td class="docs"><p>Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:</p>

<p>  (apply action-fn state-of-agent args)</p>
</td><td class="codes"><pre class="brush: clojure">(defn send-off
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Agent a f &amp; args]
  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args true))</pre></td></tr><tr><td class="docs"><p>Normally, actions sent directly or indirectly during another action
  are held until the action completes (changes the agent's
  state). This function can be used to dispatch any pending sent
  actions immediately. This has no impact on actions sent during a
  transaction, which are still held until commit. If no action is
  occurring, does nothing. Returns the number of actions dispatched.</p>
</td><td class="codes"><pre class="brush: clojure">(defn release-pending-sends
  {:added &quot;1.0&quot;
   :static true}
  [] (clojure.lang.Agent/releasePendingSends))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Adds a watch function to an agent/atom/var/ref reference. The watch
  fn must be a fn of 4 args: a key, the reference, its old-state, its
  new-state. Whenever the reference's state might have been changed,
  any registered watches will have their functions called. The watch fn
  will be called synchronously, on the agent's thread if an agent,
  before any pending sends if agent or ref. Note that an atom's or
  ref's state may have changed again prior to the fn call, so use
  old/new-state rather than derefing the reference. Note also that watch
  fns may be called from multiple threads simultaneously. Var watchers
  are triggered only by root binding changes, not thread-local
  set!s. Keys must be unique per reference, and can be used to remove
  the watch with remove-watch, but are otherwise considered opaque by
  the watch mechanism.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-watch
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.IRef reference key fn] (.addWatch reference key fn))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Removes a watch (set by add-watch) from a reference</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-watch
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.IRef reference key]
  (.removeWatch reference key))</pre></td></tr><tr><td class="docs"><p>Returns the exception thrown during an asynchronous action of the
  agent if the agent is failed.  Returns nil if the agent is not
  failed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-error
  {:added &quot;1.2&quot;
   :static true}
  [^clojure.lang.Agent a] (.getError a))</pre></td></tr><tr><td class="docs"><p>When an agent is failed, changes the agent state to new-state and
  then un-fails the agent so that sends are allowed again.  If
  a :clear-actions true option is given, any actions queued on the
  agent that were being held while it was failed will be discarded,
  otherwise those held actions will proceed.  The new-state must pass
  the validator if any, or restart will throw an exception and the
  agent will remain failed with its old state and error.  Watchers, if
  any, will NOT be notified of the new state.  Throws an exception if
  the agent is not failed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn restart-agent
  {:added &quot;1.2&quot;
   :static true
   }
  [^clojure.lang.Agent a, new-state &amp; options]
  (let [opts (apply hash-map options)]
    (.restart a new-state (if (:clear-actions opts) true false))))</pre></td></tr><tr><td class="docs"><p>Sets the error-handler of agent a to handler-fn.  If an action
  being run by the agent throws an exception or doesn't pass the
  validator fn, handler-fn will be called with two arguments: the
  agent and the exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-error-handler!
  {:added &quot;1.2&quot;
   :static true}
  [^clojure.lang.Agent a, handler-fn]
  (.setErrorHandler a handler-fn))</pre></td></tr><tr><td class="docs"><p>Returns the error-handler of agent a, or nil if there is none.
  See set-error-handler!</p>
</td><td class="codes"><pre class="brush: clojure">(defn error-handler
  {:added &quot;1.2&quot;
   :static true}
  [^clojure.lang.Agent a]
  (.getErrorHandler a))</pre></td></tr><tr><td class="docs"><p>Sets the error-mode of agent a to mode-keyword, which must be
  either :fail or :continue.  If an action being run by the agent
  throws an exception or doesn't pass the validator fn, an
  error-handler may be called (see set-error-handler!), after which,
  if the mode is :continue, the agent will continue as if neither the
  action that caused the error nor the error itself ever happened.</p>

<p>  If the mode is :fail, the agent will become failed and will stop
  accepting new 'send' and 'send-off' actions, and any previously
  queued actions will be held until a 'restart-agent'.  Deref will
  still work, returning the state of the agent before the error.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-error-mode!
  {:added &quot;1.2&quot;
   :static true}
  [^clojure.lang.Agent a, mode-keyword]
  (.setErrorMode a mode-keyword))</pre></td></tr><tr><td class="docs"><p>Returns the error-mode of agent a.  See set-error-mode!</p>
</td><td class="codes"><pre class="brush: clojure">(defn error-mode
  {:added &quot;1.2&quot;
   :static true}
  [^clojure.lang.Agent a]
  (.getErrorMode a))</pre></td></tr><tr><td class="docs"><p>DEPRECATED: Use 'agent-error' instead.
  Returns a sequence of the exceptions thrown during asynchronous
  actions of the agent.</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-errors
  {:added &quot;1.0&quot;
   :deprecated &quot;1.2&quot;}
  [a]
  (when-let [e (agent-error a)]
    (list e)))</pre></td></tr><tr><td class="docs"><p>DEPRECATED: Use 'restart-agent' instead.
  Clears any exceptions thrown during asynchronous actions of the
  agent, allowing subsequent actions to occur.</p>
</td><td class="codes"><pre class="brush: clojure">(defn clear-agent-errors
  {:added &quot;1.0&quot;
   :deprecated &quot;1.2&quot;}
  [^clojure.lang.Agent a] (restart-agent a (.deref a)))</pre></td></tr><tr><td class="docs"><p>Initiates a shutdown of the thread pools that back the agent
  system. Running actions will complete, but no new actions will be
  accepted</p>
</td><td class="codes"><pre class="brush: clojure">(defn shutdown-agents
  {:added &quot;1.0&quot;
   :static true}
  [] (. clojure.lang.Agent shutdown))</pre></td></tr><tr><td class="docs"><p>Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):</p>

<p>  :meta metadata-map</p>

<p>  :validator validate-fn</p>

<p>  :min-history (default 0)
  :max-history (default 10)</p>

<p>  If metadata-map is supplied, it will be come the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.</p>

<p>  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ref
  {:added &quot;1.0&quot;
   :static true
   }
  ([x] (new clojure.lang.Ref x))
  ([x &amp; options] 
   (let [r  ^clojure.lang.Ref (setup-reference (ref x) options)
         opts (apply hash-map options)]
    (when (:max-history opts)
      (.setMaxHistory r (:max-history opts)))
    (when (:min-history opts)
      (.setMinHistory r (:min-history opts)))
    r)))</pre></td></tr><tr><td class="docs"><p>Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deref
  {:added &quot;1.0&quot;
   :static true}
  ([^clojure.lang.IDeref ref] (.deref ref))
  ([^clojure.lang.IBlockingDeref ref timeout-ms timeout-val] (.deref ref timeout-ms timeout-val)))</pre></td></tr><tr><td class="docs"><p>Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):</p>

<p>  :meta metadata-map</p>

<p>  :validator validate-fn</p>

<p>  If metadata-map is supplied, it will be come the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn atom
  {:added &quot;1.0&quot;
   :static true}
  ([x] (new clojure.lang.Atom x))
  ([x &amp; options] (setup-reference (atom x) options)))</pre></td></tr><tr><td class="docs"><p>Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.  Returns
  the value that was swapped in.</p>
</td><td class="codes"><pre class="brush: clojure">(defn swap!
  {:added &quot;1.0&quot;
   :static true}
  ([^clojure.lang.Atom atom f] (.swap atom f))
  ([^clojure.lang.Atom atom f x] (.swap atom f x))
  ([^clojure.lang.Atom atom f x y] (.swap atom f x y))
  ([^clojure.lang.Atom atom f x y &amp; args] (.swap atom f x y args)))</pre></td></tr><tr><td class="docs"><p>Atomically sets the value of atom to newval if and only if the
  current value of the atom is identical to oldval. Returns true if
  set happened, else false</p>
</td><td class="codes"><pre class="brush: clojure">(defn compare-and-set!
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Atom atom oldval newval] (.compareAndSet atom oldval newval))</pre></td></tr><tr><td class="docs"><p>Sets the value of atom to newval without regard for the
  current value. Returns newval.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reset!
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Atom atom newval] (.reset atom newval))</pre></td></tr><tr><td class="docs"><p>Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a
  side-effect-free fn of one argument, which will be passed the intended
  new state on any state change. If the new state is unacceptable, the
  validator-fn should return false or throw an exception. If the current state (root
  value if var) is not acceptable to the new validator, an exception
  will be thrown and the validator will not be changed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-validator!
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.IRef iref validator-fn] (. iref (setValidator validator-fn)))</pre></td></tr><tr><td class="docs"><p>Gets the validator-fn for a var/ref/agent/atom.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-validator
  {:added &quot;1.0&quot;
   :static true}
 [^clojure.lang.IRef iref] (. iref (getValidator)))</pre></td></tr><tr><td class="docs"><p>Atomically sets the metadata for a namespace/var/ref/agent/atom to be:</p>

<p>  (apply f its-current-meta args)</p>

<p>  f must be free of side-effects</p>
</td><td class="codes"><pre class="brush: clojure">(defn alter-meta!
  {:added &quot;1.0&quot;
   :static true}
 [^clojure.lang.IReference iref f &amp; args] (.alterMeta iref f args))</pre></td></tr><tr><td class="docs"><p>Atomically resets the metadata for a namespace/var/ref/agent/atom</p>
</td><td class="codes"><pre class="brush: clojure">(defn reset-meta!
  {:added &quot;1.0&quot;
   :static true}
 [^clojure.lang.IReference iref metadata-map] (.resetMeta iref metadata-map))</pre></td></tr><tr><td class="docs"><p>Must be called in a transaction. Sets the in-transaction-value of
  ref to:</p>

<p>  (apply fun in-transaction-value-of-ref args)</p>

<p>  and returns the in-transaction-value of ref.</p>

<p>  At the commit point of the transaction, sets the value of ref to be:</p>

<p>  (apply fun most-recently-committed-value-of-ref args)</p>

<p>  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn commute
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Ref ref fun &amp; args]
    (. ref (commute fun args)))</pre></td></tr><tr><td class="docs"><p>Must be called in a transaction. Sets the in-transaction-value of
  ref to:</p>

<p>  (apply fun in-transaction-value-of-ref args)</p>

<p>  and returns the in-transaction-value of ref.</p>
</td><td class="codes"><pre class="brush: clojure">(defn alter
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Ref ref fun &amp; args]
    (. ref (alter fun args)))</pre></td></tr><tr><td class="docs"><p>Must be called in a transaction. Sets the value of ref.
  Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ref-set
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Ref ref val]
    (. ref (set val)))</pre></td></tr><tr><td class="docs"><p>Returns the history count of a ref</p>
</td><td class="codes"><pre class="brush: clojure">(defn ref-history-count
  {:added &quot;1.1&quot;
   :static true}
  [^clojure.lang.Ref ref]
    (.getHistoryCount ref))</pre></td></tr><tr><td class="docs"><p>Gets the min-history of a ref, or sets it and returns the ref</p>
</td><td class="codes"><pre class="brush: clojure">(defn ref-min-history
  {:added &quot;1.1&quot;
   :static true}
  ([^clojure.lang.Ref ref]
    (.getMinHistory ref))
  ([^clojure.lang.Ref ref n]
    (.setMinHistory ref n)))</pre></td></tr><tr><td class="docs"><p>Gets the max-history of a ref, or sets it and returns the ref</p>
</td><td class="codes"><pre class="brush: clojure">(defn ref-max-history
  {:added &quot;1.1&quot;
   :static true}
  ([^clojure.lang.Ref ref]
    (.getMaxHistory ref))
  ([^clojure.lang.Ref ref n]
    (.setMaxHistory ref n)))</pre></td></tr><tr><td class="docs"><p>Must be called in a transaction. Protects the ref from modification
  by other transactions.  Returns the in-transaction-value of
  ref. Allows for more concurrency than (ref-set ref @ref)</p>
</td><td class="codes"><pre class="brush: clojure">(defn ensure
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Ref ref]
    (. ref (touch))
    (. ref (deref)))</pre></td></tr><tr><td class="docs"><p>transaction-flags => TBD, pass nil for now</p>

<p>  Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of sync. The exprs may be run more than
  once, but any effects on Refs will be atomic.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro sync
  {:added &quot;1.0&quot;}
  [flags-ignored-for-now &amp; body]
  `(. clojure.lang.LockingTransaction
      (runInTransaction (fn [] ~@body))))</pre></td></tr><tr><td class="docs"><p>If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro io!
  {:added &quot;1.0&quot;}
  [&amp; body]
  (let [message (when (string? (first body)) (first body))
        body (if message (next body) body)]
    `(if (clojure.lang.LockingTransaction/isRunning)
       (throw (new IllegalStateException ~(or message &quot;I/O in transaction&quot;)))
       (do ~@body))))</pre></td></tr><tr><td class="docs"><p>fn stuff ;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defn comp
  {:added &quot;1.0&quot;
   :static true}
  ([] identity)
  ([f] f)
  ([f g] 
     (fn 
       ([] (f (g)))
       ([x] (f (g x)))
       ([x y] (f (g x y)))
       ([x y z] (f (g x y z)))
       ([x y z &amp; args] (f (apply g x y z args)))))
  ([f g h] 
     (fn 
       ([] (f (g (h))))
       ([x] (f (g (h x))))
       ([x y] (f (g (h x y))))
       ([x y z] (f (g (h x y z))))
       ([x y z &amp; args] (f (g (apply h x y z args))))))
  ([f1 f2 f3 &amp; fs]
    (let [fs (reverse (list* f1 f2 f3 fs))]
      (fn [&amp; args]
        (loop [ret (apply (first fs) args) fs (next fs)]
          (if fs
            (recur ((first fs) ret) (next fs))
            ret))))))</pre></td></tr><tr><td class="docs"><p>Takes a set of functions and returns a fn that is the juxtaposition
  of those fns.  The returned fn takes a variable number of args, and
  returns a vector containing the result of applying each fn to the
  args (left-to-right).
  ((juxt a b c) x) => [(a x) (b x) (c x)]</p>
</td><td class="codes"><pre class="brush: clojure">(defn juxt 
  {:added &quot;1.1&quot;
   :static true}
  ([f] 
     (fn
       ([] [(f)])
       ([x] [(f x)])
       ([x y] [(f x y)])
       ([x y z] [(f x y z)])
       ([x y z &amp; args] [(apply f x y z args)])))
  ([f g] 
     (fn
       ([] [(f) (g)])
       ([x] [(f x) (g x)])
       ([x y] [(f x y) (g x y)])
       ([x y z] [(f x y z) (g x y z)])
       ([x y z &amp; args] [(apply f x y z args) (apply g x y z args)])))
  ([f g h] 
     (fn
       ([] [(f) (g) (h)])
       ([x] [(f x) (g x) (h x)])
       ([x y] [(f x y) (g x y) (h x y)])
       ([x y z] [(f x y z) (g x y z) (h x y z)])
       ([x y z &amp; args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)])))
  ([f g h &amp; fs]
     (let [fs (list* f g h fs)]
       (fn
         ([] (reduce1 #(conj %1 (%2)) [] fs))
         ([x] (reduce1 #(conj %1 (%2 x)) [] fs))
         ([x y] (reduce1 #(conj %1 (%2 x y)) [] fs))
         ([x y z] (reduce1 #(conj %1 (%2 x y z)) [] fs))
         ([x y z &amp; args] (reduce1 #(conj %1 (apply %2 x y z args)) [] fs))))))</pre></td></tr><tr><td class="docs"><p>Takes a function f and fewer than the normal arguments to f, and
  returns a fn that takes a variable number of additional args. When
  called, the returned function calls f with args + additional args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partial
  {:added &quot;1.0&quot;
   :static true}
  ([f arg1]
   (fn [&amp; args] (apply f arg1 args)))
  ([f arg1 arg2]
   (fn [&amp; args] (apply f arg1 arg2 args)))
  ([f arg1 arg2 arg3]
   (fn [&amp; args] (apply f arg1 arg2 arg3 args)))
  ([f arg1 arg2 arg3 &amp; more]
   (fn [&amp; args] (apply f arg1 arg2 arg3 (concat more args)))))</pre></td></tr><tr><td class="docs"><p>Coerces coll to a (possibly empty) sequence, if it is not already
  one. Will not force a lazy seq. (sequence nil) yields ()</p>

<p>sequence fns  ;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn sequence
  {:added &quot;1.0&quot;
   :static true}
  [coll]
   (if (seq? coll) coll
    (or (seq coll) ())))</pre></td></tr><tr><td class="docs"><p>Returns true if (pred x) is logical true for every x in coll, else
  false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn every?
  {:tag Boolean
   :added &quot;1.0&quot;
   :static true}
  [pred coll]
  (cond
   (nil? (seq coll)) true
   (pred (first coll)) (recur pred (next coll))
   :else false))</pre></td></tr><tr><td class="docs"><p>Returns false if (pred x) is logical true for every x in
  coll, else true.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:tag Boolean
   :doc 
   :arglists '([pred coll])
   :added &quot;1.0&quot;}
 not-every? (comp not every?))</pre></td></tr><tr><td class="docs"><p>Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)</p>
</td><td class="codes"><pre class="brush: clojure">(defn some
  {:added &quot;1.0&quot;
   :static true}
  [pred coll]
    (when (seq coll)
      (or (pred (first coll)) (recur pred (next coll)))))</pre></td></tr><tr><td class="docs"><p>Returns false if (pred x) is logical true for any x in coll,
  else true.</p>
</td><td class="codes"><pre class="brush: clojure">(def
 ^{:tag Boolean
   :doc 
   :arglists '([pred coll])
   :added &quot;1.0&quot;}
 not-any? (comp not some))</pre></td></tr><tr><td class="docs"><p>bindings => name n</p>

<p>  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.</p>

<p>will be redefed later with arg checks</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro dotimes
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (let [i (first bindings)
        n (second bindings)]
    `(let [n# (clojure.lang.RT/longCast ~n)]
       (loop [~i 0]
         (when (&lt; ~i n#)
           ~@body
           (recur (unchecked-inc ~i)))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map
  {:added &quot;1.0&quot;
   :static true}
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (if (chunked-seq? s)
        (let [c (chunk-first s)
              size (int (count c))
              b (chunk-buffer size)]
          (dotimes [i size]
              (chunk-append b (f (.nth c i))))
          (chunk-cons (chunk b) (map f (chunk-rest s))))
        (cons (f (first s)) (map f (rest s)))))))
  ([f c1 c2]
   (lazy-seq
    (let [s1 (seq c1) s2 (seq c2)]
      (when (and s1 s2)
        (cons (f (first s1) (first s2))
              (map f (rest s1) (rest s2)))))))
  ([f c1 c2 c3]
   (lazy-seq
    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]
      (when (and  s1 s2 s3)
        (cons (f (first s1) (first s2) (first s3))
              (map f (rest s1) (rest s2) (rest s3)))))))
  ([f c1 c2 c3 &amp; colls]
   (let [step (fn step [cs]
                 (lazy-seq
                  (let [ss (map seq cs)]
                    (when (every? identity ss)
                      (cons (map first ss) (step (map rest ss)))))))]
     (map #(apply f %) (step (conj colls c3 c2 c1))))))</pre></td></tr><tr><td class="docs"><p>Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mapcat
  {:added &quot;1.0&quot;
   :static true}
  [f &amp; colls]
    (apply concat (apply map f colls)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn filter
  {:added &quot;1.0&quot;
   :static true}
  ([pred coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (if (chunked-seq? s)
        (let [c (chunk-first s)
              size (count c)
              b (chunk-buffer size)]
          (dotimes [i size]
              (when (pred (.nth c i))
                (chunk-append b (.nth c i))))
          (chunk-cons (chunk b) (filter pred (chunk-rest s))))
        (let [f (first s) r (rest s)]
          (if (pred f)
            (cons f (filter pred r))
            (filter pred r))))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove
  {:added &quot;1.0&quot;
   :static true}
  [pred coll]
  (filter (complement pred) coll))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.</p>
</td><td class="codes"><pre class="brush: clojure">(defn take
  {:added &quot;1.0&quot;
   :static true}
  [n coll]
  (lazy-seq
   (when (pos? n) 
     (when-let [s (seq coll)]
      (cons (first s) (take (dec n) (rest s)))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn take-while
  {:added &quot;1.0&quot;
   :static true}
  [pred coll]
  (lazy-seq
   (when-let [s (seq coll)]
       (when (pred (first s))
         (cons (first s) (take-while pred (rest s)))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of all but the first n items in coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn drop
  {:added &quot;1.0&quot;
   :static true}
  [n coll]
  (let [step (fn [n coll]
               (let [s (seq coll)]
                 (if (and (pos? n) s)
                   (recur (dec n) (rest s))
                   s)))]
    (lazy-seq (step n coll))))</pre></td></tr><tr><td class="docs"><p>Return a lazy sequence of all but the last n (default 1) items in coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn drop-last
  {:added &quot;1.0&quot;
   :static true}
  ([s] (drop-last 1 s))
  ([n s] (map (fn [x _] x) s (drop n s))))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the last n items in coll.  Depending on the type
  of coll may be no better than linear time.  For vectors, see also subvec.</p>
</td><td class="codes"><pre class="brush: clojure">(defn take-last
  {:added &quot;1.1&quot;
   :static true}
  [n coll]
  (loop [s (seq coll), lead (seq (drop n coll))]
    (if lead
      (recur (next s) (next lead))
      s)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the items in coll starting from the first
  item for which (pred item) returns logical false.</p>
</td><td class="codes"><pre class="brush: clojure">(defn drop-while
  {:added &quot;1.0&quot;
   :static true}
  [pred coll]
  (let [step (fn [pred coll]
               (let [s (seq coll)]
                 (if (and s (pred (first s)))
                   (recur pred (rest s))
                   s)))]
    (lazy-seq (step pred coll))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy (infinite!) sequence of repetitions of the items in coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cycle
  {:added &quot;1.0&quot;
   :static true}
  [coll] (lazy-seq 
          (when-let [s (seq coll)] 
              (concat s (cycle s)))))</pre></td></tr><tr><td class="docs"><p>Returns a vector of [(take n coll) (drop n coll)]</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-at
  {:added &quot;1.0&quot;
   :static true}
  [n coll]
    [(take n coll) (drop n coll)])</pre></td></tr><tr><td class="docs"><p>Returns a vector of [(take-while pred coll) (drop-while pred coll)]</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-with
  {:added &quot;1.0&quot;
   :static true}
  [pred coll]
    [(take-while pred coll) (drop-while pred coll)])</pre></td></tr><tr><td class="docs"><p>Returns a lazy (infinite!, or length n if supplied) sequence of xs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn repeat
  {:added &quot;1.0&quot;
   :static true}
  ([x] (lazy-seq (cons x (repeat x))))
  ([n x] (take n (repeat x))))</pre></td></tr><tr><td class="docs"><p>DEPRECATED: Use 'repeat' instead.
   Returns a lazy seq of n xs.</p>
</td><td class="codes"><pre class="brush: clojure">(defn replicate
  {:added &quot;1.0&quot;
   :deprecated &quot;1.3&quot;}
  [n x] (take n (repeat x)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects</p>
</td><td class="codes"><pre class="brush: clojure">(defn iterate
  {:added &quot;1.0&quot;
   :static true}
  [f x] (cons x (lazy-seq (iterate f (f x)))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end
  to infinity.</p>
</td><td class="codes"><pre class="brush: clojure">(defn range 
  {:added &quot;1.0&quot;
   :static true}
  ([] (range 0 Double/POSITIVE_INFINITY 1))
  ([end] (range 0 end 1))
  ([start end] (range start end 1))
  ([start end step]
   (lazy-seq
    (let [b (chunk-buffer 32)
          comp (if (pos? step) &lt; &gt;)]
      (loop [i start]
        (if (and (&lt; (count b) 32)
                 (comp i end))
          (do
            (chunk-append b i)
            (recur (+ i step)))
          (chunk-cons (chunk b) 
                      (when (comp i end) 
                        (range i end step)))))))))</pre></td></tr><tr><td class="docs"><p>Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge
  {:added &quot;1.0&quot;
   :static true}
  [&amp; maps]
  (when (some identity maps)
    (reduce1 #(conj (or %1 {}) %2) maps)))</pre></td></tr><tr><td class="docs"><p>Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (f val-in-result val-in-latter).</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-with
  {:added &quot;1.0&quot;
   :static true}
  [f &amp; maps]
  (when (some identity maps)
    (let [merge-entry (fn [m e]
			(let [k (key e) v (val e)]
			  (if (contains? m k)
			    (assoc m k (f (get m k) v))
			    (assoc m k v))))
          merge2 (fn [m1 m2]
		   (reduce1 merge-entry (or m1 {}) (seq m2)))]
      (reduce1 merge2 maps))))</pre></td></tr><tr><td class="docs"><p>Returns a map with the keys mapped to the corresponding vals.</p>
</td><td class="codes"><pre class="brush: clojure">(defn zipmap
  {:added &quot;1.0&quot;
   :static true}
  [keys vals]
    (loop [map {}
           ks (seq keys)
           vs (seq vals)]
      (if (and ks vs)
        (recur (assoc map (first ks) (first vs))
               (next ks)
               (next vs))
        map)))</pre></td></tr><tr><td class="docs"><p>defs the supplied var names with no bindings, useful for making forward declarations.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro declare
  {:added &quot;1.0&quot;}
  [&amp; names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))</pre></td></tr><tr><td class="docs"><p>Returns the lines of text from rdr as a lazy sequence of strings.
  rdr must implement java.io.BufferedReader.</p>
</td><td class="codes"><pre class="brush: clojure">(defn line-seq
  {:added &quot;1.0&quot;
   :static true}
  [^java.io.BufferedReader rdr]
  (when-let [line (.readLine rdr)]
    (cons line (lazy-seq (line-seq rdr)))))</pre></td></tr><tr><td class="docs"><p>Returns an implementation of java.util.Comparator based upon pred.</p>
</td><td class="codes"><pre class="brush: clojure">(defn comparator
  {:added &quot;1.0&quot;
   :static true}
  [pred]
    (fn [x y]
      (cond (pred x y) -1 (pred y x) 1 :else 0)))</pre></td></tr><tr><td class="docs"><p>Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  If coll is a Java array, it will be modified.
  To avoid this, sort a copy of the array.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sort
  {:added &quot;1.0&quot;
   :static true}
  ([coll]
   (sort compare coll))
  ([^java.util.Comparator comp coll]
   (if (seq coll)
     (let [a (to-array coll)]
       (. java.util.Arrays (sort a comp))
       (seq a))
     ())))</pre></td></tr><tr><td class="docs"><p>Returns a sorted sequence of the items in coll, where the sort
  order is determined by comparing (keyfn item).  If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  If coll is a Java array, it will be modified.
  To avoid this, sort a copy of the array.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sort-by
  {:added &quot;1.0&quot;
   :static true}
  ([keyfn coll]
   (sort-by keyfn compare coll))
  ([keyfn ^java.util.Comparator comp coll]
   (sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)))</pre></td></tr><tr><td class="docs"><p>When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dorun
  {:added &quot;1.0&quot;
   :static true}
  ([coll]
   (when (seq coll)
     (recur (next coll))))
  ([n coll]
   (when (and (seq coll) (pos? n))
     (recur (dec n) (next coll)))))</pre></td></tr><tr><td class="docs"><p>When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.</p>
</td><td class="codes"><pre class="brush: clojure">(defn doall
  {:added &quot;1.0&quot;
   :static true}
  ([coll]
   (dorun coll)
   coll)
  ([n coll]
   (dorun n coll)
   coll))</pre></td></tr><tr><td class="docs"><p>Returns the nth next of coll, (seq coll) when n is 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nthnext
  {:added &quot;1.0&quot;
   :static true}
  [coll n]
    (loop [n n xs (seq coll)]
      (if (and xs (pos? n))
        (recur (dec n) (next xs))
        xs)))</pre></td></tr><tr><td class="docs"><p>Returns the nth rest of coll, coll when n is 0.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nthrest
  {:added &quot;1.3&quot;
   :static true}
  [coll n]
    (loop [n n xs coll]
      (if (and (pos? n) (seq xs))
        (recur (dec n) (rest xs))
        xs)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partition
  {:added &quot;1.0&quot;
   :static true}
  ([n coll]
     (partition n n coll))
  ([n step coll]
     (lazy-seq
       (when-let [s (seq coll)]
         (let [p (doall (take n s))]
           (when (= n (count p))
             (cons p (partition n step (nthrest s step))))))))
  ([n step pad coll]
     (lazy-seq
       (when-let [s (seq coll)]
         (let [p (doall (take n s))]
           (if (= n (count p))
             (cons p (partition n step pad (nthrest s step)))
             (list (take n (concat p pad)))))))))</pre></td></tr><tr><td class="docs"><p>evaluation</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Evaluates the form data structure (not text!) and returns the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defn eval
  {:added &quot;1.0&quot;
   :static true}
  [form] (. clojure.lang.Compiler (eval form)))</pre></td></tr><tr><td class="docs"><p>Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by "for".  Does not retain
  the head of the sequence. Returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro doseq
  {:added &quot;1.0&quot;}
  [seq-exprs &amp; body]
  (assert-args
     (vector? seq-exprs) &quot;a vector for its binding&quot;
     (even? (count seq-exprs)) &quot;an even number of forms in binding vector&quot;)
  (let [step (fn step [recform exprs]
               (if-not exprs
                 [true `(do ~@body)]
                 (let [k (first exprs)
                       v (second exprs)]
                   (if (keyword? k)
                     (let [steppair (step recform (nnext exprs))
                           needrec (steppair 0)
                           subform (steppair 1)]
                       (cond
                         (= k :let) [needrec `(let ~v ~subform)]
                         (= k :while) [false `(when ~v
                                                ~subform
                                                ~@(when needrec [recform]))]
                         (= k :when) [false `(if ~v
                                               (do
                                                 ~subform
                                                 ~@(when needrec [recform]))
                                               ~recform)]))
                     (let [seq- (gensym &quot;seq_&quot;)
                           chunk- (with-meta (gensym &quot;chunk_&quot;)
                                             {:tag 'clojure.lang.IChunk})
                           count- (gensym &quot;count_&quot;)
                           i- (gensym &quot;i_&quot;)
                           recform `(recur (next ~seq-) nil 0 0)
                           steppair (step recform (nnext exprs))
                           needrec (steppair 0)
                           subform (steppair 1)
                           recform-chunk 
                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))
                           steppair-chunk (step recform-chunk (nnext exprs))
                           subform-chunk (steppair-chunk 1)]
                       [true
                        `(loop [~seq- (seq ~v), ~chunk- nil,
                                ~count- 0, ~i- 0]
                           (if (&lt; ~i- ~count-)
                             (let [~k (.nth ~chunk- ~i-)]
                               ~subform-chunk
                               ~@(when needrec [recform-chunk]))
                             (when-let [~seq- (seq ~seq-)]
                               (if (chunked-seq? ~seq-)
                                 (let [c# (chunk-first ~seq-)]
                                   (recur (chunk-rest ~seq-) c#
                                          (int (count c#)) (int 0)))
                                 (let [~k (first ~seq-)]
                                   ~subform
                                   ~@(when needrec [recform]))))))])))))]
    (nth (step nil (seq seq-exprs)) 1)))</pre></td></tr><tr><td class="docs"><p>Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true.</p>
</td><td class="codes"><pre class="brush: clojure">(defn await
  {:added &quot;1.0&quot;
   :static true}
  [&amp; agents]
  (io! &quot;await in transaction&quot;
    (when *agent*
      (throw (new Exception &quot;Can't await in agent action&quot;)))
    (let [latch (new java.util.concurrent.CountDownLatch (count agents))
          count-down (fn [agent] (. latch (countDown)) agent)]
      (doseq [agent agents]
        (send agent count-down))
      (. latch (await)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:static await1 [^clojure.lang.Agent a]
  (when (pos? (.getQueueCount a))
    (await a))
    a)</pre></td></tr><tr><td class="docs"><p>Blocks the current thread until all actions dispatched thus
  far (from this thread or agent) to the agents have occurred, or the
  timeout (in milliseconds) has elapsed. Returns logical false if
  returning due to timeout, logical true otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn await-for
  {:added &quot;1.0&quot;
   :static true}
  [timeout-ms &amp; agents]
    (io! &quot;await-for in transaction&quot;
     (when *agent*
       (throw (new Exception &quot;Can't await in agent action&quot;)))
     (let [latch (new java.util.concurrent.CountDownLatch (count agents))
           count-down (fn [agent] (. latch (countDown)) agent)]
       (doseq [agent agents]
           (send agent count-down))
       (. latch (await  timeout-ms (. java.util.concurrent.TimeUnit MILLISECONDS))))))</pre></td></tr><tr><td class="docs"><p>bindings => name n</p>

<p>  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro dotimes
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (= 2 (count bindings)) &quot;exactly 2 forms in binding vector&quot;)
  (let [i (first bindings)
        n (second bindings)]
    `(let [n# (long ~n)]
       (loop [~i 0]
         (when (&lt; ~i n#)
           ~@body
           (recur (unchecked-inc ~i)))))))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Returns a new, transient version of the collection, in constant time.</p>
</td><td class="codes"><pre class="brush: clojure">#_(defn into
  &quot;Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined.&quot;
  {:added &quot;1.0&quot;}
  [to from]
    (let [ret to items (seq from)]
      (if items
        (recur (conj ret (first items)) (next items))
        ret)))
;;;;;;;;;;;;;;;;;;;;; editable collections ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn transient 
  {:added &quot;1.1&quot;
   :static true}
  [^clojure.lang.IEditableCollection coll] 
  (.asTransient coll))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn persistent! 
  {:added &quot;1.1&quot;
   :static true}
  [^clojure.lang.ITransientCollection coll]
  (.persistent coll))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Adds x to the transient collection, and return coll. The 'addition'
  may happen at different 'places' depending on the concrete type.</p>
</td><td class="codes"><pre class="brush: clojure">(defn conj!
  {:added &quot;1.1&quot;
   :static true}
  [^clojure.lang.ITransientCollection coll x]
  (.conj coll x))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc!
  {:added &quot;1.1&quot;
   :static true}
  ([^clojure.lang.ITransientAssociative coll key val] (.assoc coll key val))
  ([^clojure.lang.ITransientAssociative coll key val &amp; kvs]
   (let [ret (.assoc coll key val)]
     (if kvs
       (recur ret (first kvs) (second kvs) (nnext kvs))
       ret))))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Returns a transient map that doesn't contain a mapping for key(s).</p>
</td><td class="codes"><pre class="brush: clojure">(defn dissoc!
  {:added &quot;1.1&quot;
   :static true}
  ([^clojure.lang.ITransientMap map key] (.without map key))
  ([^clojure.lang.ITransientMap map key &amp; ks]
   (let [ret (.without map key)]
     (if ks
       (recur ret (first ks) (next ks))
       ret))))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Removes the last item from a transient vector. If
  the collection is empty, throws an exception. Returns coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn pop!
  {:added &quot;1.1&quot;
   :static true}
  [^clojure.lang.ITransientVector coll] 
  (.pop coll)) </pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that
  does not contain key(s).</p>
</td><td class="codes"><pre class="brush: clojure">(defn disj!
  {:added &quot;1.1&quot;
   :static true}
  ([set] set)
  ([^clojure.lang.ITransientSet set key]
   (. set (disjoin key)))
  ([^clojure.lang.ITransientSet set key &amp; ks]
   (let [ret (. set (disjoin key))]
     (if ks
       (recur ret (first ks) (next ks))
       ret))))</pre></td></tr><tr><td class="docs"><p>Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined.</p>

<p>redef into with batch support</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:private into1
  {:added &quot;1.0&quot;
   :static true}
  [to from]
  (if (instance? clojure.lang.IEditableCollection to)
    (persistent! (reduce1 conj! (transient to) from))
    (reduce1 conj to from)))</pre></td></tr><tr><td class="docs"><p>import-list => (package-symbol class-name-symbols*)</p>

<p>  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro import 
  {:added &quot;1.0&quot;}
  [&amp; import-symbols-or-lists]
  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %) 
                   import-symbols-or-lists)]
    `(do ~@(map #(list 'clojure.core/import* %)
                (reduce1 (fn [v spec] 
                          (if (symbol? spec)
                            (conj v (name spec))
                            (let [p (first spec) cs (rest spec)]
                              (into1 v (map #(str p &quot;.&quot; %) cs)))))
                        [] specs)))))</pre></td></tr><tr><td class="docs"><p>Returns an array with components set to the values in aseq. The array's
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE.</p>
</td><td class="codes"><pre class="brush: clojure">(defn into-array
  {:added &quot;1.0&quot;
   :static true}
  ([aseq]
     (clojure.lang.RT/seqToTypedArray (seq aseq)))
  ([type aseq]
     (clojure.lang.RT/seqToTypedArray type (seq aseq))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:private true}
  array [&amp; items]
    (into-array items))</pre></td></tr><tr><td class="docs"><p>Returns the Class of x</p>
</td><td class="codes"><pre class="brush: clojure">(defn class
  {:added &quot;1.0&quot;
   :static true}
  ^Class [^Object x] (if (nil? x) x (. x (getClass))))</pre></td></tr><tr><td class="docs"><p>Returns the :type metadata of x, or its Class if none</p>
</td><td class="codes"><pre class="brush: clojure">(defn type 
  {:added &quot;1.0&quot;
   :static true}
  [x]
  (or (get (meta x) :type) (class x)))</pre></td></tr><tr><td class="docs"><p>Coerce to Number</p>
</td><td class="codes"><pre class="brush: clojure">(defn num
  {:tag Number
   :inline (fn  [x] `(. clojure.lang.Numbers (num ~x)))
   :added &quot;1.0&quot;}
  [x] (. clojure.lang.Numbers (num x)))</pre></td></tr><tr><td class="docs"><p>Coerce to long</p>
</td><td class="codes"><pre class="brush: clojure">(defn long
  {:inline (fn  [x] `(. clojure.lang.RT (longCast ~x)))
   :added &quot;1.0&quot;}
  [^Number x] (clojure.lang.RT/longCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to float</p>
</td><td class="codes"><pre class="brush: clojure">(defn float
  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedFloatCast 'floatCast) ~x)))
   :added &quot;1.0&quot;}
  [^Number x] (clojure.lang.RT/floatCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to double</p>
</td><td class="codes"><pre class="brush: clojure">(defn double
  {:inline (fn  [x] `(. clojure.lang.RT (doubleCast ~x)))
   :added &quot;1.0&quot;}
  [^Number x] (clojure.lang.RT/doubleCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to short</p>
</td><td class="codes"><pre class="brush: clojure">(defn short
  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedShortCast 'shortCast) ~x)))
   :added &quot;1.0&quot;}
  [^Number x] (clojure.lang.RT/shortCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to byte</p>
</td><td class="codes"><pre class="brush: clojure">(defn byte
  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedByteCast 'byteCast) ~x)))
   :added &quot;1.0&quot;}
  [^Number x] (clojure.lang.RT/byteCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to char</p>
</td><td class="codes"><pre class="brush: clojure">(defn char
  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedCharCast 'charCast) ~x)))
   :added &quot;1.1&quot;}
  [x] (. clojure.lang.RT (charCast x)))</pre></td></tr><tr><td class="docs"><p>Coerce to boolean</p>
</td><td class="codes"><pre class="brush: clojure">(defn boolean
  {
   :inline (fn  [x] `(. clojure.lang.RT (booleanCast ~x)))
   :added &quot;1.0&quot;}
  [x] (clojure.lang.RT/booleanCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to byte. Subject to rounding or truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-byte
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedByteCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedByteCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to short. Subject to rounding or truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-short
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedShortCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedShortCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to char. Subject to rounding or truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-char
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedCharCast ~x)))
   :added &quot;1.3&quot;}
  [x] (. clojure.lang.RT (uncheckedCharCast x)))</pre></td></tr><tr><td class="docs"><p>Coerce to int. Subject to rounding or truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-int
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedIntCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedIntCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to long. Subject to rounding or truncation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-long
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedLongCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedLongCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to float. Subject to rounding.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-float
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedFloatCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedFloatCast x))</pre></td></tr><tr><td class="docs"><p>Coerce to double. Subject to rounding.</p>
</td><td class="codes"><pre class="brush: clojure">(defn unchecked-double
  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedDoubleCast ~x)))
   :added &quot;1.3&quot;}
  [^Number x] (clojure.lang.RT/uncheckedDoubleCast x))</pre></td></tr><tr><td class="docs"><p>Returns true if x is a Number</p>
</td><td class="codes"><pre class="brush: clojure">(defn number?
  {:added &quot;1.0&quot;
   :static true}
  [x]
  (instance? Number x))</pre></td></tr><tr><td class="docs"><p>Modulus of num and div. Truncates toward negative infinity.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mod
  {:added &quot;1.0&quot;
   :static true}
  [num div] 
  (let [m (rem num div)] 
    (if (or (zero? m) (= (pos? num) (pos? div)))
      m 
      (+ m div))))</pre></td></tr><tr><td class="docs"><p>Returns true if n is a Ratio</p>
</td><td class="codes"><pre class="brush: clojure">(defn ratio?
  {:added &quot;1.0&quot;
   :static true}
  [n] (instance? clojure.lang.Ratio n))</pre></td></tr><tr><td class="docs"><p>Returns the numerator part of a Ratio.</p>
</td><td class="codes"><pre class="brush: clojure">(defn numerator
  {:tag BigInteger
   :added &quot;1.2&quot;
   :static true}
  [r]
  (.numerator ^clojure.lang.Ratio r))</pre></td></tr><tr><td class="docs"><p>Returns the denominator part of a Ratio.</p>
</td><td class="codes"><pre class="brush: clojure">(defn denominator
  {:tag BigInteger
   :added &quot;1.2&quot;
   :static true}
  [r]
  (.denominator ^clojure.lang.Ratio r))</pre></td></tr><tr><td class="docs"><p>Returns true if n is a BigDecimal</p>
</td><td class="codes"><pre class="brush: clojure">(defn decimal?
  {:added &quot;1.0&quot;
   :static true}
  [n] (instance? BigDecimal n))</pre></td></tr><tr><td class="docs"><p>Returns true if n is a floating point number</p>
</td><td class="codes"><pre class="brush: clojure">(defn float?
  {:added &quot;1.0&quot;
   :static true}
  [n]
  (or (instance? Double n)
      (instance? Float n)))</pre></td></tr><tr><td class="docs"><p>Returns true if n is a rational number</p>
</td><td class="codes"><pre class="brush: clojure">(defn rational? 
  {:added &quot;1.0&quot;
   :static true}
  [n]
  (or (integer? n) (ratio? n) (decimal? n)))</pre></td></tr><tr><td class="docs"><p>Coerce to BigInt</p>
</td><td class="codes"><pre class="brush: clojure">(defn bigint
  {:tag clojure.lang.BigInt
   :static true
   :added &quot;1.3&quot;}
  [x] (cond
       (instance? clojure.lang.BigInt x) x
       (instance? BigInteger x) (clojure.lang.BigInt/fromBigInteger x)
       (decimal? x) (bigint (.toBigInteger ^BigDecimal x))
       (ratio? x) (bigint (.bigIntegerValue ^clojure.lang.Ratio x))
       (number? x) (clojure.lang.BigInt/valueOf (long x))
       :else (bigint (BigInteger. x))))</pre></td></tr><tr><td class="docs"><p>Coerce to BigInteger</p>
</td><td class="codes"><pre class="brush: clojure">(defn biginteger
  {:tag BigInteger
   :added &quot;1.0&quot;
   :static true}
  [x] (cond
       (instance? BigInteger x) x
       (instance? clojure.lang.BigInt x) (.toBigInteger ^clojure.lang.BigInt x)
       (decimal? x) (.toBigInteger ^BigDecimal x)
       (ratio? x) (.bigIntegerValue ^clojure.lang.Ratio x)
       (number? x) (BigInteger/valueOf (long x))
       :else (BigInteger. x)))</pre></td></tr><tr><td class="docs"><p>Coerce to BigDecimal</p>
</td><td class="codes"><pre class="brush: clojure">(defn bigdec
  {:tag BigDecimal
   :added &quot;1.0&quot;
   :static true}
  [x] (cond
       (decimal? x) x
       (float? x) (. BigDecimal valueOf (double x))
       (ratio? x) (/ (BigDecimal. (.numerator ^clojure.lang.Ratio x)) (.denominator ^clojure.lang.Ratio x))
       (instance? clojure.lang.BigInt x) (.toBigDecimal ^clojure.lang.BigInt x)
       (instance? BigInteger x) (BigDecimal. ^BigInteger x)
       (number? x) (BigDecimal/valueOf (long x))
       :else (BigDecimal. x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:private true} print-initialized false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti print-method (fn [x writer]
                         (let [t (get (meta x) :type)]
                           (if (keyword? t) t (class x)))))
(defmulti print-dup (fn [x writer] (class x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pr-on
  {:private true
   :static true}
  [x w]
  (if *print-dup*
    (print-dup x w)
    (print-method x w))
  nil)</pre></td></tr><tr><td class="docs"><p>Prints the object(s) to the output stream that is the current value
  of <em>out</em>.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader</p>
</td><td class="codes"><pre class="brush: clojure">(defn pr
  {:dynamic true
   :added &quot;1.0&quot;}
  ([] nil)
  ([x]
     (pr-on x *out*))
  ([x &amp; more]
   (pr x)
   (. *out* (append \space))
   (if-let [nmore (next more)]
     (recur (first more) nmore)
     (apply pr more))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^String system-newline
     (System/getProperty &quot;line.separator&quot;))</pre></td></tr><tr><td class="docs"><p>Writes a platform-specific newline to <em>out</em></p>
</td><td class="codes"><pre class="brush: clojure">(defn newline
  {:added &quot;1.0&quot;
   :static true}
  []
    (. *out* (append system-newline))
    nil)</pre></td></tr><tr><td class="docs"><p>Flushes the output stream that is the current value of
  <em>out</em></p>
</td><td class="codes"><pre class="brush: clojure">(defn flush
  {:added &quot;1.0&quot;
   :static true}
  []
    (. *out* (flush))
    nil)</pre></td></tr><tr><td class="docs"><p>Same as pr followed by (newline). Observes <em>flush-on-newline</em></p>
</td><td class="codes"><pre class="brush: clojure">(defn prn
  {:added &quot;1.0&quot;
   :static true}
  [&amp; more]
    (apply pr more)
    (newline)
    (when *flush-on-newline*
      (flush)))</pre></td></tr><tr><td class="docs"><p>Prints the object(s) to the output stream that is the current value
  of <em>out</em>.  print and println produce output for human consumption.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print
  {:added &quot;1.0&quot;
   :static true}
  [&amp; more]
    (binding [*print-readably* nil]
      (apply pr more)))</pre></td></tr><tr><td class="docs"><p>Same as print followed by (newline)</p>
</td><td class="codes"><pre class="brush: clojure">(defn println
  {:added &quot;1.0&quot;
   :static true}
  [&amp; more]
    (binding [*print-readably* nil]
      (apply prn more)))</pre></td></tr><tr><td class="docs"><p>Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of <em>in</em> .</p>
</td><td class="codes"><pre class="brush: clojure">(defn read
  {:added &quot;1.0&quot;
   :static true}
  ([]
   (read *in*))
  ([stream]
   (read stream true nil))
  ([stream eof-error? eof-value]
   (read stream eof-error? eof-value false))
  ([stream eof-error? eof-value recursive?]
   (. clojure.lang.LispReader (read stream (boolean eof-error?) eof-value recursive?))))</pre></td></tr><tr><td class="docs"><p>Reads the next line from stream that is the current value of <em>in</em> .</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-line
  {:added &quot;1.0&quot;
   :static true}
  []
  (if (instance? clojure.lang.LineNumberingPushbackReader *in*)
    (.readLine ^clojure.lang.LineNumberingPushbackReader *in*)
    (.readLine ^java.io.BufferedReader *in*)))</pre></td></tr><tr><td class="docs"><p>Reads one object from the string s</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-string
  {:added &quot;1.0&quot;
   :static true}
  [s] (clojure.lang.RT/readString s))</pre></td></tr><tr><td class="docs"><p>Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.</p>
</td><td class="codes"><pre class="brush: clojure">(defn subvec
  {:added &quot;1.0&quot;
   :static true}
  ([v start]
   (subvec v start (count v)))
  ([v start end]
   (. clojure.lang.RT (subvec v start end))))</pre></td></tr><tr><td class="docs"><p>bindings => [name init ...]</p>

<p>  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-open
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (even? (count bindings)) &quot;an even number of forms in binding vector&quot;)
  (cond
    (= (count bindings) 0) `(do ~@body)
    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)
                              (try
                                (with-open ~(subvec bindings 2) ~@body)
                                (finally
                                  (. ~(bindings 0) close))))
    :else (throw (IllegalArgumentException.
                   &quot;with-open only allows Symbols in bindings&quot;))))</pre></td></tr><tr><td class="docs"><p>Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments.  The forms
  are evaluated in order.  Returns x.</p>

<p>  (doto (new java.util.HashMap) (.put "a" 1) (.put "b" 2))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro doto
  {:added &quot;1.0&quot;}
  [x &amp; forms]
    (let [gx (gensym)]
      `(let [~gx ~x]
         ~@(map (fn [f]
                  (if (seq? f)
                    `(~(first f) ~gx ~@(next f))
                    `(~f ~gx)))
                forms)
         ~gx)))</pre></td></tr><tr><td class="docs"><p>Expands into code that creates a fn that expects to be passed an
  object and any args and calls the named instance method on the
  object passing the args. Use when you want to treat a Java method as
  a first-class fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro memfn
  {:added &quot;1.0&quot;}
  [name &amp; args]
  `(fn [target# ~@args]
     (. target# (~name ~@args))))</pre></td></tr><tr><td class="docs"><p>Evaluates expr and prints the time it took.  Returns the value of
 expr.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro time
  {:added &quot;1.0&quot;}
  [expr]
  `(let [start# (. System (nanoTime))
         ret# ~expr]
     (prn (str &quot;Elapsed time: &quot; (/ (double (- (. System (nanoTime)) start#)) 1000000.0) &quot; msecs&quot;))
     ret#))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import '(java.lang.reflect Array))</pre></td></tr><tr><td class="docs"><p>Returns the length of the Java array. Works on arrays of all
  types.</p>
</td><td class="codes"><pre class="brush: clojure">(defn alength
  {:inline (fn [a] `(. clojure.lang.RT (alength ~a)))
   :added &quot;1.0&quot;}
  [array] (. clojure.lang.RT (alength array)))</pre></td></tr><tr><td class="docs"><p>Returns a clone of the Java array. Works on arrays of known
  types.</p>
</td><td class="codes"><pre class="brush: clojure">(defn aclone
  {:inline (fn [a] `(. clojure.lang.RT (aclone ~a)))
   :added &quot;1.0&quot;}
  [array] (. clojure.lang.RT (aclone array)))</pre></td></tr><tr><td class="docs"><p>Returns the value at the index/indices. Works on Java arrays of all
  types.</p>
</td><td class="codes"><pre class="brush: clojure">(defn aget
  {:inline (fn [a i] `(. clojure.lang.RT (aget ~a (int ~i))))
   :inline-arities #{2}
   :added &quot;1.0&quot;}
  ([array idx]
   (clojure.lang.Reflector/prepRet (.getComponentType (class array)) (. Array (get array idx))))
  ([array idx &amp; idxs]
   (apply aget (aget array idx) idxs)))</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(defn aset
  {:inline (fn [a i v] `(. clojure.lang.RT (aset ~a (int ~i) ~v)))
   :inline-arities #{3}
   :added &quot;1.0&quot;}
  ([array idx val]
   (. Array (set array idx val))
   val)
  ([array idx idx2 &amp; idxv]
   (apply aset (aget array idx) idx2 idxv)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro
  ^{:private true}
  def-aset [name method coerce]
    `(defn ~name
       {:arglists '([~'array ~'idx ~'val] [~'array ~'idx ~'idx2 &amp; ~'idxv])}
       ([array# idx# val#]
        (. Array (~method array# idx# (~coerce val#)))
        val#)
       ([array# idx# idx2# &amp; idxv#]
        (apply ~name (aget array# idx#) idx2# idxv#))))</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of int. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-int setInt int)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of long. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-long setLong long)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of boolean. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-boolean setBoolean boolean)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of float. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-float setFloat float)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of double. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-double setDouble double)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of short. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-short setShort short)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of byte. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-byte setByte byte)</pre></td></tr><tr><td class="docs"><p>Sets the value at the index/indices. Works on arrays of char. Returns val.</p>
</td><td class="codes"><pre class="brush: clojure">(def-aset
  ^{:doc 
    :added &quot;1.0&quot;}
  aset-char setChar char)</pre></td></tr><tr><td class="docs"><p>Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-array
  {:added &quot;1.0&quot;
   :static true}
  ([^Class type len]
   (. Array (newInstance type (int len))))
  ([^Class type dim &amp; more-dims]
   (let [dims (cons dim more-dims)
         ^&quot;[I&quot; dimarray (make-array (. Integer TYPE)  (count dims))]
     (dotimes [i (alength dimarray)]
       (aset-int dimarray i (nth dims i)))
     (. Array (newInstance type dimarray)))))</pre></td></tr><tr><td class="docs"><p>Returns a (potentially-ragged) 2-dimensional array of Objects
  containing the contents of coll, which can be any Collection of any
  Collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn to-array-2d
  {:tag &quot;[[Ljava.lang.Object;&quot;
   :added &quot;1.0&quot;
   :static true}
  [^java.util.Collection coll]
    (let [ret (make-array (. Class (forName &quot;[Ljava.lang.Object;&quot;)) (. coll (size)))]
      (loop [i 0 xs (seq coll)]
        (when xs
          (aset ret i (to-array (first xs)))
          (recur (inc i) (next xs))))
      ret))</pre></td></tr><tr><td class="docs"><p>If form represents a macro form, returns its expansion,
  else returns form.</p>
</td><td class="codes"><pre class="brush: clojure">(defn macroexpand-1
  {:added &quot;1.0&quot;
   :static true}
  [form]
    (. clojure.lang.Compiler (macroexpand1 form)))</pre></td></tr><tr><td class="docs"><p>Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn macroexpand
  {:added &quot;1.0&quot;
   :static true}
  [form]
    (let [ex (macroexpand-1 form)]
      (if (identical? ex form)
        form
        (macroexpand ex))))</pre></td></tr><tr><td class="docs"><p>Returns a structure basis object.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-struct
  {:added &quot;1.0&quot;
   :static true}
  [&amp; keys]
    (. clojure.lang.PersistentStructMap (createSlotMap keys)))</pre></td></tr><tr><td class="docs"><p>Same as (def name (create-struct keys...))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defstruct
  {:added &quot;1.0&quot;
   :static true}
  [name &amp; keys]
  `(def ~name (create-struct ~@keys)))</pre></td></tr><tr><td class="docs"><p>Returns a new structmap instance with the keys of the
  structure-basis. keyvals may contain all, some or none of the basis
  keys - where values are not supplied they will default to nil.
  keyvals can also contain keys not in the basis.</p>
</td><td class="codes"><pre class="brush: clojure">(defn struct-map
  {:added &quot;1.0&quot;
   :static true}
  [s &amp; inits]
    (. clojure.lang.PersistentStructMap (create s inits)))</pre></td></tr><tr><td class="docs"><p>Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn struct
  {:added &quot;1.0&quot;
   :static true}
  [s &amp; vals]
    (. clojure.lang.PersistentStructMap (construct s vals)))</pre></td></tr><tr><td class="docs"><p>Returns a fn that, given an instance of a structmap with the basis,
  returns the value at the key.  The key must be in the basis. The
  returned function should be (slightly) more efficient than using
  get, but such use of accessors should be limited to known
  performance-critical areas.</p>
</td><td class="codes"><pre class="brush: clojure">(defn accessor
  {:added &quot;1.0&quot;
   :static true}
  [s key]
    (. clojure.lang.PersistentStructMap (getAccessor s key)))</pre></td></tr><tr><td class="docs"><p>Sequentially read and evaluate the set of forms contained in the
  stream/file</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-reader
  {:added &quot;1.0&quot;
   :static true}
  [rdr] (. clojure.lang.Compiler (load rdr)))</pre></td></tr><tr><td class="docs"><p>Sequentially read and evaluate the set of forms contained in the
  string</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-string
  {:added &quot;1.0&quot;
   :static true}
  [s]
  (let [rdr (-&gt; (java.io.StringReader. s)
                (clojure.lang.LineNumberingPushbackReader.))]
    (load-reader rdr)))</pre></td></tr><tr><td class="docs"><p>Returns a set of the distinct elements of coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set
  {:added &quot;1.0&quot;
   :static true}
  [coll] (clojure.lang.PersistentHashSet/create (seq coll)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:private true
   :static true}
  filter-key [keyfn pred amap]
    (loop [ret {} es (seq amap)]
      (if es
        (if (pred (keyfn (first es)))
          (recur (assoc ret (key (first es)) (val (first es))) (next es))
          (recur ret (next es)))
        ret)))</pre></td></tr><tr><td class="docs"><p>Returns the namespace named by the symbol or nil if it doesn't exist.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-ns
  {:added &quot;1.0&quot;
   :static true}
  [sym] (clojure.lang.Namespace/find sym))</pre></td></tr><tr><td class="docs"><p>Create a new namespace named by the symbol if one doesn't already
  exist, returns it or the already-existing namespace of the same
  name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-ns
  {:added &quot;1.0&quot;
   :static true}
  [sym] (clojure.lang.Namespace/findOrCreate sym))</pre></td></tr><tr><td class="docs"><p>Removes the namespace named by the symbol. Use with caution.
  Cannot be used to remove the clojure namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-ns
  {:added &quot;1.0&quot;
   :static true}
  [sym] (clojure.lang.Namespace/remove sym))</pre></td></tr><tr><td class="docs"><p>Returns a sequence of all namespaces.</p>
</td><td class="codes"><pre class="brush: clojure">(defn all-ns
  {:added &quot;1.0&quot;
   :static true}
  [] (clojure.lang.Namespace/all))</pre></td></tr><tr><td class="docs"><p>If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.</p>
</td><td class="codes"><pre class="brush: clojure">(defn the-ns
  {:added &quot;1.0&quot;
   :static true}
  ^clojure.lang.Namespace [x]
  (if (instance? clojure.lang.Namespace x)
    x
    (or (find-ns x) (throw (Exception. (str &quot;No namespace: &quot; x &quot; found&quot;))))))</pre></td></tr><tr><td class="docs"><p>Returns the name of the namespace, a symbol.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-name
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (.getName (the-ns ns)))</pre></td></tr><tr><td class="docs"><p>Returns a map of all the mappings for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-map
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (.getMappings (the-ns ns)))</pre></td></tr><tr><td class="docs"><p>Removes the mappings for the symbol from the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-unmap
  {:added &quot;1.0&quot;
   :static true}
  [ns sym]
  (.unmap (the-ns ns) sym))</pre></td></tr><tr><td class="docs"><p>(defn export [syms]
 (doseq [sym syms]
  (.. <em>ns</em> (intern sym) (setExported true))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a map of the public intern mappings for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-publics
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (let [ns (the-ns ns)]
    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)
                                 (= ns (.ns v))
                                 (.isPublic v)))
                (ns-map ns))))</pre></td></tr><tr><td class="docs"><p>Returns a map of the import mappings for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-imports
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (filter-key val (partial instance? Class) (ns-map ns)))</pre></td></tr><tr><td class="docs"><p>Returns a map of the intern mappings for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-interns
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (let [ns (the-ns ns)]
    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)
                                 (= ns (.ns v))))
                (ns-map ns))))</pre></td></tr><tr><td class="docs"><p>refers to all public vars of ns, subject to filters.
  filters can include at most one each of:</p>

<p>  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol</p>

<p>  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var's name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn refer
  {:added &quot;1.0&quot;}
  [ns-sym &amp; filters]
    (let [ns (or (find-ns ns-sym) (throw (new Exception (str &quot;No namespace: &quot; ns-sym))))
          fs (apply hash-map filters)
          nspublics (ns-publics ns)
          rename (or (:rename fs) {})
          exclude (set (:exclude fs))
          to-do (if (= :all (:refer fs))
                  (keys nspublics)
                  (or (:refer fs) (:only fs) (keys nspublics)))]
      (doseq [sym to-do]
        (when-not (exclude sym)
          (let [v (nspublics sym)]
            (when-not v
              (throw (new java.lang.IllegalAccessError
                          (if (get (ns-interns ns) sym)
                            (str sym &quot; is not public&quot;)
                            (str sym &quot; does not exist&quot;)))))
            (. *ns* (refer (or (rename sym) sym) v)))))))</pre></td></tr><tr><td class="docs"><p>Returns a map of the refer mappings for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-refers
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (let [ns (the-ns ns)]
    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)
                                 (not= ns (.ns v))))
                (ns-map ns))))</pre></td></tr><tr><td class="docs"><p>Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn alias
  {:added &quot;1.0&quot;
   :static true}
  [alias namespace-sym]
  (.addAlias *ns* alias (the-ns namespace-sym)))</pre></td></tr><tr><td class="docs"><p>Returns a map of the aliases for the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-aliases
  {:added &quot;1.0&quot;
   :static true}
  [ns]
  (.getAliases (the-ns ns)))</pre></td></tr><tr><td class="docs"><p>Removes the alias for the symbol from the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-unalias
  {:added &quot;1.0&quot;
   :static true}
  [ns sym]
  (.removeAlias (the-ns ns) sym))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq of every nth item in coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn take-nth
  {:added &quot;1.0&quot;
   :static true}
  [n coll]
    (lazy-seq
     (when-let [s (seq coll)]
       (cons (first s) (take-nth n (drop n s))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq of the first item in each coll, then the second etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defn interleave
  {:added &quot;1.0&quot;
   :static true}
  ([c1 c2]
     (lazy-seq
      (let [s1 (seq c1) s2 (seq c2)]
        (when (and s1 s2)
          (cons (first s1) (cons (first s2) 
                                 (interleave (rest s1) (rest s2))))))))
  ([c1 c2 &amp; colls] 
     (lazy-seq 
      (let [ss (map seq (conj colls c2 c1))]
        (when (every? identity ss)
          (concat (map first ss) (apply interleave (map rest ss))))))))</pre></td></tr><tr><td class="docs"><p>Gets the value in the var object</p>
</td><td class="codes"><pre class="brush: clojure">(defn var-get
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Var x] (. x (get)))</pre></td></tr><tr><td class="docs"><p>Sets the value in the var object to val. The var must be
 thread-locally bound.</p>
</td><td class="codes"><pre class="brush: clojure">(defn var-set
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Var x val] (. x (set val)))</pre></td></tr><tr><td class="docs"><p>varbinding=> symbol init-expr</p>

<p>  Executes the exprs in a context in which the symbols are bound to
  vars with per-thread bindings to the init-exprs.  The symbols refer
  to the var objects themselves, and must be accessed with var-get and
  var-set</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-local-vars
  {:added &quot;1.0&quot;}
  [name-vals-vec &amp; body]
  (assert-args
     (vector? name-vals-vec) &quot;a vector for its binding&quot;
     (even? (count name-vals-vec)) &quot;an even number of forms in binding vector&quot;)
  `(let [~@(interleave (take-nth 2 name-vals-vec)
                       (repeat '(.. clojure.lang.Var create setDynamic)))]
     (. clojure.lang.Var (pushThreadBindings (hash-map ~@name-vals-vec)))
     (try
      ~@body
      (finally (. clojure.lang.Var (popThreadBindings))))))</pre></td></tr><tr><td class="docs"><p>Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environement), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ns-resolve
  {:added &quot;1.0&quot;
   :static true}
  ([ns sym]
    (ns-resolve ns nil sym))
  ([ns env sym]
    (when-not (contains? env sym)
      (clojure.lang.Compiler/maybeResolveIn (the-ns ns) sym))))</pre></td></tr><tr><td class="docs"><p>same as (ns-resolve <em>ns</em> symbol) or (ns-resolve <em>ns</em> &amp;env symbol)</p>
</td><td class="codes"><pre class="brush: clojure">(defn resolve
  {:added &quot;1.0&quot;
   :static true}
  ([sym] (ns-resolve *ns* sym))
  ([env sym] (ns-resolve *ns* env sym)))</pre></td></tr><tr><td class="docs"><p>Constructs an array-map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn array-map
  {:added &quot;1.0&quot;
   :static true}
  ([] (. clojure.lang.PersistentArrayMap EMPTY))
  ([&amp; keyvals] (clojure.lang.PersistentArrayMap/createWithCheck (to-array keyvals))))</pre></td></tr><tr><td class="docs"><p>redefine let and loop  with destructuring</p>
</td><td class="codes"><pre class="brush: clojure">(defn destructure [bindings]
  (let [bents (partition 2 bindings)
        pb (fn pb [bvec b v]
               (let [pvec
                     (fn [bvec b val]
                       (let [gvec (gensym &quot;vec__&quot;)]
                         (loop [ret (-&gt; bvec (conj gvec) (conj val))
                                n 0
                                bs b
                                seen-rest? false]
                           (if (seq bs)
                             (let [firstb (first bs)]
                               (cond
                                (= firstb '&amp;) (recur (pb ret (second bs) (list `nthnext gvec n))
                                                     n
                                                     (nnext bs)
                                                     true)
                                (= firstb :as) (pb ret (second bs) gvec)
                                :else (if seen-rest?
                                        (throw (new Exception &quot;Unsupported binding form, only :as can follow &amp; parameter&quot;))
                                        (recur (pb ret firstb  (list `nth gvec n nil))
                                               (inc n)
                                               (next bs)
                                               seen-rest?))))
                             ret))))
                     pmap
                     (fn [bvec b v]
                       (let [gmap (gensym &quot;map__&quot;)
                             gmapseq (with-meta gmap {:tag 'clojure.lang.ISeq})
                             defaults (:or b)]
                         (loop [ret (-&gt; bvec (conj gmap) (conj v)
                                        (conj gmap) (conj `(if (seq? ~gmap) (clojure.lang.PersistentHashMap/create ~gmapseq) ~gmap))
                                        ((fn [ret]
                                           (if (:as b)
                                             (conj ret (:as b) gmap)
                                             ret))))
                                bes (reduce1
                                     (fn [bes entry]
                                       (reduce1 #(assoc %1 %2 ((val entry) %2))
                                               (dissoc bes (key entry))
                                               ((key entry) bes)))
                                     (dissoc b :as :or)
                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]
                           (if (seq bes)
                             (let [bb (key (first bes))
                                   bk (val (first bes))
                                   has-default (contains? defaults bb)]
                               (recur (pb ret bb (if has-default
                                                   (list `get gmap bk (defaults bb))
                                                   (list `get gmap bk)))
                                      (next bes)))
                             ret))))]
                 (cond
                  (symbol? b) (-&gt; bvec (conj b) (conj v))
                  (vector? b) (pvec bvec b v)
                  (map? b) (pmap bvec b v)
                  :else (throw (new Exception (str &quot;Unsupported binding form: &quot; b))))))
        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]
    (if (every? symbol? (map first bents))
      bindings
      (reduce1 process-entry [] bents))))</pre></td></tr><tr><td class="docs"><p>binding => binding-form init-expr</p>

<p>  Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro let
  {:added &quot;1.0&quot;, :special-form true, :forms '[(let [bindings*] exprs*)]}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (even? (count bindings)) &quot;an even number of forms in binding vector&quot;)
  `(let* ~(destructure bindings) ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:private true}
  maybe-destructured
  [params body]
  (if (every? symbol? params)
    (cons params body)
    (loop [params params
           new-params []
           lets []]
      (if params
        (if (symbol? (first params))
          (recur (next params) (conj new-params (first params)) lets)
          (let [gparam (gensym &quot;p__&quot;)]
            (recur (next params) (conj new-params gparam)
                   (-&gt; lets (conj (first params)) (conj gparam)))))
        `(~new-params
          (let ~lets
            ~@body))))))</pre></td></tr><tr><td class="docs"><p>params => positional-params* , or positional-params* &amp; next-param
  positional-param => binding-form
  next-param => binding-form
  name => symbol</p>

<p>  Defines a function</p>

<p>redefine fn with destructuring and pre/post conditions</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro fn
  {:added &quot;1.0&quot;, :special-form true,
   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}
  [&amp; sigs]
    (let [name (if (symbol? (first sigs)) (first sigs) nil)
          sigs (if name (next sigs) sigs)
          sigs (if (vector? (first sigs)) (list sigs) sigs)
          psig (fn* [sig]
                 (let [[params &amp; body] sig
                       conds (when (and (next body) (map? (first body))) 
                                           (first body))
                       body (if conds (next body) body)
                       conds (or conds (meta params))
                       pre (:pre conds)
                       post (:post conds)                       
                       body (if post
                              `((let [~'% ~(if (&lt; 1 (count body)) 
                                            `(do ~@body) 
                                            (first body))]
                                 ~@(map (fn* [c] `(assert ~c)) post)
                                 ~'%))
                              body)
                       body (if pre
                              (concat (map (fn* [c] `(assert ~c)) pre) 
                                      body)
                              body)]
                   (maybe-destructured params body)))
          new-sigs (map psig sigs)]
      (with-meta
        (if name
          (list* 'fn* name new-sigs)
          (cons 'fn* new-sigs))
        (meta &amp;form))))</pre></td></tr><tr><td class="docs"><p>Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein. Acts as a recur target.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro loop
  {:added &quot;1.0&quot;, :special-form true, :forms '[(loop [bindings*] exprs*)]}
  [bindings &amp; body]
    (assert-args
      (vector? bindings) &quot;a vector for its binding&quot;
      (even? (count bindings)) &quot;an even number of forms in binding vector&quot;)
    (let [db (destructure bindings)]
      (if (= db bindings)
        `(loop* ~bindings ~@body)
        (let [vs (take-nth 2 (drop 1 bindings))
              bs (take-nth 2 bindings)
              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)
              bfs (reduce1 (fn [ret [b v g]]
                            (if (symbol? b)
                              (conj ret g v)
                              (conj ret g v b g)))
                          [] (map vector bs vs gs))]
          `(let ~bfs
             (loop* ~(vec (interleave gs gs))
               (let ~(vec (interleave bs gs))
                 ~@body)))))))</pre></td></tr><tr><td class="docs"><p>bindings => x xs</p>

<p>  Same as (when (seq xs) (let [x (first xs)] body))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when-first
  {:added &quot;1.0&quot;}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) &quot;a vector for its binding&quot;
     (= 2 (count bindings)) &quot;exactly 2 forms in binding vector&quot;)
  (let [[x xs] bindings]
    `(when (seq ~xs)
       (let [~x (first ~xs)]
         ~@body))))</pre></td></tr><tr><td class="docs"><p>Expands to code which yields a lazy sequence of the concatenation
  of the supplied colls.  Each coll expr is not evaluated until it is
  needed. </p>

<p>  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro lazy-cat
  {:added &quot;1.0&quot;}
  [&amp; colls]
  `(concat ~@(map #(list `lazy-seq %) colls)))</pre></td></tr><tr><td class="docs"><p>List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.</p>

<p>  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro for
  {:added &quot;1.0&quot;}
  [seq-exprs body-expr]
  (assert-args
     (vector? seq-exprs) &quot;a vector for its binding&quot;
     (even? (count seq-exprs)) &quot;an even number of forms in binding vector&quot;)
  (let [to-groups (fn [seq-exprs]
                    (reduce1 (fn [groups [k v]]
                              (if (keyword? k)
                                (conj (pop groups) (conj (peek groups) [k v]))
                                (conj groups [k v])))
                            [] (partition 2 seq-exprs)))
        err (fn [&amp; msg] (throw (IllegalArgumentException. ^String (apply str msg))))
        emit-bind (fn emit-bind [[[bind expr &amp; mod-pairs]
                                  &amp; [[_ next-expr] :as next-groups]]]
                    (let [giter (gensym &quot;iter__&quot;)
                          gxs (gensym &quot;s__&quot;)
                          do-mod (fn do-mod [[[k v :as pair] &amp; etc]]
                                   (cond
                                     (= k :let) `(let ~v ~(do-mod etc))
                                     (= k :while) `(when ~v ~(do-mod etc))
                                     (= k :when) `(if ~v
                                                    ~(do-mod etc)
                                                    (recur (rest ~gxs)))
                                     (keyword? k) (err &quot;Invalid 'for' keyword &quot; k)
                                     next-groups
                                      `(let [iterys# ~(emit-bind next-groups)
                                             fs# (seq (iterys# ~next-expr))]
                                         (if fs#
                                           (concat fs# (~giter (rest ~gxs)))
                                           (recur (rest ~gxs))))
                                     :else `(cons ~body-expr
                                                  (~giter (rest ~gxs)))))]
                      (if next-groups
                        #_&quot;not the inner-most loop&quot;
                        `(fn ~giter [~gxs]
                           (lazy-seq
                             (loop [~gxs ~gxs]
                               (when-first [~bind ~gxs]
                                 ~(do-mod mod-pairs)))))
                        #_&quot;inner-most loop&quot;
                        (let [gi (gensym &quot;i__&quot;)
                              gb (gensym &quot;b__&quot;)
                              do-cmod (fn do-cmod [[[k v :as pair] &amp; etc]]
                                        (cond
                                          (= k :let) `(let ~v ~(do-cmod etc))
                                          (= k :while) `(when ~v ~(do-cmod etc))
                                          (= k :when) `(if ~v
                                                         ~(do-cmod etc)
                                                         (recur
                                                           (unchecked-inc ~gi)))
                                          (keyword? k)
                                            (err &quot;Invalid 'for' keyword &quot; k)
                                          :else
                                            `(do (chunk-append ~gb ~body-expr)
                                                 (recur (unchecked-inc ~gi)))))]
                          `(fn ~giter [~gxs]
                             (lazy-seq
                               (loop [~gxs ~gxs]
                                 (when-let [~gxs (seq ~gxs)]
                                   (if (chunked-seq? ~gxs)
                                     (let [c# (chunk-first ~gxs)
                                           size# (int (count c#))
                                           ~gb (chunk-buffer size#)]
                                       (if (loop [~gi (int 0)]
                                             (if (&lt; ~gi size#)
                                               (let [~bind (.nth c# ~gi)]
                                                 ~(do-cmod mod-pairs))
                                               true))
                                         (chunk-cons
                                           (chunk ~gb)
                                           (~giter (chunk-rest ~gxs)))
                                         (chunk-cons (chunk ~gb) nil)))
                                     (let [~bind (first ~gxs)]
                                       ~(do-mod mod-pairs)))))))))))]
    `(let [iter# ~(emit-bind (to-groups seq-exprs))]
        (iter# ~(second seq-exprs)))))</pre></td></tr><tr><td class="docs"><p>Ignores body, yields nil</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro comment
  {:added &quot;1.0&quot;}
  [&amp; body])</pre></td></tr><tr><td class="docs"><p>Evaluates exprs in a context in which <em>out</em> is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-out-str
  {:added &quot;1.0&quot;}
  [&amp; body]
  `(let [s# (new java.io.StringWriter)]
     (binding [*out* s#]
       ~@body
       (str s#))))</pre></td></tr><tr><td class="docs"><p>Evaluates body in a context in which <em>in</em> is bound to a fresh
  StringReader initialized with the string s.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-in-str
  {:added &quot;1.0&quot;}
  [s &amp; body]
  `(with-open [s# (-&gt; (java.io.StringReader. ~s) clojure.lang.LineNumberingPushbackReader.)]
     (binding [*in* s#]
       ~@body)))</pre></td></tr><tr><td class="docs"><p>pr to a string, returning it</p>
</td><td class="codes"><pre class="brush: clojure">(defn pr-str
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [&amp; xs]
    (with-out-str
     (apply pr xs)))</pre></td></tr><tr><td class="docs"><p>prn to a string, returning it</p>
</td><td class="codes"><pre class="brush: clojure">(defn prn-str
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [&amp; xs]
  (with-out-str
   (apply prn xs)))</pre></td></tr><tr><td class="docs"><p>print to a string, returning it</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-str
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [&amp; xs]
    (with-out-str
     (apply print xs)))</pre></td></tr><tr><td class="docs"><p>println to a string, returning it</p>
</td><td class="codes"><pre class="brush: clojure">(defn println-str
  {:tag String
   :added &quot;1.0&quot;
   :static true}
  [&amp; xs]
    (with-out-str
     (apply println xs)))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
   Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.</p>
</td><td class="codes"><pre class="brush: clojure">(import clojure.lang.ExceptionInfo)
(defn ex-info
  {:added &quot;1.4&quot;}
  ([msg map]
     (ExceptionInfo. msg map))
  ([msg map cause]
     (ExceptionInfo. msg map cause)))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
   Returns exception data (a map) if ex is an ExceptionInfo.
   Otherwise returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ex-data
  {:added &quot;1.4&quot;}
  [ex]
  (when (instance? ExceptionInfo ex)
    (.getData ^ExceptionInfo ex)))</pre></td></tr><tr><td class="docs"><p>Evaluates expr and throws an exception if it does not evaluate to
  logical true.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro assert
  {:added &quot;1.0&quot;}
  ([x]
     (when *assert*
       `(when-not ~x
          (throw (new AssertionError (str &quot;Assert failed: &quot; (pr-str '~x)))))))
  ([x message]
     (when *assert*
       `(when-not ~x
          (throw (new AssertionError (str &quot;Assert failed: &quot; ~message &quot;\n&quot; (pr-str '~x))))))))</pre></td></tr><tr><td class="docs"><p>test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception</p>
</td><td class="codes"><pre class="brush: clojure">(defn test
  {:added &quot;1.0&quot;}
  [v]
    (let [f (:test (meta v))]
      (if f
        (do (f) :ok)
        :no-test)))</pre></td></tr><tr><td class="docs"><p>Returns an instance of java.util.regex.Pattern, for use, e.g. in
  re-matcher.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-pattern
  {:tag java.util.regex.Pattern
   :added &quot;1.0&quot;
   :static true}
  [s] (if (instance? java.util.regex.Pattern s)
        s
        (. java.util.regex.Pattern (compile s))))</pre></td></tr><tr><td class="docs"><p>Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-matcher
  {:tag java.util.regex.Matcher
   :added &quot;1.0&quot;
   :static true}
  [^java.util.regex.Pattern re s]
    (. re (matcher s)))</pre></td></tr><tr><td class="docs"><p>Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-groups
  {:added &quot;1.0&quot;
   :static true}
  [^java.util.regex.Matcher m]
    (let [gc  (. m (groupCount))]
      (if (zero? gc)
        (. m (group))
        (loop [ret [] c 0]
          (if (&lt;= c gc)
            (recur (conj ret (. m (group c))) (inc c))
            ret)))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of successive matches of pattern in string,
  using java.util.regex.Matcher.find(), each such match processed with
  re-groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-seq
  {:added &quot;1.0&quot;
   :static true}
  [^java.util.regex.Pattern re s]
  (let [m (re-matcher re s)]
    ((fn step []
       (when (. m (find))
         (cons (re-groups m) (lazy-seq (step))))))))</pre></td></tr><tr><td class="docs"><p>Returns the match, if any, of string to pattern, using
  java.util.regex.Matcher.matches().  Uses re-groups to return the
  groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-matches
  {:added &quot;1.0&quot;
   :static true}
  [^java.util.regex.Pattern re s]
    (let [m (re-matcher re s)]
      (when (. m (matches))
        (re-groups m))))</pre></td></tr><tr><td class="docs"><p>Returns the next regex match, if any, of string to pattern, using
  java.util.regex.Matcher.find().  Uses re-groups to return the
  groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn re-find
  {:added &quot;1.0&quot;
   :static true}
  ([^java.util.regex.Matcher m]
   (when (. m (find))
     (re-groups m)))
  ([^java.util.regex.Pattern re s]
   (let [m (re-matcher re s)]
     (re-find m))))</pre></td></tr><tr><td class="docs"><p>Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).</p>
</td><td class="codes"><pre class="brush: clojure">(defn rand
  {:added &quot;1.0&quot;
   :static true}
  ([] (. Math (random)))
  ([n] (* n (rand))))</pre></td></tr><tr><td class="docs"><p>Returns a random integer between 0 (inclusive) and n (exclusive).</p>
</td><td class="codes"><pre class="brush: clojure">(defn rand-int
  {:added &quot;1.0&quot;
   :static true}
  [n] (int (rand n)))</pre></td></tr><tr><td class="docs"><p>same as defn, yielding non-public def</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defn-
  {:added &quot;1.0&quot;}
  [name &amp; decls]
    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tree-seq
  {:added &quot;1.0&quot;
   :static true}
   [branch? children root]
   (let [walk (fn walk [node]
                (lazy-seq
                 (cons node
                  (when (branch? node)
                    (mapcat walk (children node))))))]
     (walk root)))</pre></td></tr><tr><td class="docs"><p>A tree seq on java.io.Files</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-seq
  {:added &quot;1.0&quot;
   :static true}
  [dir]
    (tree-seq
     (fn [^java.io.File f] (. f (isDirectory)))
     (fn [^java.io.File d] (seq (. d (listFiles))))
     dir))</pre></td></tr><tr><td class="docs"><p>A tree seq on the xml elements as per xml/parse</p>
</td><td class="codes"><pre class="brush: clojure">(defn xml-seq
  {:added &quot;1.0&quot;
   :static true}
  [root]
    (tree-seq
     (complement string?)
     (comp seq :content)
     root))</pre></td></tr><tr><td class="docs"><p>Returns true if s names a special form</p>
</td><td class="codes"><pre class="brush: clojure">(defn special-symbol?
  {:added &quot;1.0&quot;
   :static true}
  [s]
    (contains? (. clojure.lang.Compiler specials) s))</pre></td></tr><tr><td class="docs"><p>Returns true if v is of type clojure.lang.Var</p>
</td><td class="codes"><pre class="brush: clojure">(defn var?
  {:added &quot;1.0&quot;
   :static true}
  [v] (instance? clojure.lang.Var v))</pre></td></tr><tr><td class="docs"><p>Returns the substring of s beginning at start inclusive, and ending
  at end (defaults to length of string), exclusive.</p>
</td><td class="codes"><pre class="brush: clojure">(defn subs
  {:added &quot;1.0&quot;
   :static true}
  (^String [^String s start] (. s (substring start)))
  (^String [^String s start end] (. s (substring start end))))</pre></td></tr><tr><td class="docs"><p>Returns the x for which (k x), a number, is greatest.</p>
</td><td class="codes"><pre class="brush: clojure">(defn max-key
  {:added &quot;1.0&quot;
   :static true}
  ([k x] x)
  ([k x y] (if (&gt; (k x) (k y)) x y))
  ([k x y &amp; more]
   (reduce1 #(max-key k %1 %2) (max-key k x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns the x for which (k x), a number, is least.</p>
</td><td class="codes"><pre class="brush: clojure">(defn min-key
  {:added &quot;1.0&quot;
   :static true}
  ([k x] x)
  ([k x y] (if (&lt; (k x) (k y)) x y))
  ([k x y &amp; more]
   (reduce1 #(min-key k %1 %2) (min-key k x y) more)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the elements of coll with duplicates removed</p>
</td><td class="codes"><pre class="brush: clojure">(defn distinct
  {:added &quot;1.0&quot;
   :static true}
  [coll]
    (let [step (fn step [xs seen]
                   (lazy-seq
                    ((fn [[f :as xs] seen]
                      (when-let [s (seq xs)]
                        (if (contains? seen f) 
                          (recur (rest s) seen)
                          (cons f (step (rest s) (conj seen f))))))
                     xs seen)))]
      (step coll #{})))</pre></td></tr><tr><td class="docs"><p>Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap</p>
</td><td class="codes"><pre class="brush: clojure">(defn replace
  {:added &quot;1.0&quot;
   :static true}
  [smap coll]
    (if (vector? coll)
      (reduce1 (fn [v i]
                (if-let [e (find smap (nth v i))]
                        (assoc v i (val e))
                        v))
              coll (range (count coll)))
      (map #(if-let [e (find smap %)] (val e) %) coll)))</pre></td></tr><tr><td class="docs"><p>Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro dosync
  {:added &quot;1.0&quot;}
  [&amp; exprs]
  `(sync nil ~@exprs))</pre></td></tr><tr><td class="docs"><p>Sets the precision and rounding mode to be used for BigDecimal operations.</p>

<p>  Usage: (with-precision 10 (/ 1M 3))
  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))</p>

<p>  The rounding mode is one of CEILING, FLOOR, HALF<em>UP, HALF</em>DOWN,
  HALF<em>EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF</em>UP.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-precision
  {:added &quot;1.0&quot;}
  [precision &amp; exprs]
    (let [[body rm] (if (= (first exprs) :rounding)
                      [(next (next exprs))
                       `((. java.math.RoundingMode ~(second exprs)))]
                      [exprs nil])]
      `(binding [*math-context* (java.math.MathContext. ~precision ~@rm)]
         ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mk-bound-fn
  {:private true}
  [^clojure.lang.Sorted sc test key]
  (fn [e]
    (test (.. sc comparator (compare (. sc entryKey e) key)) 0)))</pre></td></tr><tr><td class="docs"><p>sc must be a sorted collection, test(s) one of &lt;, &lt;=, > or</p>

<blockquote>
  <p>=. Returns a seq of those entries with keys ek for
    which (test (.. sc comparator (compare ek key)) 0) is true</p>
</blockquote>
</td><td class="codes"><pre class="brush: clojure">(defn subseq
  {:added &quot;1.0&quot;
   :static true}
  ([^clojure.lang.Sorted sc test key]
   (let [include (mk-bound-fn sc test key)]
     (if (#{&gt; &gt;=} test)
       (when-let [[e :as s] (. sc seqFrom key true)]
         (if (include e) s (next s)))
       (take-while include (. sc seq true)))))
  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]
   (when-let [[e :as s] (. sc seqFrom start-key true)]
     (take-while (mk-bound-fn sc end-test end-key)
                 (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))</pre></td></tr><tr><td class="docs"><p>sc must be a sorted collection, test(s) one of &lt;, &lt;=, > or</p>

<blockquote>
  <p>=. Returns a reverse seq of those entries with keys ek for
    which (test (.. sc comparator (compare ek key)) 0) is true</p>
</blockquote>
</td><td class="codes"><pre class="brush: clojure">(defn rsubseq
  {:added &quot;1.0&quot;
   :static true}
  ([^clojure.lang.Sorted sc test key]
   (let [include (mk-bound-fn sc test key)]
     (if (#{&lt; &lt;=} test)
       (when-let [[e :as s] (. sc seqFrom key false)]
         (if (include e) s (next s)))
       (take-while include (. sc seq false)))))
  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]
   (when-let [[e :as s] (. sc seqFrom end-key false)]
     (take-while (mk-bound-fn sc start-test start-key)
                 (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))</pre></td></tr><tr><td class="docs"><p>Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it</p>
</td><td class="codes"><pre class="brush: clojure">(defn repeatedly
  {:added &quot;1.0&quot;
   :static true}
  ([f] (lazy-seq (cons (f) (repeatedly f))))
  ([n f] (take n (repeatedly f))))</pre></td></tr><tr><td class="docs"><p>DEPRECATED </p>

<p>  Adds the url (String or URL object) to the classpath per
  URLClassLoader.addURL</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-classpath
  {:added &quot;1.0&quot;
   :deprecated &quot;1.1&quot;}
  [url]
  (println &quot;WARNING: add-classpath is deprecated&quot;)
  (clojure.lang.RT/addURL url))</pre></td></tr><tr><td class="docs"><p>Returns the hash code of its argument. Note this is the hash code
  consistent with =, and thus is different than .hashCode for Integer,
  Short, Byte and Clojure collections.</p>
</td><td class="codes"><pre class="brush: clojure">(defn hash
  {:added &quot;1.0&quot;
   :static true}
  [x] (. clojure.lang.Util (hasheq x)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq of the elements of coll separated by sep</p>
</td><td class="codes"><pre class="brush: clojure">(defn interpose
  {:added &quot;1.0&quot;
   :static true}
  [sep coll] (drop 1 (interleave (repeat sep) coll)))</pre></td></tr><tr><td class="docs"><p>Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro definline
  {:added &quot;1.0&quot;}
  [name &amp; decl]
  (let [[pre-args [args expr]] (split-with (comp not vector?) decl)]
    `(do
       (defn ~name ~@pre-args ~args ~(apply (eval (list `fn args expr)) args))
       (alter-meta! (var ~name) assoc :inline (fn ~name ~args ~expr))
       (var ~name))))</pre></td></tr><tr><td class="docs"><p>Returns an empty collection of the same category as coll, or nil</p>
</td><td class="codes"><pre class="brush: clojure">(defn empty
  {:added &quot;1.0&quot;
   :static true}
  [coll]
  (when (instance? clojure.lang.IPersistentCollection coll)
    (.empty ^clojure.lang.IPersistentCollection coll)))</pre></td></tr><tr><td class="docs"><p>Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro amap
  {:added &quot;1.0&quot;}
  [a idx ret expr]
  `(let [a# ~a
         ~ret (aclone a#)]
     (loop  [~idx 0]
       (if (&lt; ~idx  (alength a#))
         (do
           (aset ~ret ~idx ~expr)
           (recur (unchecked-inc ~idx)))
         ~ret))))</pre></td></tr><tr><td class="docs"><p>Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the 
  evaluation of expr at each step, returning ret.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro areduce
  {:added &quot;1.0&quot;}
  [a idx ret init expr]
  `(let [a# ~a]
     (loop  [~idx 0 ~ret ~init]
       (if (&lt; ~idx  (alength a#))
         (recur (unchecked-inc ~idx) ~expr)
         ~ret))))</pre></td></tr><tr><td class="docs"><p>Creates an array of floats</p>
</td><td class="codes"><pre class="brush: clojure">(defn float-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers float_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.0&quot;}
  ([size-or-seq] (. clojure.lang.Numbers float_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers float_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of booleans</p>
</td><td class="codes"><pre class="brush: clojure">(defn boolean-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers boolean_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.1&quot;}
  ([size-or-seq] (. clojure.lang.Numbers boolean_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers boolean_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of bytes</p>
</td><td class="codes"><pre class="brush: clojure">(defn byte-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers byte_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.1&quot;}
  ([size-or-seq] (. clojure.lang.Numbers byte_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers byte_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of chars</p>
</td><td class="codes"><pre class="brush: clojure">(defn char-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers char_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.1&quot;}
  ([size-or-seq] (. clojure.lang.Numbers char_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers char_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of shorts</p>
</td><td class="codes"><pre class="brush: clojure">(defn short-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers short_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.1&quot;}
  ([size-or-seq] (. clojure.lang.Numbers short_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers short_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of doubles</p>
</td><td class="codes"><pre class="brush: clojure">(defn double-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers double_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.0&quot;}
  ([size-or-seq] (. clojure.lang.Numbers double_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers double_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of objects</p>
</td><td class="codes"><pre class="brush: clojure">(defn object-array
  {:inline (fn [arg] `(. clojure.lang.RT object_array ~arg))
   :inline-arities #{1}
   :added &quot;1.2&quot;}
  ([size-or-seq] (. clojure.lang.RT object_array size-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of ints</p>
</td><td class="codes"><pre class="brush: clojure">(defn int-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers int_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.0&quot;}
  ([size-or-seq] (. clojure.lang.Numbers int_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers int_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Creates an array of longs</p>
</td><td class="codes"><pre class="brush: clojure">(defn long-array
  {:inline (fn [&amp; args] `(. clojure.lang.Numbers long_array ~@args))
   :inline-arities #{1 2}
   :added &quot;1.0&quot;}
  ([size-or-seq] (. clojure.lang.Numbers long_array size-or-seq))
  ([size init-val-or-seq] (. clojure.lang.Numbers long_array size init-val-or-seq)))</pre></td></tr><tr><td class="docs"><p>Casts to boolean[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline booleans
  {:added &quot;1.1&quot;}
  [xs] `(. clojure.lang.Numbers booleans ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to bytes[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline bytes
  {:added &quot;1.1&quot;}
  [xs] `(. clojure.lang.Numbers bytes ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to chars[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline chars
  {:added &quot;1.1&quot;}
  [xs] `(. clojure.lang.Numbers chars ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to shorts[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline shorts
  {:added &quot;1.1&quot;}
  [xs] `(. clojure.lang.Numbers shorts ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to float[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline floats
  {:added &quot;1.0&quot;}
  [xs] `(. clojure.lang.Numbers floats ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to int[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline ints
  {:added &quot;1.0&quot;}
  [xs] `(. clojure.lang.Numbers ints ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to double[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline doubles
  {:added &quot;1.0&quot;}
  [xs] `(. clojure.lang.Numbers doubles ~xs))</pre></td></tr><tr><td class="docs"><p>Casts to long[]</p>
</td><td class="codes"><pre class="brush: clojure">(definline longs
  {:added &quot;1.0&quot;}
  [xs] `(. clojure.lang.Numbers longs ~xs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import '(java.util.concurrent BlockingQueue LinkedBlockingQueue))</pre></td></tr><tr><td class="docs"><p>Creates a queued seq on another (presumably lazy) seq s. The queued
  seq will produce a concrete seq in the background, and can get up to
  n items ahead of the consumer. n-or-q can be an integer n buffer
  size, or an instance of java.util.concurrent BlockingQueue. Note
  that reading from a seque can block if the reader gets ahead of the
  producer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn seque
  {:added &quot;1.0&quot;
   :static true}
  ([s] (seque 100 s))
  ([n-or-q s]
   (let [^BlockingQueue q (if (instance? BlockingQueue n-or-q)
                             n-or-q
                             (LinkedBlockingQueue. (int n-or-q)))
         NIL (Object.) ;nil sentinel since LBQ doesn't support nils
         agt (agent (seq s))
         fill (fn [s]
                (try
                  (loop [[x &amp; xs :as s] s]
                    (if s
                      (if (.offer q (if (nil? x) NIL x))
                        (recur xs)
                        s)
                      (.put q q))) ; q itself is eos sentinel
                  (catch Exception e
                    (.put q q)
                    (throw e))))
         drain (fn drain []
                 (lazy-seq
                  (let [x (.take q)]
                    (if (identical? x q) ;q itself is eos sentinel
                      (do @agt nil)  ;touch agent just to propagate errors
                      (do
                        (send-off agt fill)
                        (cons (if (identical? x NIL) nil x) (drain)))))))]
     (send-off agt fill)
     (drain))))</pre></td></tr><tr><td class="docs"><p>Returns true if x is an instance of Class</p>
</td><td class="codes"><pre class="brush: clojure">(defn class?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? Class x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- is-annotation? [c]
  (and (class? c)
       (.isAssignableFrom java.lang.annotation.Annotation c)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- is-runtime-annotation? [^Class c]
  (boolean 
   (and (is-annotation? c)
        (when-let [^java.lang.annotation.Retention r 
                   (.getAnnotation c java.lang.annotation.Retention)] 
          (= (.value r) java.lang.annotation.RetentionPolicy/RUNTIME)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- descriptor [^Class c] (clojure.asm.Type/getDescriptor c))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare process-annotation)
(defn- add-annotation [^clojure.asm.AnnotationVisitor av name v]
  (cond
   (vector? v) (let [avec (.visitArray av name)]
                 (doseq [vval v]
                   (add-annotation avec &quot;value&quot; vval))
                 (.visitEnd avec))
   (symbol? v) (let [ev (eval v)]
                 (cond 
                  (instance? java.lang.Enum ev)
                  (.visitEnum av name (descriptor (class ev)) (str ev))
                  (class? ev) (.visit av name (clojure.asm.Type/getType ev))
                  :else (throw (IllegalArgumentException. 
                                (str &quot;Unsupported annotation value: &quot; v &quot; of class &quot; (class ev))))))
   (seq? v) (let [[nested nv] v
                  c (resolve nested)
                  nav (.visitAnnotation av name (descriptor c))]
              (process-annotation nav nv)
              (.visitEnd nav))
   :else (.visit av name v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- process-annotation [av v]
  (if (map? v) 
    (doseq [[k v] v]
      (add-annotation av (name k) v))
    (add-annotation av &quot;value&quot; v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- add-annotations
  ([visitor m] (add-annotations visitor m nil))
  ([visitor m i]
     (doseq [[k v] m]
       (when (symbol? k)
         (when-let [c (resolve k)]
           (when (is-annotation? c)
                                        ;this is known duck/reflective as no common base of ASM Visitors
             (let [av (if i
                        (.visitParameterAnnotation visitor i (descriptor c) 
                                                   (is-runtime-annotation? c))
                        (.visitAnnotation visitor (descriptor c) 
                                          (is-runtime-annotation? c)))]
               (process-annotation av v)
               (.visitEnd av))))))))</pre></td></tr><tr><td class="docs"><p>Atomically alters the root binding of var v by applying f to its
  current value plus any args</p>
</td><td class="codes"><pre class="brush: clojure">(defn alter-var-root
  {:added &quot;1.0&quot;
   :static true}
  [^clojure.lang.Var v f &amp; args] (.alterRoot v f args))</pre></td></tr><tr><td class="docs"><p>Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bound?
  {:added &quot;1.2&quot;
   :static true}
  [&amp; vars]
  (every? #(.isBound ^clojure.lang.Var %) vars))</pre></td></tr><tr><td class="docs"><p>Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-bound?
  {:added &quot;1.2&quot;
   :static true}
  [&amp; vars]
  (every? #(.getThreadBinding ^clojure.lang.Var %) vars))</pre></td></tr><tr><td class="docs"><p>Creates a hierarchy object for use with derive, isa? etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-hierarchy
  {:added &quot;1.0&quot;
   :static true}
  [] {:parents {} :descendants {} :ancestors {}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     global-hierarchy (make-hierarchy))</pre></td></tr><tr><td class="docs"><p>If coll is empty, returns nil, else coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn not-empty
  {:added &quot;1.0&quot;
   :static true}
  [coll] (when (seq coll) coll))</pre></td></tr><tr><td class="docs"><p>Returns the immediate superclass and direct interfaces of c, if any</p>
</td><td class="codes"><pre class="brush: clojure">(defn bases
  {:added &quot;1.0&quot;
   :static true}
  [^Class c]
  (when c
    (let [i (.getInterfaces c)
          s (.getSuperclass c)]
      (not-empty
       (if s (cons s i) i)))))</pre></td></tr><tr><td class="docs"><p>Returns the immediate and indirect superclasses and interfaces of c, if any</p>
</td><td class="codes"><pre class="brush: clojure">(defn supers
  {:added &quot;1.0&quot;
   :static true}
  [^Class class]
  (loop [ret (set (bases class)) cs ret]
    (if (seq cs)
      (let [c (first cs) bs (bases c)]
        (recur (into1 ret bs) (into1 (disj cs c) bs)))
      (not-empty ret))))</pre></td></tr><tr><td class="docs"><p>Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy</p>
</td><td class="codes"><pre class="brush: clojure">(defn isa?
  {:added &quot;1.0&quot;}
  ([child parent] (isa? global-hierarchy child parent))
  ([h child parent]
   (or (= child parent)
       (and (class? parent) (class? child)
            (. ^Class parent isAssignableFrom child))
       (contains? ((:ancestors h) child) parent)
       (and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))
       (and (vector? parent) (vector? child)
            (= (count parent) (count child))
            (loop [ret true i 0]
              (if (or (not ret) (= i (count parent)))
                ret
                (recur (isa? h (child i) (parent i)) (inc i))))))))</pre></td></tr><tr><td class="docs"><p>Returns the immediate parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy</p>
</td><td class="codes"><pre class="brush: clojure">(defn parents
  {:added &quot;1.0&quot;}
  ([tag] (parents global-hierarchy tag))
  ([h tag] (not-empty
            (let [tp (get (:parents h) tag)]
              (if (class? tag)
                (into1 (set (bases tag)) tp)
                tp)))))</pre></td></tr><tr><td class="docs"><p>Returns the immediate and indirect parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy</p>
</td><td class="codes"><pre class="brush: clojure">(defn ancestors
  {:added &quot;1.0&quot;}
  ([tag] (ancestors global-hierarchy tag))
  ([h tag] (not-empty
            (let [ta (get (:ancestors h) tag)]
              (if (class? tag)
                (let [superclasses (set (supers tag))]
                  (reduce1 into1 superclasses
                    (cons ta
                          (map #(get (:ancestors h) %) superclasses))))
                ta)))))</pre></td></tr><tr><td class="docs"><p>Returns the immediate and indirect children of tag, through a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy. Note: does not work on Java type inheritance
  relationships.</p>
</td><td class="codes"><pre class="brush: clojure">(defn descendants
  {:added &quot;1.0&quot;}
  ([tag] (descendants global-hierarchy tag))
  ([h tag] (if (class? tag)
             (throw (java.lang.UnsupportedOperationException. &quot;Can't get descendants of classes&quot;))
             (not-empty (get (:descendants h) tag)))))</pre></td></tr><tr><td class="docs"><p>Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn derive
  {:added &quot;1.0&quot;}
  ([tag parent]
   (assert (namespace parent))
   (assert (or (class? tag) (and (instance? clojure.lang.Named tag) (namespace tag))))
   (alter-var-root #'global-hierarchy derive tag parent) nil)
  ([h tag parent]
   (assert (not= tag parent))
   (assert (or (class? tag) (instance? clojure.lang.Named tag)))
   (assert (instance? clojure.lang.Named parent))
   (let [tp (:parents h)
         td (:descendants h)
         ta (:ancestors h)
         tf (fn [m source sources target targets]
              (reduce1 (fn [ret k]
                        (assoc ret k
                               (reduce1 conj (get targets k #{}) (cons target (targets target)))))
                      m (cons source (sources source))))]
     (or
      (when-not (contains? (tp tag) parent)
        (when (contains? (ta tag) parent)
          (throw (Exception. (print-str tag &quot;already has&quot; parent &quot;as ancestor&quot;))))
        (when (contains? (ta parent) tag)
          (throw (Exception. (print-str &quot;Cyclic derivation:&quot; parent &quot;has&quot; tag &quot;as ancestor&quot;))))
        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))
         :ancestors (tf (:ancestors h) tag td parent ta)
         :descendants (tf (:descendants h) parent ta tag td)})
      h))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare flatten)</pre></td></tr><tr><td class="docs"><p>Removes a parent/child relationship between parent and
  tag. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn underive
  {:added &quot;1.0&quot;}
  ([tag parent] (alter-var-root #'global-hierarchy underive tag parent) nil)
  ([h tag parent]
    (let [parentMap (:parents h)
	  childsParents (if (parentMap tag)
			  (disj (parentMap tag) parent) #{})
	  newParents (if (not-empty childsParents)
		       (assoc parentMap tag childsParents)
		       (dissoc parentMap tag))
	  deriv-seq (flatten (map #(cons (key %) (interpose (key %) (val %)))
				       (seq newParents)))]
      (if (contains? (parentMap tag) parent)
	(reduce1 #(apply derive %1 %2) (make-hierarchy)
		(partition 2 deriv-seq))
	h))))</pre></td></tr><tr><td class="docs"><p>Returns true if no two of the arguments are =</p>
</td><td class="codes"><pre class="brush: clojure">(defn distinct?
  {:tag Boolean
   :added &quot;1.0&quot;
   :static true}
  ([x] true)
  ([x y] (not (= x y)))
  ([x y &amp; more]
   (if (not= x y)
     (loop [s #{x y} [x &amp; etc :as xs] more]
       (if xs
         (if (contains? s x)
           false
           (recur (conj s x) etc))
         true))
     false)))</pre></td></tr><tr><td class="docs"><p>Creates and returns a lazy sequence of structmaps corresponding to
  the rows in the java.sql.ResultSet rs</p>
</td><td class="codes"><pre class="brush: clojure">(defn resultset-seq
  {:added &quot;1.0&quot;}
  [^java.sql.ResultSet rs]
    (let [rsmeta (. rs (getMetaData))
          idxs (range 1 (inc (. rsmeta (getColumnCount))))
          keys (map (comp keyword #(.toLowerCase ^String %))
                    (map (fn [i] (. rsmeta (getColumnLabel i))) idxs))
          check-keys
                (or (apply distinct? keys)
                    (throw (Exception. &quot;ResultSet must have unique column labels&quot;)))
          row-struct (apply create-struct keys)
          row-values (fn [] (map (fn [^Integer i] (. rs (getObject i))) idxs))
          rows (fn thisfn []
                 (when (. rs (next))
                   (cons (apply struct row-struct (row-values)) (lazy-seq (thisfn)))))]
      (rows)))</pre></td></tr><tr><td class="docs"><p>Returns a seq on a java.util.Iterator. Note that most collections
  providing iterators implement Iterable and thus support seq directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn iterator-seq
  {:added &quot;1.0&quot;
   :static true}
  [iter]
  (clojure.lang.IteratorSeq/create iter))</pre></td></tr><tr><td class="docs"><p>Returns a seq on a java.util.Enumeration</p>
</td><td class="codes"><pre class="brush: clojure">(defn enumeration-seq
  {:added &quot;1.0&quot;
   :static true}
  [e]
  (clojure.lang.EnumerationSeq/create e))</pre></td></tr><tr><td class="docs"><p>Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax</p>
</td><td class="codes"><pre class="brush: clojure">(defn format
  {:added &quot;1.0&quot;
   :static true}
  ^String [fmt &amp; args]
  (String/format fmt (to-array args)))</pre></td></tr><tr><td class="docs"><p>Prints formatted output, as per format</p>
</td><td class="codes"><pre class="brush: clojure">(defn printf
  {:added &quot;1.0&quot;
   :static true}
  [fmt &amp; args]
  (print (apply format fmt args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare gen-class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-loading-context [&amp; body]
  `((fn loading# [] 
        (. clojure.lang.Var (pushThreadBindings {clojure.lang.Compiler/LOADER  
                                                 (.getClassLoader (.getClass ^Object loading#))}))
        (try
         ~@body
         (finally
          (. clojure.lang.Var (popThreadBindings)))))))</pre></td></tr><tr><td class="docs"><p>Sets <em>ns</em> to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer 'clojure) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:</p>

<p>  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ns
  {:arglists '([name docstring? attr-map? references*])
   :added &quot;1.0&quot;}
  [name &amp; references]
  (let [process-reference
        (fn [[kname &amp; args]]
          `(~(symbol &quot;clojure.core&quot; (clojure.core/name kname))
             ~@(map #(list 'quote %) args)))
        docstring  (when (string? (first references)) (first references))
        references (if docstring (next references) references)
        name (if docstring
               (vary-meta name assoc :doc docstring)
               name)
        metadata   (when (map? (first references)) (first references))
        references (if metadata (next references) references)
        name (if metadata
               (vary-meta name merge metadata)
               name)
        gen-class-clause (first (filter #(= :gen-class (first %)) references))
        gen-class-call
          (when gen-class-clause
            (list* `gen-class :name (.replace (str name) \- \_) :impl-ns name :main true (next gen-class-clause)))
        references (remove #(= :gen-class (first %)) references)
        ;ns-effect (clojure.core/in-ns name)
        ]
    `(do
       (clojure.core/in-ns '~name)
       (with-loading-context
        ~@(when gen-class-call (list gen-class-call))
        ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))
            `((clojure.core/refer '~'clojure.core)))
        ~@(map process-reference references)))))</pre></td></tr><tr><td class="docs"><p>Same as (refer 'clojure.core <filters>)</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro refer-clojure
  {:added &quot;1.0&quot;}
  [&amp; filters]
  `(clojure.core/refer '~'clojure.core ~@filters))</pre></td></tr><tr><td class="docs"><p>defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defonce
  {:added &quot;1.0&quot;}
  [name expr]
  `(let [v# (def ~name)]
     (when-not (.hasRoot v#)
       (def ~name ~expr))))</pre></td></tr><tr><td class="docs"><p>require/use/load, contributed by Stephen C. Gilardi ;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A ref to a sorted set of symbols representing loaded libs</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic
  ^{:private true
     :doc }
  *loaded-libs* (ref (sorted-set)))</pre></td></tr><tr><td class="docs"><p>A stack of paths currently being loaded by this thread</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic
  ^{:private true
     :doc }
  *pending-paths* ())</pre></td></tr><tr><td class="docs"><p>True while a verbose load is pending</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic
  ^{:private true :doc
     }
  *loading-verbosely* false)</pre></td></tr><tr><td class="docs"><p>Throws an exception with a message if pred is true</p>
</td><td class="codes"><pre class="brush: clojure">(defn- throw-if
  [pred fmt &amp; args]
  (when pred
    (let [^String message (apply format fmt args)
          exception (Exception. message)
          raw-trace (.getStackTrace exception)
          boring? #(not= (.getMethodName ^StackTraceElement %) &quot;doInvoke&quot;)
          trace (into-array (drop 2 (drop-while boring? raw-trace)))]
      (.setStackTrace exception trace)
      (throw exception))))</pre></td></tr><tr><td class="docs"><p>Returns true if x is a libspec</p>
</td><td class="codes"><pre class="brush: clojure">(defn- libspec?
  [x]
  (or (symbol? x)
      (and (vector? x)
           (or
            (nil? (second x))
            (keyword? (second x))))))</pre></td></tr><tr><td class="docs"><p>Prepends a symbol or a seq to coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn- prependss
  [x coll]
  (if (symbol? x)
    (cons x coll)
    (concat x coll)))</pre></td></tr><tr><td class="docs"><p>Returns the root directory path for a lib</p>
</td><td class="codes"><pre class="brush: clojure">(defn- root-resource
  {:tag String}
  [lib]
  (str \/
       (.. (name lib)
           (replace \- \_)
           (replace \. \/))))</pre></td></tr><tr><td class="docs"><p>Returns the root resource path for a lib</p>
</td><td class="codes"><pre class="brush: clojure">(defn- root-directory
  [lib]
  (let [d (root-resource lib)]
    (subs d 0 (.lastIndexOf d &quot;/&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare load)</pre></td></tr><tr><td class="docs"><p>Loads a lib given its name. If need-ns, ensures that the associated
  namespace exists after loading. If require, records the load so any
  duplicate loads can be skipped.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-one
  [lib need-ns require]
  (load (root-resource lib))
  (throw-if (and need-ns (not (find-ns lib)))
            &quot;namespace '%s' not found after loading '%s'&quot;
            lib (root-resource lib))
  (when require
    (dosync
     (commute *loaded-libs* conj lib))))</pre></td></tr><tr><td class="docs"><p>Loads a lib given its name and forces a load of any libs it directly or
  indirectly loads. If need-ns, ensures that the associated namespace
  exists after loading. If require, records the load so any duplicate loads
  can be skipped.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-all
  [lib need-ns require]
  (dosync
   (commute *loaded-libs* #(reduce1 conj %1 %2)
            (binding [*loaded-libs* (ref (sorted-set))]
              (load-one lib need-ns require)
              @*loaded-libs*))))</pre></td></tr><tr><td class="docs"><p>Loads a lib with options</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-lib
  [prefix lib &amp; options]
  (throw-if (and prefix (pos? (.indexOf (name lib) (int \.))))
            &quot;lib names inside prefix lists must not contain periods&quot;)
  (let [lib (if prefix (symbol (str prefix \. lib)) lib)
        opts (apply hash-map options)
        {:keys [as reload reload-all require use verbose]} opts
        loaded (contains? @*loaded-libs* lib)
        load (cond reload-all
                   load-all
                   (or reload (not require) (not loaded))
                   load-one)
        need-ns (or as use)
        filter-opts (select-keys opts '(:exclude :only :rename :refer))
        undefined-on-entry (not (find-ns lib))]
    (binding [*loading-verbosely* (or *loading-verbosely* verbose)]
      (if load
        (try
          (load lib need-ns require)
          (catch Exception e
            (when undefined-on-entry
              (remove-ns lib))
            (throw e)))
        (throw-if (and need-ns (not (find-ns lib)))
                  &quot;namespace '%s' not found&quot; lib))
      (when (and need-ns *loading-verbosely*)
        (printf &quot;(clojure.core/in-ns '%s)\n&quot; (ns-name *ns*)))
      (when as
        (when *loading-verbosely*
          (printf &quot;(clojure.core/alias '%s '%s)\n&quot; as lib))
        (alias as lib))
      (when (or use (:refer filter-opts))
        (when *loading-verbosely*
          (printf &quot;(clojure.core/refer '%s&quot; lib)
          (doseq [opt filter-opts]
            (printf &quot; %s '%s&quot; (key opt) (print-str (val opt))))
          (printf &quot;)\n&quot;))
        (apply refer lib (mapcat seq filter-opts))))))</pre></td></tr><tr><td class="docs"><p>Loads libs, interpreting libspecs, prefix lists, and flags for
  forwarding to load-lib</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-libs
  [&amp; args]
  (let [flags (filter keyword? args)
        opts (interleave flags (repeat true))
        args (filter (complement keyword?) args)]
    ; check for unsupported options
    (let [supported #{:as :reload :reload-all :require :use :verbose :refer}
          unsupported (seq (remove supported flags))]
      (throw-if unsupported
                (apply str &quot;Unsupported option(s) supplied: &quot;
                     (interpose \, unsupported))))
    ; check a load target was specified
    (throw-if (not (seq args)) &quot;Nothing specified to load&quot;)
    (doseq [arg args]
      (if (libspec? arg)
        (apply load-lib nil (prependss arg opts))
        (let [[prefix &amp; args] arg]
          (throw-if (nil? prefix) &quot;prefix cannot be nil&quot;)
          (doseq [arg args]
            (apply load-lib prefix (prependss arg opts))))))))</pre></td></tr><tr><td class="docs"><p>Detects and rejects non-trivial cyclic load dependencies. The
  exception message shows the dependency chain with the cycle
  highlighted. Ignores the trivial case of a file attempting to load
  itself because that can occur when a gen-class'd class loads its
  implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- check-cyclic-dependency
  [path]
  (when (some #{path} (rest *pending-paths*))
    (let [pending (map #(if (= % path) (str &quot;[ &quot; % &quot; ]&quot;) %)
                       (cons path *pending-paths*))
          chain (apply str (interpose &quot;-&gt;&quot; pending))]
      (throw (Exception. (str &quot;Cyclic load dependency: &quot; chain))))))</pre></td></tr><tr><td class="docs"><p>Public</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.</p>

<p>  Libs</p>

<p>  A 'lib' is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib's
  name also locates its root directory within classpath using Java's
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.</p>

<p>  'require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol 'x.y.z; it has the root directory
  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root
  resource should contain code to create the lib's namespace (usually by using
  the ns macro) and load any additional lib resources.</p>

<p>  Libspecs</p>

<p>  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.</p>

<p>  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib's namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.</p>

<p>  Prefix Lists</p>

<p>  It's common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.</p>

<p>  Flags</p>

<p>  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer</p>

<p>  Example:</p>

<p>  The following would load the libraries clojure.zip and clojure.set
  abbreviated as 's'.</p>

<p>  (require '(clojure zip [set :as s]))</p>
</td><td class="codes"><pre class="brush: clojure">(defn require
  {:added &quot;1.0&quot;}
  [&amp; args]
  (apply load-libs :require args))</pre></td></tr><tr><td class="docs"><p>Like 'require, but also refers to each lib's namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.</p>

<p>  'use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn use
  {:added &quot;1.0&quot;}
  [&amp; args] (apply load-libs :require :use args))</pre></td></tr><tr><td class="docs"><p>Returns a sorted set of symbols naming the currently loaded libs</p>
</td><td class="codes"><pre class="brush: clojure">(defn loaded-libs
  {:added &quot;1.0&quot;}
  [] @*loaded-libs*)</pre></td></tr><tr><td class="docs"><p>Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load
  {:added &quot;1.0&quot;}
  [&amp; paths]
  (doseq [^String path paths]
    (let [^String path (if (.startsWith path &quot;/&quot;)
                          path
                          (str (root-directory (ns-name *ns*)) \/ path))]
      (when *loading-verbosely*
        (printf &quot;(clojure.core/load \&quot;%s\&quot;)\n&quot; path)
        (flush))
      (check-cyclic-dependency path)
      (when-not (= path (first *pending-paths*))
        (binding [*pending-paths* (conj *pending-paths* path)]
          (clojure.lang.RT/load (.substring path 1)))))))</pre></td></tr><tr><td class="docs"><p>Compiles the namespace named by the symbol lib into a set of
  classfiles. The source for the lib must be in a proper
  classpath-relative directory. The output files will go into the
  directory specified by <em>compile-path</em>, and that directory too must
  be in the classpath.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compile
  {:added &quot;1.0&quot;}
  [lib]
  (binding [*compile-files* true]
    (load-one lib true true))
  lib)</pre></td></tr><tr><td class="docs"><p>nested associative ops ;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-in
  {:added &quot;1.2&quot;
   :static true}
  ([m ks]
     (reduce1 get m ks))
  ([m ks not-found]
     (loop [sentinel (Object.)
            m m
            ks (seq ks)]
       (if ks
         (let [m (get m (first ks) sentinel)]
           (if (identical? sentinel m)
             not-found
             (recur sentinel m (next ks))))
         m))))</pre></td></tr><tr><td class="docs"><p>Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created.</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-in
  {:added &quot;1.0&quot;
   :static true}
  [m [k &amp; ks] v]
  (if ks
    (assoc m k (assoc-in (get m k) ks v))
    (assoc m k v)))</pre></td></tr><tr><td class="docs"><p>'Updates' a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-in
  {:added &quot;1.0&quot;
   :static true}
  ([m [k &amp; ks] f &amp; args]
   (if ks
     (assoc m k (apply update-in (get m k) ks f args))
     (assoc m k (apply f (get m k) args)))))</pre></td></tr><tr><td class="docs"><p>Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))</p>
</td><td class="codes"><pre class="brush: clojure">(defn empty?
  {:added &quot;1.0&quot;
   :static true}
  [coll] (not (seq coll)))</pre></td></tr><tr><td class="docs"><p>Returns true if x implements IPersistentCollection</p>
</td><td class="codes"><pre class="brush: clojure">(defn coll?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.IPersistentCollection x))</pre></td></tr><tr><td class="docs"><p>Returns true if x implements IPersistentList</p>
</td><td class="codes"><pre class="brush: clojure">(defn list?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.IPersistentList x))</pre></td></tr><tr><td class="docs"><p>Returns true if x implements IPersistentSet</p>
</td><td class="codes"><pre class="brush: clojure">(defn set?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.IPersistentSet x))</pre></td></tr><tr><td class="docs"><p>Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn</p>
</td><td class="codes"><pre class="brush: clojure">(defn ifn?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.IFn x))</pre></td></tr><tr><td class="docs"><p>Returns true if x implements Fn, i.e. is an object created via fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fn?
  {:added &quot;1.0&quot;
   :static true}
  [x] (instance? clojure.lang.Fn x))</pre></td></tr><tr><td class="docs"><p>Returns true if coll implements Associative</p>
</td><td class="codes"><pre class="brush: clojure">(defn associative?
 {:added &quot;1.0&quot;
  :static true}
  [coll] (instance? clojure.lang.Associative coll))</pre></td></tr><tr><td class="docs"><p>Returns true if coll implements Sequential</p>
</td><td class="codes"><pre class="brush: clojure">(defn sequential?
 {:added &quot;1.0&quot;
  :static true}
  [coll] (instance? clojure.lang.Sequential coll))</pre></td></tr><tr><td class="docs"><p>Returns true if coll implements Sorted</p>
</td><td class="codes"><pre class="brush: clojure">(defn sorted?
 {:added &quot;1.0&quot;
   :static true}
  [coll] (instance? clojure.lang.Sorted coll))</pre></td></tr><tr><td class="docs"><p>Returns true if coll implements count in constant time</p>
</td><td class="codes"><pre class="brush: clojure">(defn counted?
 {:added &quot;1.0&quot;
   :static true}
  [coll] (instance? clojure.lang.Counted coll))</pre></td></tr><tr><td class="docs"><p>Returns true if coll implements Reversible</p>
</td><td class="codes"><pre class="brush: clojure">(defn reversible?
 {:added &quot;1.0&quot;
   :static true}
  [coll] (instance? clojure.lang.Reversible coll))</pre></td></tr><tr><td class="docs"><p>bound in a repl thread to the most recent value printed</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *1)</pre></td></tr><tr><td class="docs"><p>bound in a repl thread to the second most recent value printed</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *2)</pre></td></tr><tr><td class="docs"><p>bound in a repl thread to the third most recent value printed</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *3)</pre></td></tr><tr><td class="docs"><p>bound in a repl thread to the most recent exception caught by the repl</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *e)</pre></td></tr><tr><td class="docs"><p>trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns.</p>
</td><td class="codes"><pre class="brush: clojure">(defn trampoline
  {:added &quot;1.0&quot;
   :static true}
  ([f]
     (let [ret (f)]
       (if (fn? ret)
         (recur ret)
         ret)))
  ([f &amp; args]
     (trampoline #(apply f args))))</pre></td></tr><tr><td class="docs"><p>Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var.</p>
</td><td class="codes"><pre class="brush: clojure">(defn intern
  {:added &quot;1.0&quot;
   :static true}
  ([ns ^clojure.lang.Symbol name]
     (let [v (clojure.lang.Var/intern (the-ns ns) name)]
       (when (meta name) (.setMeta v (meta name)))
       v))
  ([ns name val]
     (let [v (clojure.lang.Var/intern (the-ns ns) name val)]
       (when (meta name) (.setMeta v (meta name)))
       v)))</pre></td></tr><tr><td class="docs"><p>Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro while
  {:added &quot;1.0&quot;}
  [test &amp; body]
  `(loop []
     (when ~test
       ~@body
       (recur))))</pre></td></tr><tr><td class="docs"><p>Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use.</p>
</td><td class="codes"><pre class="brush: clojure">(defn memoize
  {:added &quot;1.0&quot;
   :static true}
  [f]
  (let [mem (atom {})]
    (fn [&amp; args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))</pre></td></tr><tr><td class="docs"><p>Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:</p>

<p>  test-expr result-expr</p>

<p>  test-expr :>> result-fn</p>

<p>  Note :>> is an ordinary keyword.</p>

<p>  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro condp
  {:added &quot;1.0&quot;}
  [pred expr &amp; clauses]
  (let [gpred (gensym &quot;pred__&quot;)
        gexpr (gensym &quot;expr__&quot;)
        emit (fn emit [pred expr args]
               (let [[[a b c :as clause] more]
                       (split-at (if (= :&gt;&gt; (second args)) 3 2) args)
                       n (count clause)]
                 (cond
                  (= 0 n) `(throw (IllegalArgumentException. (str &quot;No matching clause: &quot; ~expr)))
                  (= 1 n) a
                  (= 2 n) `(if (~pred ~a ~expr)
                             ~b
                             ~(emit pred expr more))
                  :else `(if-let [p# (~pred ~a ~expr)]
                           (~c p#)
                           ~(emit pred expr more)))))
        gres (gensym &quot;res__&quot;)]
    `(let [~gpred ~pred
           ~gexpr ~expr]
       ~(emit gpred gexpr clauses))))</pre></td></tr><tr><td class="docs"><p>var documentation ;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-meta! #'*agent* assoc :added &quot;1.0&quot;)
(alter-meta! #'in-ns assoc :added &quot;1.0&quot;)
(alter-meta! #'load-file assoc :added &quot;1.0&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro add-doc-and-meta {:private true} [name docstring meta]
  `(alter-meta! (var ~name) merge (assoc ~meta :doc ~docstring)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *file*
  &quot;The path of the file being evaluated, as a String.

  Evaluates to nil when there is no file, eg. in the REPL.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *command-line-args*
  &quot;A sequence of the supplied command line arguments, or nil if
  none were supplied&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *warn-on-reflection*
  &quot;When set to true, the compiler will emit warnings when reflection is
  needed to resolve Java method calls or field accesses.

  Defaults to false.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *compile-path*
  &quot;Specifies the directory where 'compile' will write out .class
  files. This directory must be in the classpath for 'compile' to
  work.

  Defaults to \&quot;classes\&quot;&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *compile-files*
  &quot;Set to true when compiling files, false otherwise.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *unchecked-math*
  &quot;While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. Default: false.&quot;
  {:added &quot;1.3&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *compiler-options*
  &quot;A map of keys to options.
  Note, when binding dynamically make sure to merge with previous value.
  Supported options:
  :elide-meta - a collection of metadata keys to elide during compilation.
  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger
  Alpha, subject to change.&quot;
  {:added &quot;1.4&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *ns*
  &quot;A clojure.lang.Namespace object representing the current namespace.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *in*
  &quot;A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *out*
  &quot;A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *err*
  &quot;A java.io.Writer object representing standard error for print operations.

  Defaults to System/err, wrapped in a PrintWriter&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *flush-on-newline*
  &quot;When set to true, output will be flushed whenever a newline is printed.

  Defaults to true.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *print-meta*
  &quot;If set to logical true, when printing an object, its metadata will also
  be printed in a form that can be read back by the reader.

  Defaults to false.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *print-dup*
  &quot;When set to logical true, objects will be printed in a way that preserves
  their type when read in later.

  Defaults to false.&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *print-readably*
  &quot;When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *read-eval*
  &quot;When set to logical false, the EvalReader (#=(...)) is disabled in the 
  read/load in the thread-local binding.
  Example: (binding [*read-eval* false] (read-string \&quot;#=(eval (def x 3))\&quot;))

  Defaults to true&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs"><p>Returns true if x is a future</p>
</td><td class="codes"><pre class="brush: clojure">(defn future?
  {:added &quot;1.1&quot;
   :static true}
  [x] (instance? java.util.concurrent.Future x))</pre></td></tr><tr><td class="docs"><p>Returns true if future f is done</p>
</td><td class="codes"><pre class="brush: clojure">(defn future-done?
  {:added &quot;1.1&quot;
   :static true}
  [^java.util.concurrent.Future f] (.isDone f))</pre></td></tr><tr><td class="docs"><p>fnspec ==> (fname [params<em>] exprs) or (fname ([params</em>] exprs)+)</p>

<p>  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro letfn 
  {:added &quot;1.0&quot;, :forms '[(letfn [fnspecs*] exprs*)],
   :special-form true, :url nil}
  [fnspecs &amp; body] 
  `(letfn* ~(vec (interleave (map first fnspecs) 
                             (map #(cons `fn %) fnspecs)))
           ~@body))</pre></td></tr><tr><td class="docs"><p>Takes a function f, and returns a function that calls f, replacing
  a nil first argument to f with the supplied value x. Higher arity
  versions can replace arguments in the second and third
  positions (y, z). Note that the function f can take any number of
  arguments, not just the one(s) being nil-patched.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fnil
  {:added &quot;1.2&quot;
   :static true}
  ([f x]
   (fn
     ([a] (f (if (nil? a) x a)))
     ([a b] (f (if (nil? a) x a) b))
     ([a b c] (f (if (nil? a) x a) b c))
     ([a b c &amp; ds] (apply f (if (nil? a) x a) b c ds))))
  ([f x y]
   (fn
     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))
     ([a b c &amp; ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))
  ([f x y z]
   (fn
     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))
     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))
     ([a b c &amp; ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))</pre></td></tr><tr><td class="docs"><p>case ;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn- shift-mask [shift mask x]
  (-&gt; x (bit-shift-right shift) (bit-and mask)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private max-mask-bits 13)
(def ^:private max-switch-table-size (bit-shift-left 1 max-mask-bits))</pre></td></tr><tr><td class="docs"><p>takes a collection of hashes and returns [shift mask] or nil if none found</p>
</td><td class="codes"><pre class="brush: clojure">(defn- maybe-min-hash
  [hashes]
  (first
    (filter (fn [[s m]]
              (apply distinct? (map #(shift-mask s m %) hashes)))
            (for [mask (map #(dec (bit-shift-left 1 %)) (range 1 (inc max-mask-bits)))
                  shift (range 0 31)]
              [shift mask]))))</pre></td></tr><tr><td class="docs"><p>Transforms a sequence of test constants and a corresponding sequence of then
  expressions into a sorted map to be consumed by case*. The form of the map
  entries are {(case-f test) [(test-f test) then]}.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- case-map
  [case-f test-f tests thens]
  (into1 (sorted-map)
    (zipmap (map case-f tests)
            (map vector
              (map test-f tests)
              thens))))</pre></td></tr><tr><td class="docs"><p>Returns true if the collection of ints can fit within the
  max-table-switch-size, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fits-table?
  [ints]
  (&lt; (- (apply max (seq ints)) (apply min (seq ints))) max-switch-table-size))</pre></td></tr><tr><td class="docs"><p>Takes a sequence of int-sized test constants and a corresponding sequence of
  then expressions. Returns a tuple of [shift mask case-map switch-type] where
  case-map is a map of int case values to [test then] tuples, and switch-type
  is either :sparse or :compact.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- prep-ints
  [tests thens]
  (if (fits-table? tests)
    ; compact case ints, no shift-mask
    [0 0 (case-map int int tests thens) :compact]
    (let [[shift mask] (or (maybe-min-hash (map int tests)) [0 0])]
      (if (zero? mask)
        ; sparse case ints, no shift-mask
        [0 0 (case-map int int tests thens) :sparse]
        ; compact case ints, with shift-mask
        [shift mask (case-map #(shift-mask shift mask (int %)) int tests thens) :compact]))))</pre></td></tr><tr><td class="docs"><p>Takes a case expression, default expression, and a sequence of test constants
  and a corresponding sequence of then expressions. Returns a tuple of
  [tests thens skip-check-set] where no tests have the same hash. Each set of
  input test constants with the same hash is replaced with a single test
  constant (the case int), and their respective thens are combined into:
  (condp = expr
    test-1 then-1
    ...
    test-n then-n
    default).
  The skip-check is a set of case ints for which post-switch equivalence
  checking must not be done (the cases holding the above condp thens).</p>
</td><td class="codes"><pre class="brush: clojure">(defn- merge-hash-collisions
  [expr-sym default tests thens]
  (let [buckets (loop [m {} ks tests vs thens]
                  (if (and ks vs)
                    (recur
                      (update-in m [(hash (first ks))] (fnil conj []) [(first ks) (first vs)])
                      (next ks) (next vs))
                    m))
        assoc-multi (fn [m h bucket]
                      (let [testexprs (apply concat bucket)
                            expr `(condp = ~expr-sym ~@testexprs ~default)]
                        (assoc m h expr)))
        hmap (reduce1
               (fn [m [h bucket]]
                 (if (== 1 (count bucket))
                   (assoc m (ffirst bucket) (second (first bucket)))
                   (assoc-multi m h bucket)))
               {} buckets)
        skip-check (-&gt;&gt; buckets
                     (filter #(&lt; 1 (count (second %))))
                     (map first)
                     (into1 #{}))]
    [(keys hmap) (vals hmap) skip-check]))</pre></td></tr><tr><td class="docs"><p>Takes a sequence of test constants and a corresponding sequence of then
  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]
  where case-map is a map of int case values to [test then] tuples, switch-type
  is either :sparse or :compact, and skip-check is a set of case ints for which
  post-switch equivalence checking must not be done (occurs with hash
  collisions).</p>
</td><td class="codes"><pre class="brush: clojure">(defn- prep-hashes
  [expr-sym default tests thens]
  (let [hashes (into1 #{} (map hash tests))]
    (if (== (count tests) (count hashes))
      (if (fits-table? hashes)
        ; compact case ints, no shift-mask
        [0 0 (case-map hash identity tests thens) :compact]
        (let [[shift mask] (or (maybe-min-hash hashes) [0 0])]
          (if (zero? mask)
            ; sparse case ints, no shift-mask
            [0 0 (case-map hash identity tests thens) :sparse]
            ; compact case ints, with shift-mask
            [shift mask (case-map #(shift-mask shift mask (hash %)) identity tests thens) :compact])))
      ; resolve hash collisions and try again
      (let [[tests thens skip-check] (merge-hash-collisions expr-sym default tests thens)
            [shift mask case-map switch-type] (prep-hashes expr-sym default tests thens)
            skip-check (if (zero? mask)
                         skip-check
                         (into1 #{} (map #(shift-mask shift mask %) skip-check)))]
        [shift mask case-map switch-type skip-check]))))</pre></td></tr><tr><td class="docs"><p>Takes an expression, and a set of clauses.</p>

<p>  Each clause can take the form of either:</p>

<p>  test-constant result-expr</p>

<p>  (test-constant1 ... test-constantN)  result-expr</p>

<p>  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.</p>

<p>  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro case 
  {:added &quot;1.2&quot;}
  [e &amp; clauses]
  (let [ge (with-meta (gensym) {:tag Object})
        default (if (odd? (count clauses)) 
                  (last clauses)
                  `(throw (IllegalArgumentException. (str &quot;No matching clause: &quot; ~ge))))]
    (if (&gt; 2 (count clauses))
      `(let [~ge ~e] ~default)
      (let [pairs (partition 2 clauses)
            assoc-test (fn assoc-test [m test expr]
                         (if (contains? m test)
                           (throw (IllegalArgumentException. (str &quot;Duplicate case test constant: &quot; test)))
                           (assoc m test expr)))
            pairs (reduce1
                       (fn [m [test expr]]
                         (if (seq? test)
                           (reduce1 #(assoc-test %1 %2 expr) m test)
                           (assoc-test m test expr)))
                       {} pairs)
            tests (keys pairs)
            thens (vals pairs)
            mode (cond
                   (every? #(and (integer? %) (&lt;= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)
                   :ints
                   (every? keyword? tests)
                   :identity
                   :else :hashes)]
        (condp = mode
          :ints
          (let [[shift mask imap switch-type] (prep-ints tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))
          :hashes
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))
          :identity
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))</pre></td></tr><tr><td class="docs"><p>Wraps x in a way such that a reduce will terminate with the value x</p>

<p>redefine reduce with internal-reduce</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduced
  {:added &quot;1.5&quot;}
  [x]
  (clojure.lang.Reduced. x))</pre></td></tr><tr><td class="docs"><p>Returns true if x is the result of a call to reduced</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduced?
  {:inline (fn [x] `(clojure.lang.RT/isReduced ~x ))
   :inline-arities #{1}
   :added &quot;1.5&quot;}
  ([x] (clojure.lang.RT/isReduced x)))</pre></td></tr><tr><td class="docs"><p>helper files ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(alter-meta! (find-ns 'clojure.core) assoc :doc &quot;Fundamental library of the Clojure language&quot;)
(load &quot;core_proxy&quot;)
(load &quot;core_print&quot;)
(load &quot;genclass&quot;)
(load &quot;core_deftype&quot;)
(load &quot;core/protocols&quot;)
(load &quot;gvec&quot;)
(load &quot;instant&quot;)
(load &quot;uuid&quot;)</pre></td></tr><tr><td class="docs"><p>f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduce
  {:added &quot;1.0&quot;}
  ([f coll]
     (clojure.core.protocols/coll-reduce coll f))
  ([f val coll]
     (clojure.core.protocols/coll-reduce coll f val)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol clojure.core.protocols/IKVReduce
 ;;slow path default
 clojure.lang.IPersistentMap
 (kv-reduce 
  [amap f init]
  (reduce (fn [ret [k v]] (f ret k v)) init amap))

 clojure.lang.PersistentHashMap
 (kv-reduce 
  [amap f init]
  (.kvreduce amap f init))

 clojure.lang.PersistentArrayMap
 (kv-reduce 
  [amap f init]
  (.kvreduce amap f init))

 clojure.lang.PersistentTreeMap
 (kv-reduce 
  [amap f init]
  (.kvreduce amap f init))

 clojure.lang.PersistentVector
 (kv-reduce 
  [vec f init]
  (.kvreduce vec f init)))</pre></td></tr><tr><td class="docs"><p>Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduce-kv
  {:added &quot;1.4&quot;}
  ([f init coll]
     (clojure.core.protocols/kv-reduce coll f init)))</pre></td></tr><tr><td class="docs"><p>Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined.</p>
</td><td class="codes"><pre class="brush: clojure">(defn into
  {:added &quot;1.0&quot;
   :static true}
  [to from]
  (if (instance? clojure.lang.IEditableCollection to)
    (persistent! (reduce conj! (transient to) from))
    (reduce conj to from)))</pre></td></tr><tr><td class="docs"><p>Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mapv
  {:added &quot;1.4&quot;
   :static true}
  ([f coll]
     (-&gt; (reduce (fn [v o] (conj! v (f o))) (transient []) coll)
         persistent!))
  ([f c1 c2]
     (into [] (map f c1 c2)))
  ([f c1 c2 c3]
     (into [] (map f c1 c2 c3)))
  ([f c1 c2 c3 &amp; colls]
     (into [] (apply map f c1 c2 c3 colls))))</pre></td></tr><tr><td class="docs"><p>Returns a vector of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn filterv
  {:added &quot;1.4&quot;
   :static true}
  [pred coll]
  (-&gt; (reduce (fn [v o] (if (pred o) (conj! v o) v))
              (transient [])
              coll)
      persistent!))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require '[clojure.java.io :as jio])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- normalize-slurp-opts
  [opts]
  (if (string? (first opts))
    (do
      (println &quot;WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc).&quot;)
      [:encoding (first opts)])
    opts))</pre></td></tr><tr><td class="docs"><p>Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn slurp
  {:added &quot;1.0&quot;}
  ([f &amp; opts]
     (let [opts (normalize-slurp-opts opts)
           sb (StringBuilder.)]
       (with-open [#^java.io.Reader r (apply jio/reader f opts)]
         (loop [c (.read r)]
           (if (neg? c)
             (str sb)
             (do
               (.append sb (char c))
               (recur (.read r)))))))))</pre></td></tr><tr><td class="docs"><p>Opposite of slurp.  Opens f with writer, writes content, then
  closes f. Options passed to clojure.java.io/writer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn spit
  {:added &quot;1.2&quot;}
  [f content &amp; options]
  (with-open [#^java.io.Writer w (apply jio/writer f options)]
    (.write w (str content))))</pre></td></tr><tr><td class="docs"><p>Takes a function of no args and yields a future object that will
  invoke the function in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant
  of deref with timeout is used. See also - realized?.</p>

<p>futures (needs proxy);;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn future-call 
  {:added &quot;1.1&quot;
   :static true}
  [f]
  (let [f (binding-conveyor-fn f)
        fut (.submit clojure.lang.Agent/soloExecutor ^Callable f)]
    (reify 
     clojure.lang.IDeref 
     (deref [_] (.get fut))
     clojure.lang.IBlockingDeref
     (deref
      [_ timeout-ms timeout-val]
      (try (.get fut timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)
           (catch java.util.concurrent.TimeoutException e
             timeout-val)))
     clojure.lang.IPending
     (isRealized [_] (.isDone fut))
     java.util.concurrent.Future
      (get [_] (.get fut))
      (get [_ timeout unit] (.get fut timeout unit))
      (isCancelled [_] (.isCancelled fut))
      (isDone [_] (.isDone fut))
      (cancel [_ interrupt?] (.cancel fut interrupt?)))))</pre></td></tr><tr><td class="docs"><p>Takes a body of expressions and yields a future object that will
  invoke the body in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant of
  deref with timeout is used. See also - realized?.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro future
  {:added &quot;1.1&quot;}
  [&amp; body] `(future-call (^{:once true} fn* [] ~@body)))</pre></td></tr><tr><td class="docs"><p>Cancels the future, if possible.</p>
</td><td class="codes"><pre class="brush: clojure">(defn future-cancel
  {:added &quot;1.1&quot;
   :static true}
  [^java.util.concurrent.Future f] (.cancel f true))</pre></td></tr><tr><td class="docs"><p>Returns true if future f is cancelled</p>
</td><td class="codes"><pre class="brush: clojure">(defn future-cancelled?
  {:added &quot;1.1&quot;
   :static true}
  [^java.util.concurrent.Future f] (.isCancelled f))</pre></td></tr><tr><td class="docs"><p>Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn't
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pmap
  {:added &quot;1.0&quot;
   :static true}
  ([f coll]
   (let [n (+ 2 (.. Runtime getRuntime availableProcessors))
         rets (map #(future (f %)) coll)
         step (fn step [[x &amp; xs :as vs] fs]
                (lazy-seq
                 (if-let [s (seq fs)]
                   (cons (deref x) (step xs (rest s)))
                   (map deref vs))))]
     (step rets (drop n rets))))
  ([f coll &amp; colls]
   (let [step (fn step [cs]
                (lazy-seq
                 (let [ss (map seq cs)]
                   (when (every? identity ss)
                     (cons (map first ss) (step (map rest ss)))))))]
     (pmap #(apply f %) (step (cons coll colls))))))</pre></td></tr><tr><td class="docs"><p>Executes the no-arg fns in parallel, returning a lazy sequence of
  their values</p>
</td><td class="codes"><pre class="brush: clojure">(defn pcalls
  {:added &quot;1.0&quot;
   :static true}
  [&amp; fns] (pmap #(%) fns))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the values of the exprs, which are
  evaluated in parallel</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro pvalues
  {:added &quot;1.0&quot;
   :static true}
  [&amp; exprs]
  `(pcalls ~@(map #(list `fn [] %) exprs)))</pre></td></tr><tr><td class="docs"><p>clojure version number ;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(let [properties (with-open [version-stream (.getResourceAsStream
                                             (clojure.lang.RT/baseLoader)
                                             &quot;clojure/version.properties&quot;)]
                   (doto (new java.util.Properties)
                     (.load version-stream)))
      version-string (.getProperty properties &quot;version&quot;)
      [_ major minor incremental qualifier snapshot]
      (re-matches
       #&quot;(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9_]+))?(?:-(SNAPSHOT))?&quot;
       version-string)
      clojure-version {:major       (Integer/valueOf ^String major)
                       :minor       (Integer/valueOf ^String minor)
                       :incremental (Integer/valueOf ^String incremental)
                       :qualifier   (if (= qualifier &quot;SNAPSHOT&quot;) nil qualifier)}]
  (def ^:dynamic *clojure-version*
    (if (.contains version-string &quot;SNAPSHOT&quot;)
      (clojure.lang.RT/assoc clojure-version :interim true)
      clojure-version)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-doc-and-meta *clojure-version*
  &quot;The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include \&quot;GA\&quot;, \&quot;SNAPSHOT\&quot;, \&quot;RC-x\&quot; \&quot;BETA-x\&quot;&quot;
  {:added &quot;1.0&quot;})</pre></td></tr><tr><td class="docs"><p>Returns clojure version as a printable string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn
  clojure-version 
  {:added &quot;1.0&quot;}
  []
  (str (:major *clojure-version*)
       &quot;.&quot;
       (:minor *clojure-version*)
       (when-let [i (:incremental *clojure-version*)]
         (str &quot;.&quot; i))
       (when-let [q (:qualifier *clojure-version*)]
         (when (pos? (count q)) (str &quot;-&quot; q)))
       (when (:interim *clojure-version*)
         &quot;-SNAPSHOT&quot;)))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?.</p>
</td><td class="codes"><pre class="brush: clojure">(defn promise
  {:added &quot;1.1&quot;
   :static true}
  []
  (let [d (java.util.concurrent.CountDownLatch. 1)
        v (atom d)]
    (reify 
     clojure.lang.IDeref
       (deref [_] (.await d) @v)
     clojure.lang.IBlockingDeref
       (deref
        [_ timeout-ms timeout-val]
        (if (.await d timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)
          @v
          timeout-val))  
     clojure.lang.IPending
      (isRealized [this]
       (zero? (.getCount d)))
     clojure.lang.IFn
     (invoke
      [this x]
      (when (and (pos? (.getCount d))
                 (compare-and-set! v d x))
        (.countDown d)
        this)))))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
  Delivers the supplied value to the promise, releasing any pending
  derefs. A subsequent call to deliver on a promise will throw an exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deliver
  {:added &quot;1.1&quot;
   :static true}
  [promise val] (promise val))</pre></td></tr><tr><td class="docs"><p>Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn flatten
  {:added &quot;1.2&quot;
   :static true}
  [x]
  (filter (complement sequential?)
          (rest (tree-seq sequential? seq x))))</pre></td></tr><tr><td class="docs"><p>Returns a map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-by 
  {:added &quot;1.2&quot;
   :static true}
  [f coll]  
  (persistent!
   (reduce
    (fn [ret x]
      (let [k (f x)]
        (assoc! ret k (conj (get ret k []) x))))
    (transient {}) coll)))</pre></td></tr><tr><td class="docs"><p>Applies f to each value in coll, splitting it each time f returns
   a new value.  Returns a lazy seq of partitions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partition-by
  {:added &quot;1.2&quot;
   :static true}
  [f coll]
  (lazy-seq
   (when-let [s (seq coll)]
     (let [fst (first s)
           fv (f fst)
           run (cons fst (take-while #(= fv (f %)) (next s)))]
       (cons run (partition-by f (seq (drop (count run) s))))))))</pre></td></tr><tr><td class="docs"><p>Returns a map from distinct items in coll to the number of times
  they appear.</p>
</td><td class="codes"><pre class="brush: clojure">(defn frequencies
  {:added &quot;1.2&quot;
   :static true}
  [coll]
  (persistent!
   (reduce (fn [counts x]
             (assoc! counts x (inc (get counts x 0))))
           (transient {}) coll)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reductions
  {:added &quot;1.2&quot;}
  ([f coll]
     (lazy-seq
      (if-let [s (seq coll)]
        (reductions f (first s) (rest s))
        (list (f)))))
  ([f init coll]
     (cons init
           (lazy-seq
            (when-let [s (seq coll)]
              (reductions f (f init (first s)) (rest s)))))))</pre></td></tr><tr><td class="docs"><p>Return a random element of the (sequential) collection. Will have
  the same performance characteristics as nth for the given
  collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn rand-nth
  {:added &quot;1.2&quot;
   :static true}
  [coll]
  (nth coll (rand-int (count coll))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.</p>
</td><td class="codes"><pre class="brush: clojure">(defn partition-all
  {:added &quot;1.2&quot;
   :static true}
  ([n coll]
     (partition-all n n coll))
  ([n step coll]
     (lazy-seq
      (when-let [s (seq coll)]
        (let [seg (doall (take n s))]
          (cons seg (partition-all n step (nthrest s step))))))))</pre></td></tr><tr><td class="docs"><p>Return a random permutation of coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn shuffle
  {:added &quot;1.2&quot;
   :static true}
  [^java.util.Collection coll]
  (let [al (java.util.ArrayList. coll)]
    (java.util.Collections/shuffle al)
    (clojure.lang.RT/vector (.toArray al))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence consisting of the result of applying f to 0
  and the first item of coll, followed by applying f to 1 and the second
  item in coll, etc, until coll is exhausted. Thus function f should
  accept 2 arguments, index and item.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-indexed
  {:added &quot;1.2&quot;
   :static true}
  [f coll]
  (letfn [(mapi [idx coll]
            (lazy-seq
             (when-let [s (seq coll)]
               (if (chunked-seq? s)
                 (let [c (chunk-first s)
                       size (int (count c))
                       b (chunk-buffer size)]
                   (dotimes [i size]
                     (chunk-append b (f (+ idx i) (.nth c i))))
                   (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))
                 (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]
    (mapi 0 coll)))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keep
  {:added &quot;1.2&quot;
   :static true}
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      (if (chunked-seq? s)
        (let [c (chunk-first s)
              size (count c)
              b (chunk-buffer size)]
          (dotimes [i size]
            (let [x (f (.nth c i))]
              (when-not (nil? x)
                (chunk-append b x))))
          (chunk-cons (chunk b) (keep f (chunk-rest s))))
        (let [x (f (first s))]
          (if (nil? x)
            (keep f (rest s))
            (cons x (keep f (rest s))))))))))</pre></td></tr><tr><td class="docs"><p>Returns a lazy sequence of the non-nil results of (f index item). Note,
  this means false return values will be included.  f must be free of
  side-effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keep-indexed
  {:added &quot;1.2&quot;
   :static true}
  ([f coll]
     (letfn [(keepi [idx coll]
               (lazy-seq
                (when-let [s (seq coll)]
                  (if (chunked-seq? s)
                    (let [c (chunk-first s)
                          size (count c)
                          b (chunk-buffer size)]
                      (dotimes [i size]
                        (let [x (f (+ idx i) (.nth c i))]
                          (when-not (nil? x)
                            (chunk-append b x))))
                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))
                    (let [x (f idx (first s))]
                      (if (nil? x)
                        (keepi (inc idx) (rest s))
                        (cons x (keepi (inc idx) (rest s)))))))))]
       (keepi 0 coll))))</pre></td></tr><tr><td class="docs"><p>Takes a set of predicates and returns a function f that returns true if all of its
  composing predicates return a logical true value against all of its arguments, else it returns
  false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical false result against the original predicates.</p>
</td><td class="codes"><pre class="brush: clojure">(defn every-pred
  {:added &quot;1.3&quot;}
  ([p]
     (fn ep1
       ([] true)
       ([x] (boolean (p x)))
       ([x y] (boolean (and (p x) (p y))))
       ([x y z] (boolean (and (p x) (p y) (p z))))
       ([x y z &amp; args] (boolean (and (ep1 x y z)
                                     (every? p args))))))
  ([p1 p2]
     (fn ep2
       ([] true)
       ([x] (boolean (and (p1 x) (p2 x))))
       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))
       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))
       ([x y z &amp; args] (boolean (and (ep2 x y z)
                                     (every? #(and (p1 %) (p2 %)) args))))))
  ([p1 p2 p3]
     (fn ep3
       ([] true)
       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))
       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))
       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))
       ([x y z &amp; args] (boolean (and (ep3 x y z)
                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))
  ([p1 p2 p3 &amp; ps]
     (let [ps (list* p1 p2 p3 ps)]
       (fn epn
         ([] true)
         ([x] (every? #(% x) ps))
         ([x y] (every? #(and (% x) (% y)) ps))
         ([x y z] (every? #(and (% x) (% y) (% z)) ps))
         ([x y z &amp; args] (boolean (and (epn x y z)
                                       (every? #(every? % args) ps))))))))</pre></td></tr><tr><td class="docs"><p>Takes a set of predicates and returns a function f that returns the first logical true value
  returned by one of its composing predicates against any of its arguments, else it returns
  logical false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical true result against the original predicates.</p>
</td><td class="codes"><pre class="brush: clojure">(defn some-fn
  {:added &quot;1.3&quot;}
  ([p]
     (fn sp1
       ([] nil)
       ([x] (p x))
       ([x y] (or (p x) (p y)))
       ([x y z] (or (p x) (p y) (p z)))
       ([x y z &amp; args] (or (sp1 x y z)
                           (some p args)))))
  ([p1 p2]
     (fn sp2
       ([] nil)
       ([x] (or (p1 x) (p2 x)))
       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))
       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))
       ([x y z &amp; args] (or (sp2 x y z)
                           (some #(or (p1 %) (p2 %)) args)))))
  ([p1 p2 p3]
     (fn sp3
       ([] nil)
       ([x] (or (p1 x) (p2 x) (p3 x)))
       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))
       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))
       ([x y z &amp; args] (or (sp3 x y z)
                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))
  ([p1 p2 p3 &amp; ps]
     (let [ps (list* p1 p2 p3 ps)]
       (fn spn
         ([] nil)
         ([x] (some #(% x) ps))
         ([x y] (some #(or (% x) (% y)) ps))
         ([x y z] (some #(or (% x) (% y) (% z)) ps))
         ([x y z &amp; args] (or (spn x y z)
                             (some #(some % args) ps)))))))</pre></td></tr><tr><td class="docs"><p>A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ^{:dynamic true} assert-valid-fdecl
  [fdecl]
  (if-let [bad-args (seq (remove #(vector? %) (map first fdecl)))]
    (throw (IllegalArgumentException. (str &quot;Parameter declaration &quot; (first bad-args) &quot; should be a vector&quot;)))))</pre></td></tr><tr><td class="docs"><p>Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing.</p>
</td><td class="codes"><pre class="brush: clojure">(defn with-redefs-fn
  {:added &quot;1.3&quot;}
  [binding-map func]
  (let [root-bind (fn [m]
                    (doseq [[a-var a-val] m]
                      (.bindRoot ^clojure.lang.Var a-var a-val)))
        old-vals (zipmap (keys binding-map)
                         (map #(.getRawRoot ^clojure.lang.Var %) (keys binding-map)))]
    (try
      (root-bind binding-map)
      (func)
      (finally
        (root-bind old-vals)))))</pre></td></tr><tr><td class="docs"><p>binding => var-symbol temp-value-expr</p>

<p>  Temporarily redefines Vars while executing the body.  The
  temp-value-exprs will be evaluated and each resulting value will
  replace in parallel the root value of its Var.  After the body is
  executed, the root values of all the Vars will be set back to their
  old values.  These temporary changes will be visible in all threads.
  Useful for mocking out functions during testing.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-redefs
  {:added &quot;1.3&quot;}
  [bindings &amp; body]
  `(with-redefs-fn ~(zipmap (map #(list `var %) (take-nth 2 bindings))
                            (take-nth 2 (next bindings)))
                    (fn [] ~@body)))</pre></td></tr><tr><td class="docs"><p>Returns true if a value has been produced for a promise, delay, future or lazy sequence.</p>
</td><td class="codes"><pre class="brush: clojure">(defn realized?
  {:added &quot;1.3&quot;}
  [^clojure.lang.IPending x] (.isRealized x))</pre></td></tr><tr><td class="docs"><p>data readers ;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Default map of data reader functions provided by Clojure. May be
  overridden by binding <em>data-readers</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:added &quot;1.4&quot;} default-data-readers
  {'inst #'clojure.instant/read-instant-date
   'uuid #'clojure.uuid/default-uuid-reader})</pre></td></tr><tr><td class="docs"><p>Map from reader tag symbols to data reader Vars.</p>

<p>  When Clojure starts, it searches for files named 'data_readers.clj'
  at the root of the classpath. Each such file must contain a literal
  map of symbols, like this:</p>

<pre><code>  {foo/bar my.project.foo/bar
   foo/baz my.project/baz}
</code></pre>

<p>  The first symbol in each pair is a tag that will be recognized by
  the Clojure reader. The second symbol in the pair is the
  fully-qualified name of a Var which will be invoked by the reader to
  parse the form following the tag. For example, given the
  data_readers.clj file above, the Clojure reader would parse this
  form:</p>

<pre><code>  #foo/bar [1 2 3]
</code></pre>

<p>  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The
  data reader function is invoked on the form AFTER it has been read
  as a normal Clojure data structure by the reader.</p>

<p>  Reader tags without namespace qualifiers are reserved for
  Clojure. Default reader tags are defined in
  clojure.core/default-data-readers but may be overridden in
  data_readers.clj or by rebinding this Var.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:added &quot;1.4&quot; :dynamic true} *data-readers*
  {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- data-reader-urls []
  (enumeration-seq
   (.. Thread currentThread getContextClassLoader
       (getResources &quot;data_readers.clj&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- data-reader-var [sym]
  (intern (create-ns (symbol (namespace sym)))
          (symbol (name sym))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- load-data-reader-file [mappings ^java.net.URL url]
  (with-open [rdr (clojure.lang.LineNumberingPushbackReader.
                   (java.io.InputStreamReader.
                    (.openStream url) &quot;UTF-8&quot;))]
    (binding [*file* (.getFile url)]
      (let [new-mappings (read rdr false nil)]
        (when (not (map? new-mappings))
          (throw (ex-info (str &quot;Not a valid data-reader map&quot;)
                          {:url url})))
        (reduce
         (fn [m [k v]]
           (when (not (symbol? k))
             (throw (ex-info (str &quot;Invalid form in data-reader file&quot;)
                             {:url url
                              :form k})))
           (when (contains? mappings k)
             (throw (ex-info &quot;Conflicting data-reader mapping&quot;
                             {:url url
                              :conflict k
                              :mappings m})))
           (assoc m k (data-reader-var v)))
         mappings
         new-mappings)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- load-data-readers []
  (alter-var-root #'*data-readers*
                  (fn [mappings]
                    (reduce load-data-reader-file
                            mappings (data-reader-urls)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(try
 (load-data-readers)
 (catch Throwable t
   (.printStackTrace t)
   (throw t)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.core.protocols" name="clojure.core.protocols"><h1 class="project-name">clojure.core.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns clojure.core.protocols)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Protocol for collection types that can implement reduce faster than
  first/next recursion. Called by clojure.core/reduce. Baseline
  implementation defined in terms of Iterable.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol CollReduce
  (coll-reduce [coll f] [coll f val]))</pre></td></tr><tr><td class="docs"><p>Protocol for concrete seq types that can reduce themselves
   faster than first/next recursion. Called by clojure.core/reduce.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol InternalReduce
  (internal-reduce [seq f start]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- seq-reduce
  ([coll f]
     (if-let [s (seq coll)]
       (internal-reduce (next s) f (first s))
       (f)))
  ([coll f val]
     (let [s (seq coll)]
       (internal-reduce s f val))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol CollReduce
  nil
  (coll-reduce
   ([coll f] (f))
   ([coll f val] val))

  Object
  (coll-reduce
   ([coll f] (seq-reduce coll f))
   ([coll f val] (seq-reduce coll f val)))

  ;;aseqs are iterable, masking internal-reducers
  clojure.lang.ASeq
  (coll-reduce
   ([coll f] (seq-reduce coll f))
   ([coll f val] (seq-reduce coll f val)))

  ;;for range
  clojure.lang.LazySeq
  (coll-reduce
   ([coll f] (seq-reduce coll f))
   ([coll f val] (seq-reduce coll f val)))

  ;;vector's chunked seq is faster than its iter
  clojure.lang.PersistentVector
  (coll-reduce
   ([coll f] (seq-reduce coll f))
   ([coll f val] (seq-reduce coll f val)))
  
  Iterable
  (coll-reduce
   ([coll f]
      (let [iter (.iterator coll)]
        (if (.hasNext iter)
          (loop [ret (.next iter)]
            (if (.hasNext iter)
              (let [ret (f ret (.next iter))]
                (if (reduced? ret)
                  @ret
                  (recur ret)))
              ret))
          (f))))
   ([coll f val]
      (let [iter (.iterator coll)]
        (loop [ret val]
          (if (.hasNext iter)
            (let [ret (f ret (.next iter))]
                (if (reduced? ret)
                  @ret
                  (recur ret)))
            ret)))))
  )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol InternalReduce
  nil
  (internal-reduce
   [s f val]
   val)
  
  ;; handles vectors and ranges
  clojure.lang.IChunkedSeq
  (internal-reduce
   [s f val]
   (if-let [s (seq s)]
     (if (chunked-seq? s)
       (let [ret (.reduce (chunk-first s) f val)]
         (if (reduced? ret)
           @ret
           (recur (chunk-next s)
                  f
                  ret)))
       (internal-reduce s f val))
     val))
 
  clojure.lang.StringSeq
  (internal-reduce
   [str-seq f val]
   (let [s (.s str-seq)]
     (loop [i (.i str-seq)
            val val]
       (if (&lt; i (.length s))
         (let [ret (f val (.charAt s i))]
                (if (reduced? ret)
                  @ret
                  (recur (inc i) ret)))
         val))))
  
  clojure.lang.ArraySeq
  (internal-reduce
       [a-seq f val]
       (let [^objects arr (.array a-seq)]
         (loop [i (.index a-seq)
                val val]
           (if (&lt; i (alength arr))
             (let [ret (f val (aget arr i))]
                (if (reduced? ret)
                  @ret
                  (recur (inc i) ret)))
             val))))
  
  java.lang.Object
  (internal-reduce
   [s f val]
   (loop [cls (class s)
          s s
          f f
          val val]
     (if-let [s (seq s)]
       ;; roll over to faster implementation if underlying seq changes type
       (if (identical? (class s) cls)
         (let [ret (f val (first s))]
                (if (reduced? ret)
                  @ret
                  (recur cls (next s) f ret)))
         (internal-reduce s f val))
       val))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def arr-impl
  '(internal-reduce
       [a-seq f val]
       (let [arr (.array a-seq)]
         (loop [i (.index a-seq)
                val val]
           (if (&lt; i (alength arr))
             (let [ret (f val (aget arr i))]
                (if (reduced? ret)
                  @ret
                  (recur (inc i) ret)))
             val)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-array-impls*
  [syms]
  (apply
   concat
   (map
    (fn [s]
      [(symbol (str &quot;clojure.lang.ArraySeq$ArraySeq_&quot; s))
       arr-impl])
    syms)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro emit-array-impls
  [&amp; syms]
  `(extend-protocol InternalReduce
     ~@(emit-array-impls* syms)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(emit-array-impls int long float double byte char boolean)</pre></td></tr><tr><td class="docs"><p>Protocol for concrete associative types that can reduce themselves
   via a function of key and val faster than first/next recursion over map
   entries. Called by clojure.core/reduce-kv, and has same
   semantics (just different arg order).</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol IKVReduce
  (kv-reduce [amap f init]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.core.reducers" name="clojure.core.reducers"><h1 class="project-name">clojure.core.reducers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A library for reduction and parallel folding. Alpha and subject
      to change.  Note that fold and its derivatives require Java 7+ or
      Java 6 + jsr166y.jar for fork/join support. See Clojure's pom.xml for the
      dependency info.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc
      :author &quot;Rich Hickey&quot;}
  clojure.core.reducers
  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten])
  (:require [clojure.walk :as walk]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alias 'core 'clojure.core)
(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>some fj stuff ;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Evaluate <code>exp</code> and if it returns logical true and doesn't error, expand to
  <code>then</code>.  Else expand to <code>else</code>.</p>

<p>  (compile-if (Class/forName "java.util.concurrent.ForkJoinTask")
    (do-cool-stuff-with-fork-join)
    (fall-back-to-executor-services))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private compile-if
  [exp then else]
  (if (try (eval exp)
           (catch Throwable _ false))
    `(do ~then)
    `(do ~else)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(compile-if
 (Class/forName &quot;java.util.concurrent.ForkJoinTask&quot;)
 ;; We're running a JDK 7+
 (do
   (def pool (delay (java.util.concurrent.ForkJoinPool.)))
   (defn fjtask [^Callable f]
     (java.util.concurrent.ForkJoinTask/adapt f))
   (defn- fjinvoke [f]
     (if (java.util.concurrent.ForkJoinTask/inForkJoinPool)
       (f)
       (.invoke ^java.util.concurrent.ForkJoinPool @pool ^java.util.concurrent.ForkJoinTask (fjtask f))))
   (defn- fjfork [task] (.fork ^java.util.concurrent.ForkJoinTask task))
   (defn- fjjoin [task] (.join ^java.util.concurrent.ForkJoinTask task)))
 ;; We're running a JDK &lt;7
 (do
   (def pool (delay (jsr166y.ForkJoinPool.)))
   (defn fjtask [^Callable f]
     (jsr166y.ForkJoinTask/adapt f))
   (defn- fjinvoke [f]
     (if (jsr166y.ForkJoinTask/inForkJoinPool)
       (f)
       (.invoke ^jsr166y.ForkJoinPool @pool ^jsr166y.ForkJoinTask (fjtask f))))
   (defn- fjfork [task] (.fork ^jsr166y.ForkJoinTask task))
   (defn- fjjoin [task] (.join ^jsr166y.ForkJoinTask task))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"></td></tr><tr><td class="docs"><p>Like core/reduce except:
     When init is not provided, (f) is used.
     Maps are reduced with reduce-kv</p>
</td><td class="codes"><pre class="brush: clojure">(defn reduce
  ([f coll] (reduce f (f) coll))
  ([f init coll]
     (if (instance? java.util.Map coll)
       (clojure.core.protocols/kv-reduce coll f init)
       (clojure.core.protocols/coll-reduce coll f init))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol CollFold
  (coll-fold [coll n combinef reducef]))</pre></td></tr><tr><td class="docs"><p>Reduces a collection using a (potentially parallel) reduce-combine
  strategy. The collection is partitioned into groups of approximately
  n (default 512), each of which is reduced with reducef (with a seed
  value obtained by calling (combinef) with no arguments). The results
  of these reductions are then reduced with combinef (default
  reducef). combinef must be associative, and, when called with no
  arguments, (combinef) must produce its identity element. These
  operations may be performed in parallel, but the results will
  preserve order.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fold
  {:added &quot;1.5&quot;}
  ([reducef coll] (fold reducef reducef coll))
  ([combinef reducef coll] (fold 512 combinef reducef coll))
  ([n combinef reducef coll]
     (coll-fold coll n combinef reducef)))</pre></td></tr><tr><td class="docs"><p>Given a reducible collection, and a transformation function xf,
  returns a reducible collection, where any supplied reducing
  fn will be transformed by xf. xf is a function of reducing fn to
  reducing fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reducer
  {:added &quot;1.5&quot;}
  ([coll xf]
     (reify
      clojure.core.protocols/CollReduce
      (coll-reduce [this f1]
                   (clojure.core.protocols/coll-reduce this f1 (f1)))
      (coll-reduce [_ f1 init]
                   (clojure.core.protocols/coll-reduce coll (xf f1) init)))))</pre></td></tr><tr><td class="docs"><p>Given a foldable collection, and a transformation function xf,
  returns a foldable collection, where any supplied reducing
  fn will be transformed by xf. xf is a function of reducing fn to
  reducing fn.</p>
</td><td class="codes"><pre class="brush: clojure">(defn folder
  {:added &quot;1.5&quot;}
  ([coll xf]
     (reify
      clojure.core.protocols/CollReduce
      (coll-reduce [_ f1]
                   (clojure.core.protocols/coll-reduce coll (xf f1) (f1)))
      (coll-reduce [_ f1 init]
                   (clojure.core.protocols/coll-reduce coll (xf f1) init))
      CollFold
      (coll-fold [_ n combinef reducef]
                 (coll-fold coll n combinef (xf reducef))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-curried
  [name doc meta args body]
  (let [cargs (vec (butlast args))]
    `(defn ~name ~doc ~meta
       (~cargs (fn [x#] (~name ~@cargs x#)))
       (~args ~@body))))</pre></td></tr><tr><td class="docs"><p>Builds another arity of the fn that returns a fn awaiting the last
  param</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private defcurried
  [name doc meta args &amp; body]
  (do-curried name doc meta args body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-rfn [f1 k fkv]
  `(fn
     ([] (~f1))
     ~(clojure.walk/postwalk
       #(if (sequential? %)
          ((if (vector? %) vec identity)
           (core/remove #{k} %))
          %)
       fkv)
     ~fkv))</pre></td></tr><tr><td class="docs"><p>Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private rfn
  [[f1 k] fkv]
  (do-rfn f1 k fkv))</pre></td></tr><tr><td class="docs"><p>Applies f to every value in the reduction of coll. Foldable.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried map
  {:added &quot;1.5&quot;}
  [f coll]
  (folder coll
   (fn [f1]
     (rfn [f1 k]
          ([ret k v]
             (f1 ret (f k v)))))))</pre></td></tr><tr><td class="docs"><p>Applies f to every value in the reduction of coll, concatenating the result
  colls of (f val). Foldable.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried mapcat
  {:added &quot;1.5&quot;}
  [f coll]
  (folder coll
   (fn [f1]
     (rfn [f1 k]
          ([ret k v]
             (reduce f1 ret (f k v)))))))</pre></td></tr><tr><td class="docs"><p>Retains values in the reduction of coll for which (pred val)
  returns logical true. Foldable.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried filter
  {:added &quot;1.5&quot;}
  [pred coll]
  (folder coll
   (fn [f1]
     (rfn [f1 k]
          ([ret k v]
             (if (pred k v)
               (f1 ret k v)
               ret))))))</pre></td></tr><tr><td class="docs"><p>Removes values in the reduction of coll for which (pred val)
  returns logical true. Foldable.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried remove
  {:added &quot;1.5&quot;}
  [pred coll]
  (filter (complement pred) coll))</pre></td></tr><tr><td class="docs"><p>Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat foldable
  collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried flatten
  {:added &quot;1.5&quot;}
  [coll]
  (folder coll
   (fn [f1]
     (fn
       ([] (f1))
       ([ret v]
          (if (sequential? v)
            (clojure.core.protocols/coll-reduce (flatten v) f1 ret)
            (f1 ret v)))))))</pre></td></tr><tr><td class="docs"><p>Ends the reduction of coll when (pred val) returns logical false.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried take-while
  {:added &quot;1.5&quot;}
  [pred coll]
  (reducer coll
   (fn [f1]
     (rfn [f1 k]
          ([ret k v]
             (if (pred k v)
               (f1 ret k v)
               (reduced ret)))))))</pre></td></tr><tr><td class="docs"><p>Ends the reduction of coll after consuming n values.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried take
  {:added &quot;1.5&quot;}
  [n coll]
  (reducer coll
   (fn [f1]
     (let [cnt (atom n)]
       (rfn [f1 k]
         ([ret k v]
            (swap! cnt dec)
            (if (neg? @cnt)
              (reduced ret)
              (f1 ret k v))))))))</pre></td></tr><tr><td class="docs"><p>Elides the first n values from the reduction of coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defcurried drop
  {:added &quot;1.5&quot;}
  [n coll]
  (reducer coll
   (fn [f1]
     (let [cnt (atom n)]
       (rfn [f1 k]
         ([ret k v]
            (swap! cnt dec)
            (if (neg? @cnt)
              (f1 ret k v)
              ret)))))))</pre></td></tr><tr><td class="docs"><p>do not construct this directly, use cat</p>
</td><td class="codes"><pre class="brush: clojure">(deftype Cat [cnt left right]
  clojure.lang.Counted
  (count [_] cnt)
  clojure.lang.Seqable
  (seq [_] (concat (seq left) (seq right)))
  clojure.core.protocols/CollReduce
  (coll-reduce [this f1] (clojure.core.protocols/coll-reduce this f1 (f1)))
  (coll-reduce
   [_  f1 init]
   (clojure.core.protocols/coll-reduce
    right f1
    (clojure.core.protocols/coll-reduce left f1 init)))
  CollFold
  (coll-fold
   [_ n combinef reducef]
   (fjinvoke
    (fn []
      (let [rt (fjfork (fjtask #(coll-fold right n combinef reducef)))]
        (combinef
         (coll-fold left n combinef reducef)
         (fjjoin rt)))))))</pre></td></tr><tr><td class="docs"><p>A high-performance combining fn that yields the catenation of the
  reduced values. The result is reducible, foldable, seqable and
  counted, providing the identity collections are reducible, seqable
  and counted. The single argument version will build a combining fn
  with the supplied identity constructor. Tests for identity
  with (zero? (count x)). See also foldcat.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cat
  {:added &quot;1.5&quot;}
  ([] (java.util.ArrayList.))
  ([ctor]
     (fn
       ([] (ctor))
       ([left right] (cat left right))))
  ([left right]
     (cond
      (zero? (count left)) right
      (zero? (count right)) left
      :else
      (Cat. (+ (count left) (count right)) left right))))</pre></td></tr><tr><td class="docs"><p>.adds x to acc and returns acc</p>
</td><td class="codes"><pre class="brush: clojure">(defn append!
  {:added &quot;1.5&quot;}
  [^java.util.Collection acc x]
  (doto acc (.add x)))</pre></td></tr><tr><td class="docs"><p>Equivalent to (fold cat append! coll)</p>
</td><td class="codes"><pre class="brush: clojure">(defn foldcat
  {:added &quot;1.5&quot;}
  [coll]
  (fold cat append! coll))</pre></td></tr><tr><td class="docs"><p>Builds a combining fn out of the supplied operator and identity
  constructor. op must be associative and ctor called with no args
  must return an identity value for it.</p>
</td><td class="codes"><pre class="brush: clojure">(defn monoid
  {:added &quot;1.5&quot;}
  [op ctor]
  (fn m
    ([] (ctor))
    ([a b] (op a b))))</pre></td></tr><tr><td class="docs"><p>fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn- foldvec
  [v n combinef reducef]
  (cond
   (empty? v) (combinef)
   (&lt;= (count v) n) (reduce reducef (combinef) v)
   :else
   (let [split (quot (count v) 2)
         v1 (subvec v 0 split)
         v2 (subvec v split (count v))
         fc (fn [child] #(foldvec child n combinef reducef))]
     (fjinvoke
      #(let [f1 (fc v1)
             t2 (fjtask (fc v2))]
         (fjfork t2)
         (combinef (f1) (fjjoin t2)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol CollFold
 Object
 (coll-fold
  [coll n combinef reducef]
  ;;can't fold, single reduce
  (reduce reducef (combinef) coll))

 clojure.lang.IPersistentVector
 (coll-fold
  [v n combinef reducef]
  (foldvec v n combinef reducef))

 clojure.lang.PersistentHashMap
 (coll-fold
  [m n combinef reducef]
  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.core)</pre></td></tr><tr><td class="docs"><p>definterface ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Convert a Clojure namespace name to a legal Java package name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn namespace-munge
  {:added &quot;1.2&quot;}
  [ns]
  (.replace (str ns) \- \_))</pre></td></tr><tr><td class="docs"><p>for now, built on gen-interface</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro definterface 
  [name &amp; sigs]
  (let [tag (fn [x] (or (:tag (meta x)) Object))
        psig (fn [[name [&amp; args]]]
               (vector name (vec (map tag args)) (tag name) (map meta args)))
        cname (with-meta (symbol (str (namespace-munge *ns*) &quot;.&quot; name)) (meta name))]
    `(let [] 
       (gen-interface :name ~cname :methods ~(vec (map psig sigs)))
       (import ~cname))))</pre></td></tr><tr><td class="docs"><p>reify/deftype ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-opts [s]
  (loop [opts {} [k v &amp; rs :as s] s]
    (if (keyword? k)
      (recur (assoc opts k v) rs)
      [opts s])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-impls [specs]
  (loop [ret {} s specs]
    (if (seq s)
      (recur (assoc ret (first s) (take-while seq? (next s)))
             (drop-while seq? (next s)))
      ret)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-opts+specs [opts+specs]
  (let [[opts specs] (parse-opts opts+specs)
        impls (parse-impls specs)
        interfaces (-&gt; (map #(if (var? (resolve %)) 
                               (:on (deref (resolve %)))
                               %)
                            (keys impls))
                       set
                       (disj 'Object 'java.lang.Object)
                       vec)
        methods (map (fn [[name params &amp; body]]
                       (cons name (maybe-destructured params body)))
                     (apply concat (vals impls)))]
    (when-let [bad-opts (seq (remove #{:no-print} (keys opts)))]
      (throw (IllegalArgumentException. (apply print-str &quot;Unsupported option(s) -&quot; bad-opts))))
    [interfaces methods opts]))</pre></td></tr><tr><td class="docs"><p>reify is a macro with the following structure:</p>

<p> (reify options* specs*)</p>

<p>  Currently there are no options.</p>

<p>  Each spec consists of the protocol or interface name followed by zero
  or more method bodies:</p>

<p>  protocol-or-interface-or-Object
  (methodName [args+] body)*</p>

<p>  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that the first parameter must be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations.  Note also that recur calls to the method
  head should <em>not</em> pass the target object, it will be supplied
  automatically and can not be substituted.</p>

<p>  The return type can be indicated by a type hint on the method name,
  and arg types can be indicated by a type hint on arg names. If you
  leave out all hints, reify will try to match on same name/arity
  method in the protocol(s)/interface(s) - this is preferred. If you
  supply any hints at all, no inference is done, so all hints (or
  default of Object) must be correct, for both arguments and return
  type. If a method is overloaded in a protocol/interface, multiple
  independent method definitions must be supplied.  If overloaded with
  same arity in an interface you must specify complete hints to
  disambiguate - a missing hint implies Object.</p>

<p>  recur works to method heads The method bodies of reify are lexical
  closures, and can refer to the surrounding local scope:</p>

<p>  (str (let [f "foo"] 
       (reify Object 
         (toString [this] f))))
  == "foo"</p>

<p>  (seq (let [f "foo"] 
       (reify clojure.lang.Seqable 
         (seq [this] (seq f)))))
  == (\f \o \o))</p>

<p>  reify always implements clojure.lang.IObj and transfers meta
  data of the form to the created object.</p>

<p>  (meta ^{:k :v} (reify Object (toString [this] "foo")))
  == {:k :v}</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro reify 
  &quot;reify is a macro with the following structure:
 (reify options* specs*)
  Currently there are no options.
  Each spec consists of the protocol or interface name followed by zero
  or more method bodies:
  protocol-or-interface-or-Object
  (methodName [args+] body)*
  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that the first parameter must be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations.  Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.
  The return type can be indicated by a type hint on the method name,
  and arg types can be indicated by a type hint on arg names. If you
  leave out all hints, reify will try to match on same name/arity
  method in the protocol(s)/interface(s) - this is preferred. If you
  supply any hints at all, no inference is done, so all hints (or
  default of Object) must be correct, for both arguments and return
  type. If a method is overloaded in a protocol/interface, multiple
  independent method definitions must be supplied.  If overloaded with
  same arity in an interface you must specify complete hints to
  disambiguate - a missing hint implies Object.
  recur works to method heads The method bodies of reify are lexical
  closures, and can refer to the surrounding local scope:
  (str (let [f \&quot;foo\&quot;] 
       (reify Object 
         (toString [this] f))))
  == \&quot;foo\&quot;
  (seq (let [f \&quot;foo\&quot;] 
       (reify clojure.lang.Seqable 
         (seq [this] (seq f)))))
  == (\\f \\o \\o))
  reify always implements clojure.lang.IObj and transfers meta
  data of the form to the created object.
  (meta ^{:k :v} (reify Object (toString [this] \&quot;foo\&quot;)))
  == {:k :v}&quot;
  {:added &quot;1.2&quot;} 
  [&amp; opts+specs]
  (let [[interfaces methods] (parse-opts+specs opts+specs)]
    (with-meta `(reify* ~interfaces ~@methods) (meta &amp;form))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn hash-combine [x y] 
  (clojure.lang.Util/hashCombine x (clojure.lang.Util/hash y)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn munge [s]
  ((if (symbol? s) symbol str) (clojure.lang.Compiler/munge (str s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- imap-cons
  [^IPersistentMap this o]
  (cond
   (instance? java.util.Map$Entry o)
     (let [^java.util.Map$Entry pair o]
       (.assoc this (.getKey pair) (.getValue pair)))
   (instance? clojure.lang.IPersistentVector o)
     (let [^clojure.lang.IPersistentVector vec o]
       (.assoc this (.nth vec 0) (.nth vec 1)))
   :else (loop [this this
                o o]
      (if (seq o)
        (let [^java.util.Map$Entry pair (first o)]
          (recur (.assoc this (.getKey pair) (.getValue pair)) (rest o)))
        this))))</pre></td></tr><tr><td class="docs"><p>Do not use this directly - use defrecord</p>
</td><td class="codes"><pre class="brush: clojure">(defn- emit-defrecord 
  {:added &quot;1.2&quot;}
  [tagname name fields interfaces methods]
  (let [classname (with-meta (symbol (str (namespace-munge *ns*) &quot;.&quot; name)) (meta name))
        interfaces (vec interfaces)
        interface-set (set (map resolve interfaces))
        methodname-set (set (map first methods))
        hinted-fields fields
        fields (vec (map #(with-meta % nil) fields))
        base-fields fields
        fields (conj fields '__meta '__extmap)
        type-hash (hash classname)]
    (when (some #{:volatile-mutable :unsynchronized-mutable} (mapcat (comp keys meta) hinted-fields))
      (throw (IllegalArgumentException. &quot;:volatile-mutable or :unsynchronized-mutable not supported for record fields&quot;)))
    (let [gs (gensym)]
    (letfn 
     [(irecord [[i m]]
        [(conj i 'clojure.lang.IRecord)
         m])
      (eqhash [[i m]] 
        [(conj i 'clojure.lang.IHashEq)
         (conj m
               `(hasheq [this#] (bit-xor ~type-hash (.hashCode this#)))
               `(hashCode [this#] (clojure.lang.APersistentMap/mapHash this#))
               `(equals [this# ~gs] (clojure.lang.APersistentMap/mapEquals this# ~gs)))])
      (iobj [[i m]] 
            [(conj i 'clojure.lang.IObj)
             (conj m `(meta [this#] ~'__meta)
                   `(withMeta [this# ~gs] (new ~tagname ~@(replace {'__meta gs} fields))))])
      (ilookup [[i m]] 
         [(conj i 'clojure.lang.ILookup 'clojure.lang.IKeywordLookup)
          (conj m `(valAt [this# k#] (.valAt this# k# nil))
                `(valAt [this# k# else#] 
                   (case k# ~@(mapcat (fn [fld] [(keyword fld) fld]) 
                                       base-fields)
                         (get ~'__extmap k# else#)))
                `(getLookupThunk [this# k#]
                   (let [~'gclass (class this#)]              
                     (case k#
                           ~@(let [hinted-target (with-meta 'gtarget {:tag tagname})] 
                               (mapcat 
                                (fn [fld]
                                  [(keyword fld)
                                   `(reify clojure.lang.ILookupThunk
                                           (get [~'thunk ~'gtarget]
                                                (if (identical? (class ~'gtarget) ~'gclass)
                                                  (. ~hinted-target ~(symbol (str &quot;-&quot; fld)))
                                                  ~'thunk)))])
                                base-fields))
                           nil))))])
      (imap [[i m]] 
            [(conj i 'clojure.lang.IPersistentMap)
             (conj m 
                   `(count [this#] (+ ~(count base-fields) (count ~'__extmap)))
                   `(empty [this#] (throw (UnsupportedOperationException. (str &quot;Can't create empty: &quot; ~(str classname)))))
                   `(cons [this# e#] ((var imap-cons) this# e#))
                   `(equiv [this# ~gs] 
                        (boolean 
                         (or (identical? this# ~gs)
                             (when (identical? (class this#) (class ~gs))
                               (let [~gs ~(with-meta gs {:tag tagname})]
                                 (and  ~@(map (fn [fld] `(= ~fld (. ~gs ~(symbol (str &quot;-&quot; fld))))) base-fields)
                                       (= ~'__extmap (. ~gs ~'__extmap))))))))
                   `(containsKey [this# k#] (not (identical? this# (.valAt this# k# this#))))
                   `(entryAt [this# k#] (let [v# (.valAt this# k# this#)]
                                            (when-not (identical? this# v#)
                                              (clojure.lang.MapEntry. k# v#))))
                   `(seq [this#] (seq (concat [~@(map #(list `new `clojure.lang.MapEntry (keyword %) %) base-fields)] 
                                              ~'__extmap)))
                   `(iterator [this#] (clojure.lang.SeqIterator. (.seq this#)))
                   `(assoc [this# k# ~gs]
                     (condp identical? k#
                       ~@(mapcat (fn [fld]
                                   [(keyword fld) (list* `new tagname (replace {fld gs} fields))])
                                 base-fields)
                       (new ~tagname ~@(remove #{'__extmap} fields) (assoc ~'__extmap k# ~gs))))
                   `(without [this# k#] (if (contains? #{~@(map keyword base-fields)} k#)
                                            (dissoc (with-meta (into {} this#) ~'__meta) k#)
                                            (new ~tagname ~@(remove #{'__extmap} fields) 
                                                 (not-empty (dissoc ~'__extmap k#))))))])
      (ijavamap [[i m]]
                [(conj i 'java.util.Map 'java.io.Serializable)
                 (conj m
                       `(size [this#] (.count this#))
                       `(isEmpty [this#] (= 0 (.count this#)))
                       `(containsValue [this# v#] (boolean (some #{v#} (vals this#))))
                       `(get [this# k#] (.valAt this# k#))
                       `(put [this# k# v#] (throw (UnsupportedOperationException.)))
                       `(remove [this# k#] (throw (UnsupportedOperationException.)))
                       `(putAll [this# m#] (throw (UnsupportedOperationException.)))
                       `(clear [this#] (throw (UnsupportedOperationException.)))
                       `(keySet [this#] (set (keys this#)))
                       `(values [this#] (vals this#))
                       `(entrySet [this#] (set this#)))])
      ]
     (let [[i m] (-&gt; [interfaces methods] irecord eqhash iobj ilookup imap ijavamap)]
       `(deftype* ~tagname ~classname ~(conj hinted-fields '__meta '__extmap) 
          :implements ~(vec i) 
          ~@m))))))</pre></td></tr><tr><td class="docs"><p>Used to build a positional factory for a given type/record.  Because of the
  limitation of 20 arguments to Clojure functions, this factory needs to be
  constructed to deal with more arguments.  It does this by building a straight
  forward type/record ctor call in the &lt;=20 case, and a call to the same
  ctor pulling the extra args out of the &amp; overage parameter.  Finally, the
  arity is constrained to the number of expected fields and an ArityException
  will be thrown at runtime if the actual arg count does not match.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-positional-factory
  [nom classname fields]
  (let [fn-name (symbol (str '-&gt; nom))
        [field-args over] (split-at 20 fields)
        field-count (count fields)
        arg-count (count field-args)
        over-count (count over)
        docstring (str &quot;Positional factory function for class &quot; classname &quot;.&quot;)]
    `(defn ~fn-name
       ~docstring
       [~@field-args ~@(if (seq over) '[&amp; overage] [])]
       ~(if (seq over)
          `(if (= (count ~'overage) ~over-count)
             (new ~classname
                  ~@field-args
                  ~@(for [i (range 0 (count over))]
                      (list `nth 'overage i)))
             (throw (clojure.lang.ArityException. (+ ~arg-count (count ~'overage)) (name '~fn-name))))
          `(new ~classname ~@field-args)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- validate-fields
  [fields]
  (when-not (vector? fields)
    (throw (AssertionError. &quot;No fields vector given.&quot;)))
  (let [specials #{'__meta '__extmap}]
    (when (some specials fields)
      (throw (AssertionError. (str &quot;The names in &quot; specials &quot; cannot be used as field names for types or records.&quot;))))))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change</p>

<p>  (defrecord name [fields<em>]  options</em> specs*)</p>

<p>  Currently there are no options.</p>

<p>  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:</p>

<p>  protocol-or-interface-or-Object
  (methodName [args<em>] body)</em></p>

<p>  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces.</p>

<p>  The class will have the (immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directy.</p>

<p>  Method definitions take the form:</p>

<p>  (methodname [args*] body)</p>

<p>  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.</p>

<p>  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should <em>not</em> pass the target object, it will be supplied
  automatically and can not be substituted.</p>

<p>  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).</p>

<p>  The class will have implementations of several (clojure.lang)
  interfaces generated automatically: IObj (metadata support) and
  IPersistentMap, and all of their superinterfaces.</p>

<p>  In addition, defrecord will define type-and-value-based =,
  and will defined Java .hashCode and .equals consistent with the
  contract for java.util.Map.</p>

<p>  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the <em>compile-path</em> directory.</p>

<p>  Two constructors will be defined, one taking the designated fields
  followed by a metadata map (nil for none) and an extension field
  map (nil for none), and one taking only the fields (using nil for
  meta and extension fields). Note that the field names __meta
  and __extmap are currently reserved and should not be used when
  defining your own records.</p>

<p>  Given (defrecord TypeName ...), two factory functions will be
  defined: ->TypeName, taking positional parameters for the fields,
  and map->TypeName, taking a map of keywords to field values.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defrecord
  {:added &quot;1.2&quot;
   :arglists '([name [&amp; fields] &amp; opts+specs])}
  [name fields &amp; opts+specs]
  (validate-fields fields)
  (let [gname name
        [interfaces methods opts] (parse-opts+specs opts+specs)
        ns-part (namespace-munge *ns*)
        classname (symbol (str ns-part &quot;.&quot; gname))
        hinted-fields fields
        fields (vec (map #(with-meta % nil) fields))]
    `(let []
       (declare ~(symbol (str  '-&gt; gname)))
       (declare ~(symbol (str 'map-&gt; gname)))
       ~(emit-defrecord name gname (vec hinted-fields) (vec interfaces) methods)
       (import ~classname)
       ~(build-positional-factory gname classname fields)
       (defn ~(symbol (str 'map-&gt; gname))
         ~(str &quot;Factory function for class &quot; classname &quot;, taking a map of keywords to field values.&quot;)
         ([m#] (~(symbol (str classname &quot;/create&quot;)) m#)))
       ~classname)))</pre></td></tr><tr><td class="docs"><p>Do not use this directly - use deftype</p>
</td><td class="codes"><pre class="brush: clojure">(defn- emit-deftype* 
  [tagname name fields interfaces methods]
  (let [classname (with-meta (symbol (str (namespace-munge *ns*) &quot;.&quot; name)) (meta name))
        interfaces (conj interfaces 'clojure.lang.IType)]
    `(deftype* ~tagname ~classname ~fields 
       :implements ~interfaces 
       ~@methods)))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change</p>

<p>  (deftype name [fields<em>]  options</em> specs*)</p>

<p>  Currently there are no options.</p>

<p>  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:</p>

<p>  protocol-or-interface-or-Object
  (methodName [args<em>] body)</em></p>

<p>  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces. </p>

<p>  The class will have the (by default, immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directy. Fields can be qualified
  with the metadata :volatile-mutable true or :unsynchronized-mutable
  true, at which point (set! afield aval) will be supported in method
  bodies. Note well that mutable fields are extremely difficult to use
  correctly, and are present only to facilitate the building of higher
  level constructs, such as Clojure's reference types, in Clojure
  itself. They are for experts only - if the semantics and
  implications of :volatile-mutable or :unsynchronized-mutable are not
  immediately apparent to you, you should not be using them.</p>

<p>  Method definitions take the form:</p>

<p>  (methodname [args*] body)</p>

<p>  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.</p>

<p>  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should <em>not</em> pass the target object, it will be supplied
  automatically and can not be substituted.</p>

<p>  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).</p>

<p>  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the <em>compile-path</em> directory.</p>

<p>  One constructor will be defined, taking the designated fields.  Note
  that the field names <em>_meta and _</em>extmap are currently reserved and
  should not be used when defining your own types.</p>

<p>  Given (deftype TypeName ...), a factory function called ->TypeName
  will be defined, taking positional parameters for the fields</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro deftype
  {:added &quot;1.2&quot;
   :arglists '([name [&amp; fields] &amp; opts+specs])}
  [name fields &amp; opts+specs]
  (validate-fields fields)
  (let [gname name
        [interfaces methods opts] (parse-opts+specs opts+specs)
        ns-part (namespace-munge *ns*)
        classname (symbol (str ns-part &quot;.&quot; gname))
        hinted-fields fields
        fields (vec (map #(with-meta % nil) fields))
        [field-args over] (split-at 20 fields)]
    `(let []
       ~(emit-deftype* name gname (vec hinted-fields) (vec interfaces) methods)
       (import ~classname)
       ~(build-positional-factory gname classname fields)
       ~classname)))</pre></td></tr><tr><td class="docs"><p>protocols ;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- expand-method-impl-cache [^clojure.lang.MethodImplCache cache c f]
  (if (.map cache)
    (let [cs (assoc (.map cache) c (clojure.lang.MethodImplCache$Entry. c f))]
      (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs))
    (let [cs (into1 {} (remove (fn [[c e]] (nil? e)) (map vec (partition 2 (.table cache)))))
          cs (assoc cs c (clojure.lang.MethodImplCache$Entry. c f))]
      (if-let [[shift mask] (maybe-min-hash (map hash (keys cs)))]
        (let [table (make-array Object (* 2 (inc mask)))
              table (reduce1 (fn [^objects t [c e]]
                               (let [i (* 2 (int (shift-mask shift mask (hash c))))]
                                 (aset t i c)
                                 (aset t (inc i) e)
                                 t))
                             table cs)]
          (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) shift mask table))
        (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- super-chain [^Class c]
  (when c
    (cons c (super-chain (.getSuperclass c)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pref
  ([] nil)
  ([a] a) 
  ([^Class a ^Class b]
     (if (.isAssignableFrom a b) b a)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn find-protocol-impl [protocol x]
  (if (instance? (:on-interface protocol) x)
    x
    (let [c (class x)
          impl #(get (:impls protocol) %)]
      (or (impl c)
          (and c (or (first (remove nil? (map impl (butlast (super-chain c)))))
                     (when-let [t (reduce1 pref (filter impl (disj (supers c) Object)))]
                       (impl t))
                     (impl Object)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn find-protocol-method [protocol methodk x]
  (get (find-protocol-impl protocol x) methodk))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- protocol?
  [maybe-p]
  (boolean (:on-interface maybe-p)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- implements? [protocol atype]
  (and atype (.isAssignableFrom ^Class (:on-interface protocol) atype)))</pre></td></tr><tr><td class="docs"><p>Returns true if atype extends protocol</p>
</td><td class="codes"><pre class="brush: clojure">(defn extends? 
  {:added &quot;1.2&quot;}
  [protocol atype]
  (boolean (or (implements? protocol atype) 
               (get (:impls protocol) atype))))</pre></td></tr><tr><td class="docs"><p>Returns a collection of the types explicitly extending protocol</p>
</td><td class="codes"><pre class="brush: clojure">(defn extenders 
  {:added &quot;1.2&quot;}
  [protocol]
  (keys (:impls protocol)))</pre></td></tr><tr><td class="docs"><p>Returns true if x satisfies the protocol</p>
</td><td class="codes"><pre class="brush: clojure">(defn satisfies? 
  {:added &quot;1.2&quot;}
  [protocol x]
  (boolean (find-protocol-impl protocol x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -cache-protocol-fn [^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]
  (let [cache  (.__methodImplCache pf)
        f (if (.isInstance c x)
            interf 
            (find-protocol-method (.protocol cache) (.methodk cache) x))]
    (when-not f
      (throw (IllegalArgumentException. (str &quot;No implementation of method: &quot; (.methodk cache) 
                                             &quot; of protocol: &quot; (:var (.protocol cache)) 
                                             &quot; found for class: &quot; (if (nil? x) &quot;nil&quot; (.getName (class x)))))))
    (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))
    f))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-method-builder [on-interface method on-method arglists]
  (let [methodk (keyword method)
        gthis (with-meta (gensym) {:tag 'clojure.lang.AFunction})
        ginterf (gensym)]
    `(fn [cache#]
       (let [~ginterf
             (fn
               ~@(map 
                  (fn [args]
                    (let [gargs (map #(gensym (str &quot;gf__&quot; % &quot;__&quot;)) args)
                          target (first gargs)]
                      `([~@gargs]
                          (. ~(with-meta target {:tag on-interface})  ~(or on-method method) ~@(rest gargs)))))
                  arglists))
             ^clojure.lang.AFunction f#
             (fn ~gthis
               ~@(map 
                  (fn [args]
                    (let [gargs (map #(gensym (str &quot;gf__&quot; % &quot;__&quot;)) args)
                          target (first gargs)]
                      `([~@gargs]
                          (let [cache# (.__methodImplCache ~gthis)
                                f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]
                            (if f# 
                              (f# ~@gargs)
                              ((-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf) ~@gargs))))))
                  arglists))]
         (set! (.__methodImplCache f#) cache#)
         f#))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -reset-methods [protocol]
  (doseq [[^clojure.lang.Var v build] (:method-builders protocol)]
    (let [cache (clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]
      (.bindRoot v (build cache)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- assert-same-protocol [protocol-var method-syms]
  (doseq [m method-syms]
    (let [v (resolve m)
          p (:protocol (meta v))]
      (when (and v (bound? v) (not= protocol-var p))
        (binding [*out* *err*]
          (println &quot;Warning: protocol&quot; protocol-var &quot;is overwriting&quot;
                   (if p
                     (str &quot;method &quot; (.sym v) &quot; of protocol &quot; (.sym p))
                     (str &quot;function &quot; (.sym v)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-protocol [name opts+sigs]
  (let [iname (symbol (str (munge (namespace-munge *ns*)) &quot;.&quot; (munge name)))
        [opts sigs]
        (loop [opts {:on (list 'quote iname) :on-interface iname} sigs opts+sigs]
          (condp #(%1 %2) (first sigs) 
            string? (recur (assoc opts :doc (first sigs)) (next sigs))
            keyword? (recur (assoc opts (first sigs) (second sigs)) (nnext sigs))
            [opts sigs]))
        sigs (reduce1 (fn [m s]
                       (let [name-meta (meta (first s))
                             mname (with-meta (first s) nil)
                             [arglists doc]
                               (loop [as [] rs (rest s)]
                                 (if (vector? (first rs))
                                   (recur (conj as (first rs)) (next rs))
                                   [(seq as) (first rs)]))]
                         (when (some #{0} (map count arglists))
                           (throw (IllegalArgumentException. (str &quot;Protocol fn: &quot; mname &quot; must take at least one arg&quot;))))
                         (assoc m (keyword mname)
                                (merge name-meta
                                       {:name (vary-meta mname assoc :doc doc :arglists arglists)
                                        :arglists arglists
                                        :doc doc}))))
                     {} sigs)
        meths (mapcat (fn [sig]
                        (let [m (munge (:name sig))]
                          (map #(vector m (vec (repeat (dec (count %))'Object)) 'Object) 
                               (:arglists sig))))
                      (vals sigs))]
  `(do
     (defonce ~name {})
     (gen-interface :name ~iname :methods ~meths)
     (alter-meta! (var ~name) assoc :doc ~(:doc opts))
     (#'assert-same-protocol (var ~name) '~(map :name (vals sigs)))
     (alter-var-root (var ~name) merge 
                     (assoc ~opts 
                       :sigs '~sigs 
                       :var (var ~name)
                       :method-map 
                         ~(and (:on opts)
                               (apply hash-map 
                                      (mapcat 
                                       (fn [s] 
                                         [(keyword (:name s)) (keyword (or (:on s) (:name s)))])
                                       (vals sigs))))
                       :method-builders 
                        ~(apply hash-map 
                                (mapcat 
                                 (fn [s]
                                   [`(intern *ns* (with-meta '~(:name s) (merge '~s {:protocol (var ~name)})))
                                    (emit-method-builder (:on-interface opts) (:name s) (:on s) (:arglists s))])
                                 (vals sigs)))))
     (-reset-methods ~name)
     '~name)))</pre></td></tr><tr><td class="docs"><p>A protocol is a named set of named methods and their signatures:
  (defprotocol AProtocolName</p>

<pre><code>;optional doc string
"A doc string for AProtocol abstraction"
</code></pre>

<p>  ;method signatures
    (bar [this a b] "bar docs")
    (baz [this a] [this a b] [this a b c] "baz docs"))</p>

<p>  No implementations are provided. Docs can be specified for the
  protocol overall and for each method. The above yields a set of
  polymorphic functions and a protocol object. All are
  namespace-qualified by the ns enclosing the definition The resulting
  functions dispatch on the type of their first argument, which is
  required and corresponds to the implicit target object ('this' in 
  Java parlance). defprotocol is dynamic, has no special compile-time 
  effect, and defines no new types or classes. Implementations of 
  the protocol methods can be provided using extend.</p>

<p>  defprotocol will automatically generate a corresponding interface,
  with the same name as the protocol, i.e. given a protocol:
  my.ns/Protocol, an interface: my.ns.Protocol. The interface will
  have methods corresponding to the protocol functions, and the
  protocol will automatically work with instances of the interface.</p>

<p>  Note that you should not use this interface with deftype or
  reify, as they support the protocol directly:</p>

<p>  (defprotocol P 
    (foo [this]) 
    (bar-me [this] [this y]))</p>

<p>  (deftype Foo [a b c] 
   P
    (foo [this] a)
    (bar-me [this] b)
    (bar-me [this y] (+ c y)))</p>

<p>  (bar-me (Foo. 1 2 3) 42)
  => 45</p>

<p>  (foo 
    (let [x 42]
      (reify P 
        (foo [this] 17)
        (bar-me [this] x)
        (bar-me [this y] x))))
  => 17</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defprotocol 
  {:added &quot;1.2&quot;} 
  [name &amp; opts+sigs]
  (emit-protocol name opts+sigs))</pre></td></tr><tr><td class="docs"><p>Implementations of protocol methods can be provided using the extend construct:</p>

<p>  (extend AType
    AProtocol
     {:foo an-existing-fn
      :bar (fn [a b] ...)
      :baz (fn ([a]...) ([a b] ...)...)}
    BProtocol 
      {...} 
    ...)</p>

<p>  extend takes a type/class (or interface, see below), and one or more
  protocol + method map pairs. It will extend the polymorphism of the
  protocol's methods to call the supplied methods when an AType is
  provided as the first argument. </p>

<p>  Method maps are maps of the keyword-ized method names to ordinary
  fns. This facilitates easy reuse of existing fns and fn maps, for
  code reuse/mixins without derivation or composition. You can extend
  an interface to a protocol. This is primarily to facilitate interop
  with the host (e.g. Java) but opens the door to incidental multiple
  inheritance of implementation since a class can inherit from more
  than one interface, both of which extend the protocol. It is TBD how
  to specify which impl to use. You can extend a protocol on nil.</p>

<p>  If you are supplying the definitions explicitly (i.e. not reusing
  exsting functions or mixin maps), you may find it more convenient to
  use the extend-type or extend-protocol macros.</p>

<p>  Note that multiple independent extend clauses can exist for the same
  type, not all protocols need be defined in a single extend call.</p>

<p>  See also:
  extends?, satisfies?, extenders</p>
</td><td class="codes"><pre class="brush: clojure">(defn extend 
  {:added &quot;1.2&quot;} 
  [atype &amp; proto+mmaps]
  (doseq [[proto mmap] (partition 2 proto+mmaps)]
    (when-not (protocol? proto)
      (throw (IllegalArgumentException.
              (str proto &quot; is not a protocol&quot;))))
    (when (implements? proto atype)
      (throw (IllegalArgumentException. 
              (str atype &quot; already directly implements &quot; (:on-interface proto) &quot; for protocol:&quot;  
                   (:var proto)))))
    (-reset-methods (alter-var-root (:var proto) assoc-in [:impls atype] mmap))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-impl [[p fs]]
  [p (zipmap (map #(-&gt; % first keyword) fs)
             (map #(cons 'fn (drop 1 %)) fs))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-hinted-impl [c [p fs]]
  (let [hint (fn [specs]
               (let [specs (if (vector? (first specs)) 
                                        (list specs) 
                                        specs)]
                 (map (fn [[[target &amp; args] &amp; body]]
                        (cons (apply vector (vary-meta target assoc :tag c) args)
                              body))
                      specs)))]
    [p (zipmap (map #(-&gt; % first name keyword) fs)
               (map #(cons 'fn (hint (drop 1 %))) fs))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-extend-type [c specs]
  (let [impls (parse-impls specs)]
    `(extend ~c
             ~@(mapcat (partial emit-hinted-impl c) impls))))</pre></td></tr><tr><td class="docs"><p>A macro that expands into an extend call. Useful when you are
  supplying the definitions explicitly inline, extend-type
  automatically creates the maps required by extend.  Propagates the
  class as a type hint on the first argument of all fns.</p>

<p>  (extend-type MyType 
    Countable
      (cnt [c] ...)
    Foo
      (bar [x y] ...)
      (baz ([x] ...) ([x y &amp; zs] ...)))</p>

<p>  expands into:</p>

<p>  (extend MyType
   Countable
     {:cnt (fn [c] ...)}
   Foo
     {:baz (fn ([x] ...) ([x y &amp; zs] ...))
      :bar (fn [x y] ...)})</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro extend-type 
  {:added &quot;1.2&quot;} 
  [t &amp; specs]
  (emit-extend-type t specs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-extend-protocol [p specs]
  (let [impls (parse-impls specs)]
    `(do
       ~@(map (fn [[t fs]]
                `(extend-type ~t ~p ~@fs))
              impls))))</pre></td></tr><tr><td class="docs"><p>Useful when you want to provide several implementations of the same
  protocol all at once. Takes a single protocol and the implementation
  of that protocol for one or more types. Expands into calls to
  extend-type:</p>

<p>  (extend-protocol Protocol
    AType
      (foo [x] ...)
      (bar [x y] ...)
    BType
      (foo [x] ...)
      (bar [x y] ...)
    AClass
      (foo [x] ...)
      (bar [x y] ...)
    nil
      (foo [x] ...)
      (bar [x y] ...))</p>

<p>  expands into:</p>

<p>  (do
   (clojure.core/extend-type AType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type BType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type AClass Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type nil Protocol 
     (foo [x] ...) 
     (bar [x y] ...)))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro extend-protocol 
  {:added &quot;1.2&quot;}
  [p &amp; specs]
  (emit-extend-protocol p specs))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.core)</pre></td></tr><tr><td class="docs"><p>printing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import '(java.io Writer))</pre></td></tr><tr><td class="docs"><p><em>print-length</em> controls how many items of each collection the
  printer will print. If it is bound to logical false, there is no
  limit. Otherwise, it must be bound to an integer indicating the maximum
  number of items of each collection to print. If a collection contains
  more items, the printer will print items up to the limit followed by
  '...' to represent the remaining items. The root binding is nil
  indicating no limit.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *print-length* nil)</pre></td></tr><tr><td class="docs"><p><em>print-level</em> controls how many levels deep the printer will
  print nested objects. If it is bound to logical false, there is no
  limit. Otherwise, it must be bound to an integer indicating the maximum
  level to print. Each argument to print is at level 0; if an argument is a
  collection, its items are at level 1; and so on. If an object is a
  collection and is at a level greater than or equal to the value bound to
  <em>print-level</em>, the printer prints '#' to represent it. The root binding
  is nil indicating no limit.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.0&quot;}
 *print-level* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *verbose-defrecords* false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-sequential [^String begin, print-one, ^String sep, ^String end, sequence, ^Writer w]
  (binding [*print-level* (and (not *print-dup*) *print-level* (dec *print-level*))]
    (if (and *print-level* (neg? *print-level*))
      (.write w &quot;#&quot;)
      (do
        (.write w begin)
        (when-let [xs (seq sequence)]
          (if (and (not *print-dup*) *print-length*)
            (loop [[x &amp; xs] xs
                   print-length *print-length*]
              (if (zero? print-length)
                (.write w &quot;...&quot;)
                (do
                  (print-one x w)
                  (when xs
                    (.write w sep)
                    (recur xs (dec print-length))))))
            (loop [[x &amp; xs] xs]
              (print-one x w)
              (when xs
                (.write w sep)
                (recur xs)))))
        (.write w end)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-meta [o, ^Writer w]
  (when-let [m (meta o)]
    (when (and (pos? (count m))
               (or *print-dup*
                   (and *print-meta* *print-readably*)))
      (.write w &quot;^&quot;)
      (if (and (= (count m) 1) (:tag m))
          (pr-on (:tag m) w)
          (pr-on m w))
      (.write w &quot; &quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method :default [o, ^Writer w]
  (print-method (vary-meta o #(dissoc % :type)) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method nil [o, ^Writer w]
  (.write w &quot;nil&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup nil [o w] (print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-ctor [o print-args ^Writer w]
  (.write w &quot;#=(&quot;)
  (.write w (.getName ^Class (class o)))
  (.write w &quot;. &quot;)
  (print-args o w)
  (.write w &quot;)&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-object [o, ^Writer w]
  (.write w &quot;#&lt;&quot;)
  (.write w (.getSimpleName (class o)))
  (.write w &quot; &quot;)
  (.write w (str o))
  (.write w &quot;&gt;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Object [o, ^Writer w]
  (print-object o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.Keyword [o, ^Writer w]
  (.write w (str o)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.Keyword [o w] (print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Number [o, ^Writer w]
  (.write w (str o)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup Number [o, ^Writer w]
  (print-ctor o
              (fn [o w]
                  (print-dup (str o) w))
              w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.Fn [o, ^Writer w]
  (print-ctor o (fn [o w]) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(prefer-method print-dup clojure.lang.IPersistentCollection clojure.lang.Fn)
(prefer-method print-dup java.util.Map clojure.lang.Fn)
(prefer-method print-dup java.util.Collection clojure.lang.Fn)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Boolean [o, ^Writer w]
  (.write w (str o)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup Boolean [o w] (print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-simple [o, ^Writer w]
  (print-meta o w)
  (.write w (str o)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.Symbol [o, ^Writer w]
  (print-simple o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.Symbol [o w] (print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.Var [o, ^Writer w]
  (print-simple o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.Var [^clojure.lang.Var o, ^Writer w]
  (.write w (str &quot;#=(var &quot; (.name (.ns o)) &quot;/&quot; (.sym o) &quot;)&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.ISeq [o, ^Writer w]
  (print-meta o w)
  (print-sequential &quot;(&quot; pr-on &quot; &quot; &quot;)&quot; o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.ISeq [o w] (print-method o w))
(defmethod print-dup clojure.lang.IPersistentList [o w] (print-method o w))
(prefer-method print-method clojure.lang.ISeq clojure.lang.IPersistentCollection)
(prefer-method print-dup clojure.lang.ISeq clojure.lang.IPersistentCollection)
(prefer-method print-method clojure.lang.ISeq java.util.Collection)
(prefer-method print-dup clojure.lang.ISeq java.util.Collection)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.Collection [o, ^Writer w]
 (print-ctor o #(print-sequential &quot;[&quot; print-dup &quot; &quot; &quot;]&quot; %1 %2) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.IPersistentCollection [o, ^Writer w]
  (print-meta o w)
  (.write w &quot;#=(&quot;)
  (.write w (.getName ^Class (class o)))
  (.write w &quot;/create &quot;)
  (print-sequential &quot;[&quot; print-dup &quot; &quot; &quot;]&quot; o w)
  (.write w &quot;)&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(prefer-method print-dup clojure.lang.IPersistentCollection java.util.Collection)</pre></td></tr><tr><td class="docs"><p>Returns escape string for char or nil if none</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:tag String 
       :doc 
       :added &quot;1.0&quot;}
  char-escape-string
    {\newline &quot;\\n&quot;
     \tab  &quot;\\t&quot;
     \return &quot;\\r&quot;
     \&quot; &quot;\\\&quot;&quot;
     \\  &quot;\\\\&quot;
     \formfeed &quot;\\f&quot;
     \backspace &quot;\\b&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method String [^String s, ^Writer w]
  (if (or *print-dup* *print-readably*)
    (do (.append w \&quot;)
      (dotimes [n (count s)]
        (let [c (.charAt s n)
              e (char-escape-string c)]
          (if e (.write w e) (.append w c))))
      (.append w \&quot;))
    (.write w s))
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup String [s w] (print-method s w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.IPersistentVector [v, ^Writer w]
  (print-meta v w)
  (print-sequential &quot;[&quot; pr-on &quot; &quot; &quot;]&quot; v w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-map [m print-one w]
  (print-sequential 
   &quot;{&quot;
   (fn [e  ^Writer w]
     (do (print-one (key e) w) (.append w \space) (print-one (val e) w)))
   &quot;, &quot;
   &quot;}&quot;
   (seq m) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.IPersistentMap [m, ^Writer w]
  (print-meta m w)
  (print-map m pr-on w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.Map [m, ^Writer w]
  (print-ctor m #(print-map (seq %1) print-dup %2) w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.IPersistentMap [m, ^Writer w]
  (print-meta m w)
  (.write w &quot;#=(&quot;)
  (.write w (.getName (class m)))
  (.write w &quot;/create &quot;)
  (print-map m print-dup w)
  (.write w &quot;)&quot;))</pre></td></tr><tr><td class="docs"><p>java.util</p>
</td><td class="codes"><pre class="brush: clojure">(prefer-method print-method clojure.lang.IPersistentCollection java.util.Collection)
(prefer-method print-method clojure.lang.IPersistentCollection java.util.RandomAccess)
(prefer-method print-method java.util.RandomAccess java.util.List)
(prefer-method print-method clojure.lang.IPersistentCollection java.util.Map)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.List [c, ^Writer w]
  (if *print-readably*
    (do
      (print-meta c w)
      (print-sequential &quot;(&quot; pr-on &quot; &quot; &quot;)&quot; c w))
    (print-object c w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.RandomAccess [v, ^Writer w]
  (if *print-readably*
    (do
      (print-meta v w)
      (print-sequential &quot;[&quot; pr-on &quot; &quot; &quot;]&quot; v w))
    (print-object v w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.Map [m, ^Writer w]
  (if *print-readably*
    (do
      (print-meta m w)
      (print-map m pr-on w))
    (print-object m w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.Set [s, ^Writer w]
  (if *print-readably*
    (do
      (print-meta s w)
      (print-sequential &quot;#{&quot; pr-on &quot; &quot; &quot;}&quot; (seq s) w))
    (print-object s w)))</pre></td></tr><tr><td class="docs"><p>Records</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.IRecord [r, ^Writer w]
  (print-meta r w)
  (.write w &quot;#&quot;)
  (.write w (.getName (class r)))
  (print-map r pr-on w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.IRecord [r, ^Writer w]
  (print-meta r w)
  (.write w &quot;#&quot;)
  (.write w (.getName (class r)))
  (if *verbose-defrecords*
    (print-map r print-dup w)
    (print-sequential &quot;[&quot; pr-on &quot;, &quot; &quot;]&quot; (vals r) w)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(prefer-method print-method clojure.lang.IRecord java.util.Map)
(prefer-method print-method clojure.lang.IRecord clojure.lang.IPersistentMap)
(prefer-method print-dup clojure.lang.IRecord clojure.lang.IPersistentMap)
(prefer-method print-dup clojure.lang.IPersistentCollection java.util.Map)
(prefer-method print-dup clojure.lang.IRecord clojure.lang.IPersistentCollection)
(prefer-method print-dup clojure.lang.IRecord java.util.Map)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.IPersistentSet [s, ^Writer w]
  (print-meta s w)
  (print-sequential &quot;#{&quot; pr-on &quot; &quot; &quot;}&quot; (seq s) w))</pre></td></tr><tr><td class="docs"><p>Returns name string for char or nil if none</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:tag String
       :doc 
       :added &quot;1.0&quot;} 
 char-name-string
   {\newline &quot;newline&quot;
    \tab &quot;tab&quot;
    \space &quot;space&quot;
    \backspace &quot;backspace&quot;
    \formfeed &quot;formfeed&quot;
    \return &quot;return&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.lang.Character [^Character c, ^Writer w]
  (if (or *print-dup* *print-readably*)
    (do (.append w \\)
        (let [n (char-name-string c)]
          (if n (.write w n) (.append w c))))
    (.append w c))
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.lang.Character [c w] (print-method c w))
(defmethod print-dup java.lang.Long [o w] (print-method o w))
(defmethod print-dup java.lang.Double [o w] (print-method o w))
(defmethod print-dup clojure.lang.Ratio [o w] (print-method o w))
(defmethod print-dup java.math.BigDecimal [o w] (print-method o w))
(defmethod print-dup clojure.lang.BigInt [o w] (print-method o w))
(defmethod print-dup clojure.lang.PersistentHashMap [o w] (print-method o w))
(defmethod print-dup clojure.lang.PersistentHashSet [o w] (print-method o w))
(defmethod print-dup clojure.lang.PersistentVector [o w] (print-method o w))
(defmethod print-dup clojure.lang.LazilyPersistentVector [o w] (print-method o w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def primitives-classnames
  {Float/TYPE &quot;Float/TYPE&quot;
   Integer/TYPE &quot;Integer/TYPE&quot;
   Long/TYPE &quot;Long/TYPE&quot;
   Boolean/TYPE &quot;Boolean/TYPE&quot;
   Character/TYPE &quot;Character/TYPE&quot;
   Double/TYPE &quot;Double/TYPE&quot;
   Byte/TYPE &quot;Byte/TYPE&quot;
   Short/TYPE &quot;Short/TYPE&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method Class [^Class c, ^Writer w]
  (.write w (.getName c)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup Class [^Class c, ^Writer w]
  (cond
    (.isPrimitive c) (do
                       (.write w &quot;#=(identity &quot;)
                       (.write w ^String (primitives-classnames c))
                       (.write w &quot;)&quot;))
    (.isArray c) (do
                   (.write w &quot;#=(java.lang.Class/forName \&quot;&quot;)
                   (.write w (.getName c))
                   (.write w &quot;\&quot;)&quot;))
    :else (do
            (.write w &quot;#=&quot;)
            (.write w (.getName c)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.math.BigDecimal [b, ^Writer w]
  (.write w (str b))
  (.write w &quot;M&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.BigInt [b, ^Writer w]
  (.write w (str b))
  (.write w &quot;N&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.regex.Pattern [p ^Writer w]
  (.write w &quot;#\&quot;&quot;)
  (loop [[^Character c &amp; r :as s] (seq (.pattern ^java.util.regex.Pattern p))
         qmode false]
    (when s
      (cond
        (= c \\) (let [[^Character c2 &amp; r2] r]
                   (.append w \\)
                   (.append w c2)
                   (if qmode
                      (recur r2 (not= c2 \E))
                      (recur r2 (= c2 \Q))))
        (= c \&quot;) (do
                   (if qmode
                     (.write w &quot;\\E\\\&quot;\\Q&quot;)
                     (.write w &quot;\\\&quot;&quot;))
                   (recur r qmode))
        :else    (do
                   (.append w c)
                   (recur r qmode)))))
  (.append w \&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.regex.Pattern [p ^Writer w] (print-method p w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup clojure.lang.Namespace [^clojure.lang.Namespace n ^Writer w]
  (.write w &quot;#=(find-ns &quot;)
  (print-dup (.name n) w)
  (.write w &quot;)&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method clojure.lang.IDeref [o ^Writer w]
  (print-sequential (format &quot;#&lt;%s@%x%s: &quot;
                            (.getSimpleName (class o))
                            (System/identityHashCode o)
                            (if (and (instance? clojure.lang.Agent o)
                                     (agent-error o))
                              &quot; FAILED&quot;
                              &quot;&quot;))
                    pr-on, &quot;&quot;, &quot;&gt;&quot;, (list (if (and (instance? clojure.lang.IPending o) (not (.isRealized o)))
                                            :pending
                                            @o)), w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} print-initialized true)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.core)</pre></td></tr><tr><td class="docs"><p>proxy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import
 '(clojure.asm ClassWriter ClassVisitor Opcodes Type) 
 '(java.lang.reflect Modifier Constructor)
 '(clojure.asm.commons Method GeneratorAdapter)
 '(clojure.lang IProxy Reflector DynamicClassLoader IPersistentMap PersistentHashMap RT))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn method-sig [^java.lang.reflect.Method meth]
  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- most-specific [rtypes]
  (or (some (fn [t] (when (every? #(isa? t %) rtypes) t)) rtypes)
    (throw (Exception. &quot;Incompatible return types&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- group-by-sig [coll]
 &quot;takes a collection of [msig meth] and returns a seq of maps from return-types to meths.&quot;
  (vals (reduce1 (fn [m [msig meth]]
                  (let [rtype (peek msig)
                        argsig (pop msig)]
                    (assoc m argsig (assoc (m argsig {}) rtype meth))))
          {} coll)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn proxy-name
 {:tag String} 
 [^Class super interfaces]
  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]
    (apply str (.replace (str *ns*) \- \_) &quot;.proxy&quot;
      (interleave (repeat &quot;$&quot;)
        (concat
          [(.getName super)]
          (map #(subs % (inc (.lastIndexOf ^String % &quot;.&quot;))) inames)
          [(Integer/toHexString (hash inames))])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- generate-proxy [^Class super interfaces]
  (let [cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))
        cname (.replace (proxy-name super interfaces) \. \/) ;(str &quot;clojure/lang/&quot; (gensym &quot;Proxy__&quot;))
        ctype (. Type (getObjectType cname))
        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))
        fmap &quot;__clojureFnMap&quot;
        totype (fn [^Class c] (. Type (getType c)))
        to-types (fn [cs] (if (pos? (count cs))
                            (into-array (map totype cs))
                            (make-array Type 0)))
        super-type ^Type (totype super)
        imap-type ^Type (totype IPersistentMap)
        ifn-type (totype clojure.lang.IFn)
        obj-type (totype Object)
        sym-type (totype clojure.lang.Symbol)
        rt-type  (totype clojure.lang.RT)
        ex-type  (totype java.lang.UnsupportedOperationException)
        gen-bridge 
        (fn [^java.lang.reflect.Method meth ^java.lang.reflect.Method dest]
            (let [pclasses (. meth (getParameterTypes))
                  ptypes (to-types pclasses)
                  rtype ^Type (totype (. meth (getReturnType)))
                  m (new Method (. meth (getName)) rtype ptypes)
                  dtype (totype (.getDeclaringClass dest))
                  dm (new Method (. dest (getName)) (totype (. dest (getReturnType))) (to-types (. dest (getParameterTypes))))
                  gen (new GeneratorAdapter (bit-or (. Opcodes ACC_PUBLIC) (. Opcodes ACC_BRIDGE)) m nil nil cv)]
              (. gen (visitCode))
              (. gen (loadThis))
              (dotimes [i (count ptypes)]
                  (. gen (loadArg i)))
              (if (-&gt; dest .getDeclaringClass .isInterface)
                (. gen (invokeInterface dtype dm))
                (. gen (invokeVirtual dtype dm)))
              (. gen (returnValue))
              (. gen (endMethod))))
        gen-method
        (fn [^java.lang.reflect.Method meth else-gen]
            (let [pclasses (. meth (getParameterTypes))
                  ptypes (to-types pclasses)
                  rtype ^Type (totype (. meth (getReturnType)))
                  m (new Method (. meth (getName)) rtype ptypes)
                  gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)
                  else-label (. gen (newLabel))
                  end-label (. gen (newLabel))
                  decl-type (. Type (getType (. meth (getDeclaringClass))))]
              (. gen (visitCode))
              (if (&gt; (count pclasses) 18)
                (else-gen gen m)
                (do
                  (. gen (loadThis))
                  (. gen (getField ctype fmap imap-type))
                  (. gen (push (. meth (getName))))
                                        ;lookup fn in map
                  (. gen (invokeStatic rt-type (. Method (getMethod &quot;Object get(Object, Object)&quot;))))
                  (. gen (dup))
                  (. gen (ifNull else-label))
                                        ;if found
                  (.checkCast gen ifn-type)
                  (. gen (loadThis))
                                        ;box args
                  (dotimes [i (count ptypes)]
                      (. gen (loadArg i))
                    (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))
                                        ;call fn
                  (. gen (invokeInterface ifn-type (new Method &quot;invoke&quot; obj-type 
                                                        (into-array (cons obj-type 
                                                                          (replicate (count ptypes) obj-type))))))
                                        ;unbox return
                  (. gen (unbox rtype))
                  (when (= (. rtype (getSort)) (. Type VOID))
                    (. gen (pop)))
                  (. gen (goTo end-label))
                                        ;else call supplied alternative generator
                  (. gen (mark else-label))
                  (. gen (pop))
                  (else-gen gen m)
                  (. gen (mark end-label))))
              (. gen (returnValue))
              (. gen (endMethod))))]
                                        ;start class definition
    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))
                 cname nil (iname super) 
                 (into-array (map iname (cons IProxy interfaces)))))
                                        ;add field for fn mappings
    (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_VOLATILE))
                      fmap (. imap-type (getDescriptor)) nil nil))          
                                        ;add ctors matching/calling super's
    (doseq [^Constructor ctor (. super (getDeclaredConstructors))]
        (when-not (. Modifier (isPrivate (. ctor (getModifiers))))
          (let [ptypes (to-types (. ctor (getParameterTypes)))
                m (new Method &quot;&lt;init&gt;&quot; (. Type VOID_TYPE) ptypes)
                gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]
            (. gen (visitCode))
                                        ;call super ctor
            (. gen (loadThis))
            (. gen (dup))
            (. gen (loadArgs))
            (. gen (invokeConstructor super-type m))
            (. gen (returnValue))
            (. gen (endMethod)))))
                                        ;add IProxy methods
    (let [m (. Method (getMethod &quot;void __initClojureFnMappings(clojure.lang.IPersistentMap)&quot;))
          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]
      (. gen (visitCode))
      (. gen (loadThis))
      (. gen (loadArgs))
      (. gen (putField ctype fmap imap-type))
      (. gen (returnValue))
      (. gen (endMethod)))
    (let [m (. Method (getMethod &quot;void __updateClojureFnMappings(clojure.lang.IPersistentMap)&quot;))
          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]
      (. gen (visitCode))
      (. gen (loadThis))
      (. gen (dup))
      (. gen (getField ctype fmap imap-type))
      (.checkCast gen (totype clojure.lang.IPersistentCollection))
      (. gen (loadArgs))
      (. gen (invokeInterface (totype clojure.lang.IPersistentCollection)
                              (. Method (getMethod &quot;clojure.lang.IPersistentCollection cons(Object)&quot;))))
      (. gen (checkCast imap-type))
      (. gen (putField ctype fmap imap-type))
      (. gen (returnValue))
      (. gen (endMethod)))
    (let [m (. Method (getMethod &quot;clojure.lang.IPersistentMap __getClojureFnMappings()&quot;))
          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]
      (. gen (visitCode))
      (. gen (loadThis))
      (. gen (getField ctype fmap imap-type))
      (. gen (returnValue))
      (. gen (endMethod)))
                                        ;calc set of supers' non-private instance methods
    (let [[mm considered]
            (loop [mm {} considered #{} c super]
              (if c
                (let [[mm considered]
                      (loop [mm mm 
                             considered considered 
                             meths (concat 
                                    (seq (. c (getDeclaredMethods)))
                                    (seq (. c (getMethods))))]
                        (if (seq meths)
                          (let [^java.lang.reflect.Method meth (first meths)
                                mods (. meth (getModifiers))
                                mk (method-sig meth)]
                            (if (or (considered mk)
                                    (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))
                                    ;(. Modifier (isPrivate mods)) 
                                    (. Modifier (isStatic mods))
                                    (. Modifier (isFinal mods))
                                    (= &quot;finalize&quot; (.getName meth)))
                              (recur mm (conj considered mk) (next meths))
                              (recur (assoc mm mk meth) (conj considered mk) (next meths))))
                          [mm considered]))]
                  (recur mm considered (. c (getSuperclass))))
                [mm considered]))
          ifaces-meths (into1 {} 
                         (for [^Class iface interfaces meth (. iface (getMethods))
                               :let [msig (method-sig meth)] :when (not (considered msig))]
                           {msig meth}))
          mgroups (group-by-sig (concat mm ifaces-meths))
          rtypes (map #(most-specific (keys %)) mgroups)
          mb (map #(vector (%1 %2) (vals (dissoc %1 %2))) mgroups rtypes)
          bridge? (reduce1 into1 #{} (map second mb))
          ifaces-meths (remove bridge? (vals ifaces-meths))
          mm (remove bridge? (vals mm))]
                                        ;add methods matching supers', if no mapping -&gt; call super
      (doseq [[^java.lang.reflect.Method dest bridges] mb
              ^java.lang.reflect.Method meth bridges]
          (gen-bridge meth dest))
      (doseq [^java.lang.reflect.Method meth mm]
          (gen-method meth 
                      (fn [^GeneratorAdapter gen ^Method m]
                          (. gen (loadThis))
                                        ;push args
                        (. gen (loadArgs))
                                        ;call super
                        (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) 
                                                (. super-type (getInternalName))
                                                (. m (getName))
                                                (. m (getDescriptor)))))))
                                        ;add methods matching interfaces', if no mapping -&gt; throw
      (doseq [^java.lang.reflect.Method meth ifaces-meths]
                (gen-method meth 
                            (fn [^GeneratorAdapter gen ^Method m]
                                (. gen (throwException ex-type (. m (getName))))))))
                                        ;finish class def
    (. cv (visitEnd))
    [cname (. cv toByteArray)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-super-and-interfaces [bases]
  (if (. ^Class (first bases) (isInterface))
    [Object bases]
    [(first bases) (next bases)]))</pre></td></tr><tr><td class="docs"><p>Takes an optional single class followed by zero or more
  interfaces. If not supplied class defaults to Object.  Creates an
  returns an instance of a proxy class derived from the supplied
  classes. The resulting value is cached and used for any subsequent
  requests for the same class set. Returns a Class object.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-proxy-class 
  {:added &quot;1.0&quot;}
  [&amp; bases]
    (let [[super interfaces] (get-super-and-interfaces bases)
          pname (proxy-name super interfaces)]
      (or (RT/loadClassForName pname)
          (let [[cname bytecode] (generate-proxy super interfaces)]
            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))</pre></td></tr><tr><td class="docs"><p>Takes a proxy class and any arguments for its superclass ctor and
  creates and returns an instance of the proxy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn construct-proxy
  {:added &quot;1.0&quot;}
  [c &amp; ctor-args]
    (. Reflector (invokeConstructor c (to-array ctor-args))))</pre></td></tr><tr><td class="docs"><p>Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  sets the proxy's fn map.  Returns the proxy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn init-proxy
  {:added &quot;1.0&quot;}
  [^IProxy proxy mappings]
    (. proxy (__initClojureFnMappings mappings))
    proxy)</pre></td></tr><tr><td class="docs"><p>Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  updates (via assoc) the proxy's fn map. nil can be passed instead of
  a fn, in which case the corresponding method will revert to the
  default behavior. Note that this function can be used to update the
  behavior of an existing instance without changing its identity.
  Returns the proxy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-proxy
  {:added &quot;1.0&quot;}
  [^IProxy proxy mappings]
    (. proxy (__updateClojureFnMappings mappings))
    proxy)</pre></td></tr><tr><td class="docs"><p>Takes a proxy instance and returns the proxy's fn map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn proxy-mappings
  {:added &quot;1.0&quot;}
  [^IProxy proxy]
    (. proxy (__getClojureFnMappings)))</pre></td></tr><tr><td class="docs"><p>class-and-interfaces - a vector of class names</p>

<p>  args - a (possibly empty) vector of arguments to the superclass
  constructor.</p>

<p>  f => (name [params*] body) or
  (name ([params*] body) ([params+] body) ...)</p>

<p>  Expands to code which creates a instance of a proxy class that
  implements the named class/interface(s) by calling the supplied
  fns. A single class, if provided, must be first. If not provided it
  defaults to Object.</p>

<p>  The interfaces names must be valid interface types. If a method fn
  is not provided for a class method, the superclass methd will be
  called. If a method fn is not provided for an interface method, an
  UnsupportedOperationException will be thrown should it be
  called. Method fns are closures and can capture the environment in
  which proxy is called. Each method fn takes an additional implicit
  first arg, which is bound to 'this. Note that while method fns can
  be provided to override protected methods, they have no other access
  to protected members, nor to super, as these capabilities cannot be
  proxied.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro proxy
  {:added &quot;1.0&quot;}
  [class-and-interfaces args &amp; fs]
   (let [bases (map #(or (resolve %) (throw (Exception. (str &quot;Can't resolve: &quot; %)))) 
                    class-and-interfaces)
         [super interfaces] (get-super-and-interfaces bases)
         compile-effect (when *compile-files*
                          (let [[cname bytecode] (generate-proxy super interfaces)]
                            (clojure.lang.Compiler/writeClassFile cname bytecode)))
         pc-effect (apply get-proxy-class bases)
         pname (proxy-name super interfaces)]
     ;remember the class to prevent it from disappearing before use
     (intern *ns* (symbol pname) pc-effect)
     `(let [;pc# (get-proxy-class ~@class-and-interfaces)
            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   
        (init-proxy p#
         ~(loop [fmap {} fs fs]
            (if fs
              (let [[sym &amp; meths] (first fs)
                    meths (if (vector? (first meths))
                            (list meths)
                            meths)
                    meths (map (fn [[params &amp; body]]
                                   (cons (apply vector 'this params) body))
                               meths)]
                (if-not (contains? fmap (name sym))		  
                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))
		           (throw (IllegalArgumentException.
			              (str &quot;Method '&quot; (name sym) &quot;' redefined&quot;)))))
              fmap)))
        p#)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn proxy-call-with-super [call this meth]
 (let [m (proxy-mappings this)]
    (update-proxy this (assoc m meth nil))
    (let [ret (call)]
      (update-proxy this m)
      ret)))</pre></td></tr><tr><td class="docs"><p>Use to call a superclass method in the body of a proxy method. 
  Note, expansion captures 'this</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro proxy-super 
  {:added &quot;1.0&quot;}
  [meth &amp; args]
 `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))</pre></td></tr><tr><td class="docs"><p>Takes a Java object and returns a read-only implementation of the
  map abstraction based upon its JavaBean properties.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bean
  {:added &quot;1.0&quot;}
  [^Object x]
  (let [c (. x (getClass))
	pmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]
			 (let [name (. pd (getName))
			       method (. pd (getReadMethod))]
			   (if (and method (zero? (alength (. method (getParameterTypes)))))
			     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))
			     m)))
		     {}
		     (seq (.. java.beans.Introspector
			      (getBeanInfo c)
			      (getPropertyDescriptors))))
	v (fn [k] ((pmap k)))
        snapshot (fn []
                   (reduce1 (fn [m e]
                             (assoc m (key e) ((val e))))
                           {} (seq pmap)))]
    (proxy [clojure.lang.APersistentMap]
           []
      (containsKey [k] (contains? pmap k))
      (entryAt [k] (when (contains? pmap k) (new clojure.lang.MapEntry k (v k))))
      (valAt ([k] (when (contains? pmap k) (v k)))
	     ([k default] (if (contains? pmap k) (v k) default)))
      (cons [m] (conj (snapshot) m))
      (count [] (count pmap))
      (assoc [k v] (assoc (snapshot) k v))
      (without [k] (dissoc (snapshot) k))
      (seq [] ((fn thisfn [plseq]
		  (lazy-seq
                   (when-let [pseq (seq plseq)]
                     (cons (new clojure.lang.MapEntry (first pseq) (v (first pseq)))
                           (thisfn (rest pseq)))))) (keys pmap))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.data" name="clojure.data"><h1 class="project-name">clojure.data</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Non-core data functions.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Stuart Halloway&quot;,
    :doc }
  clojure.data
  (:require [clojure.set :as set]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare diff)</pre></td></tr><tr><td class="docs"><p>Internal helper for diff.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- atom-diff
  [a b]
  (if (= a b) [nil nil a] [a b nil]))</pre></td></tr><tr><td class="docs"><p>Convert an associative-by-numeric-index collection into
   an equivalent vector, with nil for any missing keys</p>

<p>for big things a sparse vector class would be better</p>
</td><td class="codes"><pre class="brush: clojure">(defn- vectorize
  [m]
  (when (seq m)
    (reduce
     (fn [result [k v]] (assoc result k v))
     (vec (repeat (apply max (keys m))  nil))
     m)))</pre></td></tr><tr><td class="docs"><p>Diff associative things a and b, comparing only keys in ks.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- diff-associative
  [a b ks]
  (reduce
   (fn [diff1 diff2]
     (doall (map merge diff1 diff2)))
   [nil nil nil]
   (map
    (fn [k] (map #(when % {k %}) (diff (get a k) (get b k))))
    ks)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- diff-sequential
  [a b]
  (vec (map vectorize (diff-associative
                       (if (vector? a) a (vec a))
                       (if (vector? b) b (vec b))
                       (range (max (count a) (count b)))))))</pre></td></tr><tr><td class="docs"><p>Implementation detail. Subject to change.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol ^{:added &quot;1.3&quot;} EqualityPartition
  (^{:added &quot;1.3&quot;} equality-partition [x] ))</pre></td></tr><tr><td class="docs"><p>Implementation detail. Subject to change.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol ^{:added &quot;1.3&quot;} Diff
  (^{:added &quot;1.3&quot;} diff-similar [a b] ))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend nil
        Diff
        {:diff-similar atom-diff})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend Object
        Diff
        {:diff-similar (fn [a b] ((if (.. a getClass isArray) diff-sequential atom-diff) a b))}
        EqualityPartition
        {:equality-partition (fn [x] (if (.. x getClass isArray) :sequential :atom))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol EqualityPartition
  nil
  (equality-partition [x] :atom)
  
  java.util.Set
  (equality-partition [x] :set)

  java.util.List
  (equality-partition [x] :sequential)
  
  java.util.Map
  (equality-partition [x] :map))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- as-set-value
  [s]
  (if (set? s) s (into #{} s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Diff
  java.util.Set
  (diff-similar
   [a b]
   (let [aval (as-set-value a)
         bval (as-set-value b)]
     [(not-empty (set/difference aval bval))
      (not-empty (set/difference bval aval))
      (not-empty (set/intersection aval bval))]))
  
  java.util.List
  (diff-similar [a b]
    (diff-sequential a b))
  
  java.util.Map
  (diff-similar [a b]
    (diff-associative a b (set/union (keys a) (keys b)))))</pre></td></tr><tr><td class="docs"><p>Recursively compares a and b, returning a tuple of
  [things-only-in-a things-only-in-b things-in-both].
  Comparison rules:</p>

<ul>
<li>For equal a and b, return [nil nil a].</li>
<li>Maps are subdiffed where keys match and values differ.</li>
<li>Sets are never subdiffed.</li>
<li>All sequential things are treated as associative collections
by their indexes, with results returned as vectors.</li>
<li>Everything else (including strings!) is treated as
an atom and compared for equality.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn diff
  {:added &quot;1.3&quot;}
  [a b]
  (if (= a b)
    [nil nil a]
    (if (= (equality-partition a) (equality-partition b))
      (diff-similar a b)
      (atom-diff a b))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.core)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import '(java.lang.reflect Modifier Constructor)
        '(clojure.asm ClassWriter ClassVisitor Opcodes Type)
        '(clojure.asm.commons Method GeneratorAdapter)
        '(clojure.lang IPersistentMap))</pre></td></tr><tr><td class="docs"><p>(defn method-sig [^java.lang.reflect.Method meth]
 [(. meth (getName)) (seq (. meth (getParameterTypes)))])</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- non-private-methods [^Class c]
  (loop [mm {}
         considered #{}
         c c]
    (if c
      (let [[mm considered]
            (loop [mm mm
                   considered considered
                   meths (seq (concat
                                (seq (. c (getDeclaredMethods)))
                                (seq (. c (getMethods)))))]
              (if meths
                (let [^java.lang.reflect.Method meth (first meths)
                      mods (. meth (getModifiers))
                      mk (method-sig meth)]
                  (if (or (considered mk)
                          (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))
                          ;(. Modifier (isPrivate mods))
                          (. Modifier (isStatic mods))
                          (. Modifier (isFinal mods))
                          (= &quot;finalize&quot; (.getName meth)))
                    (recur mm (conj considered mk) (next meths))
                    (recur (assoc mm mk meth) (conj considered mk) (next meths))))
                [mm considered]))]
        (recur mm considered (. c (getSuperclass))))
      mm)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ctor-sigs [^Class super]
  (for [^Constructor ctor (. super (getDeclaredConstructors))
        :when (not (. Modifier (isPrivate (. ctor (getModifiers)))))]
    (apply vector (. ctor (getParameterTypes)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- escape-class-name [^Class c]
  (.. (.getSimpleName c) 
      (replace &quot;[]&quot; &quot;&lt;&gt;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- overload-name [mname pclasses]
  (if (seq pclasses)
    (apply str mname (interleave (repeat \-) 
                                 (map escape-class-name pclasses)))
    (str mname &quot;-void&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ^java.lang.reflect.Field find-field [^Class c f]
  (let [start-class c]
    (loop [c c]
      (if (= c Object)
        (throw (new Exception (str &quot;field, &quot; f &quot;, not defined in class, &quot; start-class &quot;, or its ancestors&quot;)))
        (let [dflds (.getDeclaredFields c)
              rfld (first (filter #(= f (.getName ^java.lang.reflect.Field %)) dflds))]
          (or rfld (recur (.getSuperclass c))))))))</pre></td></tr><tr><td class="docs"><p>(distinct (map first(keys (mapcat non-private-methods [Object IPersistentMap]))))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} prim-&gt;class
     {'int Integer/TYPE
      'ints (Class/forName &quot;[I&quot;)
      'long Long/TYPE
      'longs (Class/forName &quot;[J&quot;)
      'float Float/TYPE
      'floats (Class/forName &quot;[F&quot;)
      'double Double/TYPE
      'doubles (Class/forName &quot;[D&quot;)
      'void Void/TYPE
      'short Short/TYPE
      'shorts (Class/forName &quot;[S&quot;)
      'boolean Boolean/TYPE
      'booleans (Class/forName &quot;[Z&quot;)
      'byte Byte/TYPE
      'bytes (Class/forName &quot;[B&quot;)
      'char Character/TYPE
      'chars (Class/forName &quot;[C&quot;)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ^Class the-class [x] 
  (cond 
   (class? x) x
   (contains? prim-&gt;class x) (prim-&gt;class x)
   :else (let [strx (str x)]
           (clojure.lang.RT/classForName 
            (if (some #{\. \[} strx)
              strx
              (str &quot;java.lang.&quot; strx))))))</pre></td></tr><tr><td class="docs"><p>someday this can be made codepoint aware</p>
</td><td class="codes"><pre class="brush: clojure">(defn- valid-java-method-name
  [^String s]
  (= s (clojure.lang.Compiler/munge s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- validate-generate-class-options
  [{:keys [methods]}]
  (let [[mname] (remove valid-java-method-name (map (comp str first) methods))]
    (when mname (throw (IllegalArgumentException. (str &quot;Not a valid method name: &quot; mname))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- generate-class [options-map]
  (validate-generate-class-options options-map)
  (let [default-options {:prefix &quot;-&quot; :load-impl-ns true :impl-ns (ns-name *ns*)}
        {:keys [name extends implements constructors methods main factory state init exposes 
                exposes-methods prefix load-impl-ns impl-ns post-init]} 
          (merge default-options options-map)
        name-meta (meta name)
        name (str name)
        super (if extends (the-class extends) Object)
        interfaces (map the-class implements)
        supers (cons super interfaces)
        ctor-sig-map (or constructors (zipmap (ctor-sigs super) (ctor-sigs super)))
        cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))
        cname (. name (replace &quot;.&quot; &quot;/&quot;))
        pkg-name name
        impl-pkg-name (str impl-ns)
        impl-cname (.. impl-pkg-name (replace &quot;.&quot; &quot;/&quot;) (replace \- \_))
        ctype (. Type (getObjectType cname))
        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))
        totype (fn [^Class c] (. Type (getType c)))
        to-types (fn [cs] (if (pos? (count cs))
                            (into-array (map totype cs))
                            (make-array Type 0)))
        obj-type ^Type (totype Object)
        arg-types (fn [n] (if (pos? n)
                            (into-array (replicate n obj-type))
                            (make-array Type 0)))
        super-type ^Type (totype super)
        init-name (str init)
        post-init-name (str post-init)
        factory-name (str factory)
        state-name (str state)
        main-name &quot;main&quot;
        var-name (fn [s] (clojure.lang.Compiler/munge (str s &quot;__var&quot;)))
        class-type  (totype Class)
        rt-type  (totype clojure.lang.RT)
        var-type ^Type (totype clojure.lang.Var)
        ifn-type (totype clojure.lang.IFn)
        iseq-type (totype clojure.lang.ISeq)
        ex-type  (totype java.lang.UnsupportedOperationException)
        all-sigs (distinct (concat (map #(let[[m p] (key %)] {m [p]}) (mapcat non-private-methods supers))
                                   (map (fn [[m p]] {(str m) [p]}) methods)))
        sigs-by-name (apply merge-with concat {} all-sigs)
        overloads (into1 {} (filter (fn [[m s]] (next s)) sigs-by-name))
        var-fields (concat (when init [init-name]) 
                           (when post-init [post-init-name])
                           (when main [main-name])
                           ;(when exposes-methods (map str (vals exposes-methods)))
                           (distinct (concat (keys sigs-by-name)
                                             (mapcat (fn [[m s]] (map #(overload-name m (map the-class %)) s)) overloads)
                                             (mapcat (comp (partial map str) vals val) exposes))))
        emit-get-var (fn [^GeneratorAdapter gen v]
                       (let [false-label (. gen newLabel)
                             end-label (. gen newLabel)]
                         (. gen getStatic ctype (var-name v) var-type)
                         (. gen dup)
                         (. gen invokeVirtual var-type (. Method (getMethod &quot;boolean isBound()&quot;)))
                         (. gen ifZCmp (. GeneratorAdapter EQ) false-label)
                         (. gen invokeVirtual var-type (. Method (getMethod &quot;Object get()&quot;)))
                         (. gen goTo end-label)
                         (. gen mark false-label)
                         (. gen pop)
                         (. gen visitInsn (. Opcodes ACONST_NULL))
                         (. gen mark end-label)))
        emit-unsupported (fn [^GeneratorAdapter gen ^Method m]
                           (. gen (throwException ex-type (str (. m (getName)) &quot; (&quot;
                                                               impl-pkg-name &quot;/&quot; prefix (.getName m)
                                                               &quot; not defined?)&quot;))))
        emit-forwarding-method
        (fn [name pclasses rclass as-static else-gen]
          (let [mname (str name)
                pmetas (map meta pclasses)
                pclasses (map the-class pclasses)
                rclass (the-class rclass)
                ptypes (to-types pclasses)
                rtype ^Type (totype rclass)
                m (new Method mname rtype ptypes)
                is-overload (seq (overloads mname))
                gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (if as-static (. Opcodes ACC_STATIC) 0)) 
                         m nil nil cv)
                found-label (. gen (newLabel))
                else-label (. gen (newLabel))
                end-label (. gen (newLabel))]
            (add-annotations gen (meta name))
            (dotimes [i (count pmetas)]
              (add-annotations gen (nth pmetas i) i))
            (. gen (visitCode))
            (if (&gt; (count pclasses) 18)
              (else-gen gen m)
              (do
                (when is-overload
                  (emit-get-var gen (overload-name mname pclasses))
                  (. gen (dup))
                  (. gen (ifNonNull found-label))
                  (. gen (pop)))
                (emit-get-var gen mname)
                (. gen (dup))
                (. gen (ifNull else-label))
                (when is-overload
                  (. gen (mark found-label)))
                                        ;if found
                (.checkCast gen ifn-type)
                (when-not as-static
                  (. gen (loadThis)))
                                        ;box args
                (dotimes [i (count ptypes)]
                  (. gen (loadArg i))
                  (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))
                                        ;call fn
                (. gen (invokeInterface ifn-type (new Method &quot;invoke&quot; obj-type 
                                                      (to-types (replicate (+ (count ptypes)
                                                                              (if as-static 0 1)) 
                                                                           Object)))))
                                        ;(into-array (cons obj-type 
                                        ;                 (replicate (count ptypes) obj-type))))))
                                        ;unbox return
                (. gen (unbox rtype))
                (when (= (. rtype (getSort)) (. Type VOID))
                  (. gen (pop)))
                (. gen (goTo end-label))
                                        ;else call supplied alternative generator
                (. gen (mark else-label))
                (. gen (pop))
                (else-gen gen m)
                (. gen (mark end-label))))
            (. gen (returnValue))
            (. gen (endMethod))))
        ]
                                        ;start class definition
    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))
                 cname nil (iname super)
                 (when-let [ifc (seq interfaces)]
                   (into-array (map iname ifc)))))
                                        ; class annotations
    (add-annotations cv name-meta)
                                        ;static fields for vars
    (doseq [v var-fields]
      (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_FINAL) (. Opcodes ACC_STATIC))
                        (var-name v) 
                        (. var-type getDescriptor)
                        nil nil)))
                                        ;instance field for state
    (when state
      (. cv (visitField (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_FINAL))
                        state-name 
                        (. obj-type getDescriptor)
                        nil nil)))
                                        ;static init to set up var fields and load init
    (let [gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) 
                   (. Method getMethod &quot;void &lt;clinit&gt; ()&quot;)
                   nil nil cv)]
      (. gen (visitCode))
      (doseq [v var-fields]
        (. gen push impl-pkg-name)
        (. gen push (str prefix v))
        (. gen (invokeStatic var-type (. Method (getMethod &quot;clojure.lang.Var internPrivate(String,String)&quot;))))
        (. gen putStatic ctype (var-name v) var-type))
      (when load-impl-ns
        (. gen push &quot;clojure.core&quot;)
        (. gen push &quot;load&quot;)
        (. gen (invokeStatic rt-type (. Method (getMethod &quot;clojure.lang.Var var(String,String)&quot;))))
        (. gen push (str &quot;/&quot; impl-cname))
        (. gen (invokeInterface ifn-type (new Method &quot;invoke&quot; obj-type (to-types [Object]))))
;        (. gen push (str (.replace impl-pkg-name \- \_) &quot;__init&quot;))
;        (. gen (invokeStatic class-type (. Method (getMethod &quot;Class forName(String)&quot;))))
        (. gen pop))
      (. gen (returnValue))
      (. gen (endMethod)))
                                        ;ctors
    (doseq [[pclasses super-pclasses] ctor-sig-map]
      (let [pclasses (map the-class pclasses)
            super-pclasses (map the-class super-pclasses)
            ptypes (to-types pclasses)
            super-ptypes (to-types super-pclasses)
            m (new Method &quot;&lt;init&gt;&quot; (. Type VOID_TYPE) ptypes)
            super-m (new Method &quot;&lt;init&gt;&quot; (. Type VOID_TYPE) super-ptypes)
            gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)
            no-init-label (. gen newLabel)
            end-label (. gen newLabel)
            no-post-init-label (. gen newLabel)
            end-post-init-label (. gen newLabel)
            nth-method (. Method (getMethod &quot;Object nth(Object,int)&quot;))
            local (. gen newLocal obj-type)]
        (. gen (visitCode))
        (if init
          (do
            (emit-get-var gen init-name)
            (. gen dup)
            (. gen ifNull no-init-label)
            (.checkCast gen ifn-type)
                                        ;box init args
            (dotimes [i (count pclasses)]
              (. gen (loadArg i))
              (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))
                                        ;call init fn
            (. gen (invokeInterface ifn-type (new Method &quot;invoke&quot; obj-type 
                                                  (arg-types (count ptypes)))))
                                        ;expecting [[super-ctor-args] state] returned
            (. gen dup)
            (. gen push (int 0))
            (. gen (invokeStatic rt-type nth-method))
            (. gen storeLocal local)
            (. gen (loadThis))
            (. gen dupX1)
            (dotimes [i (count super-pclasses)]
              (. gen loadLocal local)
              (. gen push (int i))
              (. gen (invokeStatic rt-type nth-method))
              (. clojure.lang.Compiler$HostExpr (emitUnboxArg nil gen (nth super-pclasses i))))
            (. gen (invokeConstructor super-type super-m))
            (if state
              (do
                (. gen push (int 1))
                (. gen (invokeStatic rt-type nth-method))
                (. gen (putField ctype state-name obj-type)))
              (. gen pop))
            (. gen goTo end-label)
                                        ;no init found
            (. gen mark no-init-label)
            (. gen (throwException ex-type (str impl-pkg-name &quot;/&quot; prefix init-name &quot; not defined&quot;)))
            (. gen mark end-label))
          (if (= pclasses super-pclasses)
            (do
              (. gen (loadThis))
              (. gen (loadArgs))
              (. gen (invokeConstructor super-type super-m)))
            (throw (new Exception &quot;:init not specified, but ctor and super ctor args differ&quot;))))
        (when post-init
          (emit-get-var gen post-init-name)
          (. gen dup)
          (. gen ifNull no-post-init-label)
          (.checkCast gen ifn-type)
          (. gen (loadThis))
                                       ;box init args
          (dotimes [i (count pclasses)]
            (. gen (loadArg i))
            (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))
                                       ;call init fn
          (. gen (invokeInterface ifn-type (new Method &quot;invoke&quot; obj-type 
                                                (arg-types (inc (count ptypes))))))
          (. gen pop)
          (. gen goTo end-post-init-label)
                                       ;no init found
          (. gen mark no-post-init-label)
          (. gen (throwException ex-type (str impl-pkg-name &quot;/&quot; prefix post-init-name &quot; not defined&quot;)))
          (. gen mark end-post-init-label))
        (. gen (returnValue))
        (. gen (endMethod))
                                        ;factory
        (when factory
          (let [fm (new Method factory-name ctype ptypes)
                gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) 
                         fm nil nil cv)]
            (. gen (visitCode))
            (. gen newInstance ctype)
            (. gen dup)
            (. gen (loadArgs))
            (. gen (invokeConstructor ctype m))            
            (. gen (returnValue))
            (. gen (endMethod))))))
                                        ;add methods matching supers', if no fn -&gt; call super
    (let [mm (non-private-methods super)]
      (doseq [^java.lang.reflect.Method meth (vals mm)]
             (emit-forwarding-method (.getName meth) (.getParameterTypes meth) (.getReturnType meth) false
                                     (fn [^GeneratorAdapter gen ^Method m]
                                       (. gen (loadThis))
                                        ;push args
                                       (. gen (loadArgs))
                                        ;call super
                                       (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) 
                                                               (. super-type (getInternalName))
                                                               (. m (getName))
                                                               (. m (getDescriptor)))))))
                                        ;add methods matching interfaces', if no fn -&gt; throw
      (reduce1 (fn [mm ^java.lang.reflect.Method meth]
                (if (contains? mm (method-sig meth))
                  mm
                  (do
                    (emit-forwarding-method (.getName meth) (.getParameterTypes meth) (.getReturnType meth) false
                                            emit-unsupported)
                    (assoc mm (method-sig meth) meth))))
              mm (mapcat #(.getMethods ^Class %) interfaces))
                                        ;extra methods
       (doseq [[mname pclasses rclass :as msig] methods]
         (emit-forwarding-method mname pclasses rclass (:static (meta msig))
                                 emit-unsupported))
                                        ;expose specified overridden superclass methods
       (doseq [[local-mname ^java.lang.reflect.Method m] (reduce1 (fn [ms [[name _ _] m]]
                              (if (contains? exposes-methods (symbol name))
                                (conj ms [((symbol name) exposes-methods) m])
                                ms)) [] (seq mm))]
         (let [ptypes (to-types (.getParameterTypes m))
               rtype (totype (.getReturnType m))
               exposer-m (new Method (str local-mname) rtype ptypes)
               target-m (new Method (.getName m) rtype ptypes)
               gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) exposer-m nil nil cv)]
           (. gen (loadThis))
           (. gen (loadArgs))
           (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) 
                                   (. super-type (getInternalName))
                                   (. target-m (getName))
                                   (. target-m (getDescriptor))))
           (. gen (returnValue))
           (. gen (endMethod)))))
                                        ;main
    (when main
      (let [m (. Method getMethod &quot;void main (String[])&quot;)
            gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) 
                     m nil nil cv)
            no-main-label (. gen newLabel)
            end-label (. gen newLabel)]
        (. gen (visitCode))
        (emit-get-var gen main-name)
        (. gen dup)
        (. gen ifNull no-main-label)
        (.checkCast gen ifn-type)
        (. gen loadArgs)
        (. gen (invokeStatic rt-type (. Method (getMethod &quot;clojure.lang.ISeq seq(Object)&quot;))))
        (. gen (invokeInterface ifn-type (new Method &quot;applyTo&quot; obj-type 
                                              (into-array [iseq-type]))))
        (. gen pop)
        (. gen goTo end-label)
                                        ;no main found
        (. gen mark no-main-label)
        (. gen (throwException ex-type (str impl-pkg-name &quot;/&quot; prefix main-name &quot; not defined&quot;)))
        (. gen mark end-label)
        (. gen (returnValue))
        (. gen (endMethod))))
                                        ;field exposers
    (doseq [[f {getter :get setter :set}] exposes]
      (let [fld (find-field super (str f))
            ftype (totype (.getType fld))
            static? (Modifier/isStatic (.getModifiers fld))
            acc (+ Opcodes/ACC_PUBLIC (if static? Opcodes/ACC_STATIC 0))]
        (when getter
          (let [m (new Method (str getter) ftype (to-types []))
                gen (new GeneratorAdapter acc m nil nil cv)]
            (. gen (visitCode))
            (if static?
              (. gen getStatic ctype (str f) ftype)
              (do
                (. gen loadThis)
                (. gen getField ctype (str f) ftype)))
            (. gen (returnValue))
            (. gen (endMethod))))
        (when setter
          (let [m (new Method (str setter) Type/VOID_TYPE (into-array [ftype]))
                gen (new GeneratorAdapter acc m nil nil cv)]
            (. gen (visitCode))
            (if static?
              (do
                (. gen loadArgs)
                (. gen putStatic ctype (str f) ftype))
              (do
                (. gen loadThis)
                (. gen loadArgs)
                (. gen putField ctype (str f) ftype)))
            (. gen (returnValue))
            (. gen (endMethod))))))
                                        ;finish class def
    (. cv (visitEnd))
    [cname (. cv (toByteArray))]))</pre></td></tr><tr><td class="docs"><p>When compiling, generates compiled bytecode for a class with the
  given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the <em>compile-path</em> directory.  When not compiling, does
  nothing. The gen-class construct contains no implementation, as the
  implementation will be dynamically sought by the generated class in
  functions in an implementing Clojure namespace. Given a generated
  class org.mydomain.MyClass with a method named mymethod, gen-class
  will generate an implementation that looks for a function named by 
  (str prefix mymethod) (default prefix: "-") in a
  Clojure namespace specified by :impl-ns
  (defaults to the current namespace). All inherited methods,
  generated methods, and init and main functions (see :methods, :init,
  and :main below) will be found similarly prefixed. By default, the
  static initializer for the generated class will attempt to load the
  Clojure support code for the class as a resource from the classpath,
  e.g. in the example case, <code>org/mydomain/MyClass__init.class</code>. This
  behavior can be controlled by :load-impl-ns</p>

<p>  Note that methods with a maximum of 18 parameters are supported.</p>

<p>  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.</p>

<p>  Options should be a set of key/value pairs, all except for :name are optional:</p>

<p>  :name aname</p>

<p>  The package-qualified name of the class to be generated</p>

<p>  :extends aclass</p>

<p>  Specifies the superclass, the non-private methods of which will be
  overridden by the class. If not provided, defaults to Object.</p>

<p>  :implements [interface ...]</p>

<p>  One or more interfaces, the methods of which will be implemented by the class.</p>

<p>  :init name</p>

<p>  If supplied, names a function that will be called with the arguments
  to the constructor. Must return [ [superclass-constructor-args] state] 
  If not supplied, the constructor args are passed directly to
  the superclass constructor and the state will be nil</p>

<p>  :constructors {[param-types] [super-param-types], ...}</p>

<p>  By default, constructors are created for the generated class which
  match the signature(s) of the constructors for the superclass. This
  parameter may be used to explicitly specify constructors, each entry
  providing a mapping from a constructor signature to a superclass
  constructor signature. When you supply this, you must supply an :init
  specifier. </p>

<p>  :post-init name</p>

<p>  If supplied, names a function that will be called with the object as
  the first argument, followed by the arguments to the constructor.
  It will be called every time an object of this class is created,
  immediately after all the inherited constructors have completed.
  It's return value is ignored.</p>

<p>  :methods [ [name [param-types] return-type], ...]</p>

<p>  The generated class automatically defines all of the non-private
  methods of its superclasses/interfaces. This parameter can be used
  to specify the signatures of additional methods of the generated
  class. Static methods can be specified with ^{:static true} in the
  signature's metadata. Do not repeat superclass/interface signatures
  here.</p>

<p>  :main boolean</p>

<p>  If supplied and true, a static public main function will be generated. It will
  pass each string of the String[] argument as a separate argument to
  a function called (str prefix main).</p>

<p>  :factory name</p>

<p>  If supplied, a (set of) public static factory function(s) will be
  created with the given name, and the same signature(s) as the
  constructor(s).</p>

<p>  :state name</p>

<p>  If supplied, a public final instance field with the given name will be
  created. You must supply an :init function in order to provide a
  value for the state. Note that, though final, the state can be a ref
  or agent, supporting the creation of Java objects with transactional
  or asynchronous mutation semantics.</p>

<p>  :exposes {protected-field-name {:get name :set name}, ...}</p>

<p>  Since the implementations of the methods of the generated class
  occur in Clojure functions, they have no access to the inherited
  protected fields of the superclass. This parameter can be used to
  generate public getter/setter methods exposing the protected field(s)
  for use in the implementation.</p>

<p>  :exposes-methods {super-method-name exposed-name, ...}</p>

<p>  It is sometimes necessary to call the superclass' implementation of an
  overridden method.  Those methods may be exposed and referred in 
  the new method implementation by a local name.</p>

<p>  :prefix string</p>

<p>  Default: "-" Methods called e.g. Foo will be looked up in vars called
  prefixFoo in the implementing ns.</p>

<p>  :impl-ns name</p>

<p>  Default: the name of the current ns. Implementations of methods will be 
  looked up in this namespace.</p>

<p>  :load-impl-ns boolean</p>

<p>  Default: true. Causes the static initializer for the generated class
  to reference the load code for the implementing namespace. Should be
  true when implementing-ns is the default, false if you intend to
  load the code via some other method.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro gen-class 
  {:added &quot;1.0&quot;}
  [&amp; options]
    (when *compile-files*
      (let [options-map (into1 {} (map vec (partition 2 options)))
            [cname bytecode] (generate-class options-map)]
        (clojure.lang.Compiler/writeClassFile cname bytecode))))</pre></td></tr><tr><td class="docs"><p>gen-interface ;;;;;;;;;;;;;;;;;;;;;;
based on original contribution by Chris Houser</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns an asm Type object for c, which may be a primitive class
  (such as Integer/TYPE), any other class (such as Double), or a
  fully-qualified class name given as a string or symbol
  (such as 'java.lang.String)</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ^Type asm-type
  [c]
  (if (or (instance? Class c) (prim-&gt;class c))
    (Type/getType (the-class c))
    (let [strx (str c)]
      (Type/getObjectType 
       (.replace (if (some #{\. \[} strx)
                   strx
                   (str &quot;java.lang.&quot; strx)) 
                 &quot;.&quot; &quot;/&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- generate-interface
  [{:keys [name extends methods]}]
  (when (some #(-&gt; % first clojure.core/name (.contains &quot;-&quot;)) methods)
    (throw
      (IllegalArgumentException. &quot;Interface methods must not contain '-'&quot;)))
  (let [iname (.replace (str name) &quot;.&quot; &quot;/&quot;)
        cv (ClassWriter. ClassWriter/COMPUTE_MAXS)]
    (. cv visit Opcodes/V1_5 (+ Opcodes/ACC_PUBLIC 
                                Opcodes/ACC_ABSTRACT
                                Opcodes/ACC_INTERFACE)
       iname nil &quot;java/lang/Object&quot;
       (when (seq extends)
         (into-array (map #(.getInternalName (asm-type %)) extends))))
    (add-annotations cv (meta name))
    (doseq [[mname pclasses rclass pmetas] methods]
      (let [mv (. cv visitMethod (+ Opcodes/ACC_PUBLIC Opcodes/ACC_ABSTRACT)
                  (str mname)
                  (Type/getMethodDescriptor (asm-type rclass) 
                                            (if pclasses
                                              (into-array Type (map asm-type pclasses))
                                              (make-array Type 0)))
                  nil nil)]
        (add-annotations mv (meta mname))
        (dotimes [i (count pmetas)]
          (add-annotations mv (nth pmetas i) i))
        (. mv visitEnd)))
    (. cv visitEnd)
    [iname (. cv toByteArray)]))</pre></td></tr><tr><td class="docs"><p>When compiling, generates compiled bytecode for an interface with
  the given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the <em>compile-path</em> directory.  When not compiling, does nothing.</p>

<p>  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.</p>

<p>  Options should be a set of key/value pairs, all except for :name are
  optional:</p>

<p>  :name aname</p>

<p>  The package-qualified name of the class to be generated</p>

<p>  :extends [interface ...]</p>

<p>  One or more interfaces, which will be extended by this interface.</p>

<p>  :methods [ [name [param-types] return-type], ...]</p>

<p>  This parameter is used to specify the signatures of the methods of
  the generated interface.  Do not repeat superinterface signatures
  here.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro gen-interface
  {:added &quot;1.0&quot;}
  [&amp; options]
    (let [options-map (apply hash-map options)
          [cname bytecode] (generate-interface options-map)]
      (if *compile-files*
        (clojure.lang.Compiler/writeClassFile cname bytecode)
        (.defineClass ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) 
                      (str (:name options-map)) bytecode options)))) </pre></td></tr><tr><td class="docs"><p>Generates and immediately loads the bytecode for the specified
  class. Note that a class generated this way can be loaded only once
  - the JVM supports only one class with a given name per
  classloader. Subsequent to generation you can import it into any
  desired namespaces just like any other class. See gen-class for a
  description of the options.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
(defn gen-and-load-class 
  {:added &quot;1.0&quot;}
  [&amp; options]
  (let [options-map (apply hash-map options)
        [cname bytecode] (generate-class options-map)]
    (.. (clojure.lang.RT/getRootClassLoader) (defineClass cname bytecode options)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>a generic vector implementation for vectors of primitives</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.core)</pre></td></tr><tr><td class="docs"><p>(set! <em>warn-on-reflection</em> true)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype VecNode [edit arr])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def EMPTY-NODE (VecNode. nil (object-array 32)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(definterface IVecImpl
  (^int tailoff [])
  (arrayFor [^int i])
  (pushTail [^int level ^clojure.core.VecNode parent ^clojure.core.VecNode tailnode])
  (popTail [^int level node])
  (newPath [edit ^int level node])
  (doAssoc [^int level node ^int i val]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(definterface ArrayManager
  (array [^int size])
  (^int alength [arr])
  (aclone [arr])
  (aget [arr ^int i])
  (aset [arr ^int i val]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype ArrayChunk [^clojure.core.ArrayManager am arr ^int off ^int end]
  clojure.lang.Indexed
  (nth [_ i] (.aget am arr (+ off i)))
  (count [_] (- end off))
  clojure.lang.IChunk
  (dropFirst [_]
    (if (= off end)
      (throw (IllegalStateException. &quot;dropFirst of empty chunk&quot;))
      (new ArrayChunk am arr (inc off) end)))
  (reduce [_ f init]
    (loop [ret init i off]
      (if (&lt; i end)
        (recur (f ret (.aget am arr i)) (inc i))
        ret))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype VecSeq [^clojure.core.ArrayManager am ^clojure.core.IVecImpl vec anode ^int i ^int offset] 
  :no-print true
  clojure.core.protocols.InternalReduce
  (internal-reduce
   [_ f val]
   (loop [result val
          aidx offset]
     (if (&lt; aidx (count vec))
       (let [node (.arrayFor vec aidx)
             result (loop [result result
                           node-idx (bit-and 0x1f aidx)]
                      (if (&lt; node-idx (.alength am node))
                        (recur (f result (.aget am node node-idx)) (inc node-idx))
                        result))]
         (recur result (bit-and 0xffe0 (+ aidx 32))))
       result)))
  clojure.lang.ISeq
  (first [_] (.aget am anode offset))
  (next [this] 
    (if (&lt; (inc offset) (.alength am anode))
      (new VecSeq am vec anode i (inc offset))
      (.chunkedNext this)))
  (more [this]
    (let [s (.next this)]
      (or s (clojure.lang.PersistentList/EMPTY))))
  (cons [this o]
    (clojure.lang.Cons. o this))
  (count [this]
    (loop [i 1
           s (next this)]
      (if s
        (if (instance? clojure.lang.Counted s)
          (+ i (.count s))
          (recur (inc i) (next s)))
        i)))
  (equiv [this o]
    (cond
     (identical? this o) true
     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))
     (loop [me this
            you (seq o)]
       (if (nil? me)
         (nil? you)
         (and (clojure.lang.Util/equiv (first me) (first you))
              (recur (next me) (next you)))))
     :else false))
  (empty [_]
    clojure.lang.PersistentList/EMPTY)
  clojure.lang.Seqable
  (seq [this] this)
  clojure.lang.IChunkedSeq
  (chunkedFirst [_] (ArrayChunk. am anode offset (.alength am anode)))
  (chunkedNext [_] 
   (let [nexti (+ i (.alength am anode))]
     (when (&lt; nexti (count vec))
       (new VecSeq am vec (.arrayFor vec nexti) nexti 0))))
  (chunkedMore [this]
    (let [s (.chunkedNext this)]
      (or s (clojure.lang.PersistentList/EMPTY)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method ::VecSeq [v w]
  ((get (methods print-method) clojure.lang.ISeq) v w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype Vec [^clojure.core.ArrayManager am ^int cnt ^int shift ^clojure.core.VecNode root tail _meta]
  Object
  (equals [this o]
    (cond 
     (identical? this o) true
     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))
       (and (= cnt (count o))
            (loop [i (int 0)]
              (cond
               (= i cnt) true
               (.equals (.nth this i) (nth o i)) (recur (inc i))
               :else false)))
     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))
       (.equals (seq this) (seq o))
     :else false))
  ;todo - cache
  (hashCode [this]
    (loop [hash (int 1) i (int 0)]
      (if (= i cnt)
        hash
        (let [val (.nth this i)]
          (recur (unchecked-add-int (unchecked-multiply-int 31 hash) 
                                (clojure.lang.Util/hash val)) 
                 (inc i))))))
  clojure.lang.Counted
  (count [_] cnt)
  clojure.lang.IMeta
  (meta [_] _meta)
  clojure.lang.IObj
  (withMeta [_ m] (new Vec am cnt shift root tail m))
  clojure.lang.Indexed
  (nth [this i]
    (let [a (.arrayFor this i)]
      (.aget am a (bit-and i (int 0x1f)))))
  (nth [this i not-found]
       (let [z (int 0)]
         (if (and (&gt;= i z) (&lt; i (.count this)))
           (.nth this i)
           not-found)))
  clojure.lang.IPersistentCollection
  (cons [this val]
     (if (&lt; (- cnt (.tailoff this)) (int 32))
      (let [new-tail (.array am (inc (.alength am tail)))]
        (System/arraycopy tail 0 new-tail 0 (.alength am tail))
        (.aset am new-tail (.alength am tail) val)
        (new Vec am (inc cnt) shift root new-tail (meta this)))
      (let [tail-node (VecNode. (.edit root) tail)] 
        (if (&gt; (bit-shift-right cnt (int 5)) (bit-shift-left (int 1) shift)) ;overflow root?
          (let [new-root (VecNode. (.edit root) (object-array 32))]
            (doto ^objects (.arr new-root)
              (aset 0 root)
              (aset 1 (.newPath this (.edit root) shift tail-node)))
            (new Vec am (inc cnt) (+ shift (int 5)) new-root (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this)))
          (new Vec am (inc cnt) shift (.pushTail this shift root tail-node) 
                 (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this))))))
  (empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))                             
  (equiv [this o]
    (cond 
     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))
       (and (= cnt (count o))
            (loop [i (int 0)]
              (cond
               (= i cnt) true
               (= (.nth this i) (nth o i)) (recur (inc i))
               :else false)))
     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))
       (clojure.lang.Util/equiv (seq this) (seq o))
     :else false))
  clojure.lang.IPersistentStack
  (peek [this]
    (when (&gt; cnt (int 0)) 
      (.nth this (dec cnt))))
  (pop [this]
   (cond
    (zero? cnt) 
      (throw (IllegalStateException. &quot;Can't pop empty vector&quot;))
    (= 1 cnt) 
      (new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))
    (&gt; (- cnt (.tailoff this)) 1)
      (let [new-tail (.array am (dec (.alength am tail)))]
        (System/arraycopy tail 0 new-tail 0 (.alength am new-tail))
        (new Vec am (dec cnt) shift root new-tail (meta this)))
    :else
      (let [new-tail (.arrayFor this (- cnt 2))
            new-root ^clojure.core.VecNode (.popTail this shift root)]
        (cond
         (nil? new-root) 
           (new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))
         (and (&gt; shift 5) (nil? (aget ^objects (.arr new-root) 1)))
           (new Vec am (dec cnt) (- shift 5) (aget ^objects (.arr new-root) 0) new-tail (meta this))
         :else
           (new Vec am (dec cnt) shift new-root new-tail (meta this))))))
  clojure.lang.IPersistentVector
  (assocN [this i val]
    (cond 
     (and (&lt;= (int 0) i) (&lt; i cnt))
       (if (&gt;= i (.tailoff this))
         (let [new-tail (.array am (.alength am tail))]
           (System/arraycopy tail 0 new-tail 0 (.alength am tail))
           (.aset am new-tail (bit-and i (int 0x1f)) val)
           (new Vec am cnt shift root new-tail (meta this)))
         (new Vec am cnt shift (.doAssoc this shift root i val) tail (meta this)))
     (= i cnt) (.cons this val)
     :else (throw (IndexOutOfBoundsException.))))
  clojure.lang.Reversible
  (rseq [this]
        (if (&gt; (.count this) 0)
          (clojure.lang.APersistentVector$RSeq. this (dec (.count this)))
          nil))
  clojure.lang.Associative
  (assoc [this k v]
    (if (clojure.lang.Util/isInteger k)
      (.assocN this k v)
      (throw (IllegalArgumentException. &quot;Key must be integer&quot;))))
  (containsKey [this k]
    (and (clojure.lang.Util/isInteger k)
         (&lt;= 0 (int k))
         (&lt; (int k) cnt)))
  (entryAt [this k]
    (if (.containsKey this k)
      (clojure.lang.MapEntry. k (.nth this (int k)))
      nil))
  clojure.lang.ILookup
  (valAt [this k not-found]
    (if (clojure.lang.Util/isInteger k)
      (let [i (int k)]
        (if (and (&gt;= i 0) (&lt; i cnt))
          (.nth this i)
          not-found))
      not-found))
  (valAt [this k] (.valAt this k nil))
  clojure.lang.IFn
  (invoke [this k]
    (if (clojure.lang.Util/isInteger k)
      (let [i (int k)]
        (if (and (&gt;= i 0) (&lt; i cnt))
          (.nth this i)
          (throw (IndexOutOfBoundsException.))))
      (throw (IllegalArgumentException. &quot;Key must be integer&quot;))))
  clojure.lang.Seqable
  (seq [this] 
    (if (zero? cnt) 
      nil
      (VecSeq. am this (.arrayFor this 0) 0 0)))
  clojure.lang.Sequential ;marker, no methods
  clojure.core.IVecImpl
  (tailoff [_] 
    (- cnt (.alength am tail)))
  (arrayFor [this i]
    (if (and  (&lt;= (int 0) i) (&lt; i cnt))
      (if (&gt;= i (.tailoff this))
        tail
        (loop [node root level shift]
          (if (zero? level)
            (.arr node)
            (recur (aget ^objects (.arr node) (bit-and (bit-shift-right i level) (int 0x1f))) 
                   (- level (int 5))))))
      (throw (IndexOutOfBoundsException.))))
  (pushTail [this level parent tailnode]
    (let [subidx (bit-and (bit-shift-right (dec cnt) level) (int 0x1f))
          parent ^clojure.core.VecNode parent
          ret (VecNode. (.edit parent) (aclone ^objects (.arr parent)))
          node-to-insert (if (= level (int 5))
                           tailnode
                           (let [child (aget ^objects (.arr parent) subidx)]
                             (if child
                               (.pushTail this (- level (int 5)) child tailnode)
                               (.newPath this (.edit root) (- level (int 5)) tailnode))))]
      (aset ^objects (.arr ret) subidx node-to-insert)
      ret))
  (popTail [this level node]
    (let [node ^clojure.core.VecNode node
          subidx (bit-and (bit-shift-right (- cnt (int 2)) level) (int 0x1f))]
      (cond
       (&gt; level 5) 
         (let [new-child (.popTail this (- level 5) (aget ^objects (.arr node) subidx))]
           (if (and (nil? new-child) (zero? subidx))
             nil
             (let [arr (aclone ^objects (.arr node))]
               (aset arr subidx new-child)
               (VecNode. (.edit root) arr))))
       (zero? subidx) nil
       :else (let [arr (aclone ^objects (.arr node))]
               (aset arr subidx nil)
               (VecNode. (.edit root) arr)))))
  (newPath [this edit ^int level node]
    (if (zero? level)
      node
      (let [ret (VecNode. edit (object-array 32))]
        (aset ^objects (.arr ret) 0 (.newPath this edit (- level (int 5)) node))
        ret)))
  (doAssoc [this level node i val]
    (let [node ^clojure.core.VecNode node]       
      (if (zero? level)
        ;on this branch, array will need val type
        (let [arr (.aclone am (.arr node))]
          (.aset am arr (bit-and i (int 0x1f)) val)
          (VecNode. (.edit node) arr))
        (let [arr (aclone ^objects (.arr node))
              subidx (bit-and (bit-shift-right i level) (int 0x1f))]
          (aset arr subidx (.doAssoc this (- level (int 5)) (aget arr subidx) i val))
          (VecNode. (.edit node) arr)))))
  java.lang.Comparable
  (compareTo [this o]
    (if (identical? this o)
      0
      (let [#^clojure.lang.IPersistentVector v (cast clojure.lang.IPersistentVector o)
            vcnt (.count v)]
        (cond
          (&lt; cnt vcnt) -1
          (&gt; cnt vcnt) 1
          :else
            (loop [i (int 0)]
              (if (= i cnt)
                0
                (let [comp (clojure.lang.Util/compare (.nth this i) (.nth v i))]
                  (if (= 0 comp)
                    (recur (inc i))
                    comp))))))))
  java.lang.Iterable
  (iterator [this]
    (let [i (java.util.concurrent.atomic.AtomicInteger. 0)]
      (reify java.util.Iterator
        (hasNext [_] (&lt; (.get i) cnt))
        (next [_] (.nth this (dec (.incrementAndGet i))))
        (remove [_] (throw (UnsupportedOperationException.))))))
  java.util.Collection
  (contains [this o] (boolean (some #(= % o) this)))
  (containsAll [this c] (every? #(.contains this %) c))
  (isEmpty [_] (zero? cnt))
  (toArray [this] (into-array Object this))
  (toArray [this arr]
    (if (&gt;= (count arr) cnt)
      (do
        (dotimes [i cnt]
          (aset arr i (.nth this i)))
        arr)
      (into-array Object this)))
  (size [_] cnt)
  (add [_ o] (throw (UnsupportedOperationException.)))
  (addAll [_ c] (throw (UnsupportedOperationException.)))
  (clear [_] (throw (UnsupportedOperationException.)))
  (^boolean remove [_ o] (throw (UnsupportedOperationException.)))
  (removeAll [_ c] (throw (UnsupportedOperationException.)))
  (retainAll [_ c] (throw (UnsupportedOperationException.)))
  java.util.List
  (get [this i] (.nth this i))
  (indexOf [this o]
    (loop [i (int 0)]
      (cond
        (== i cnt) -1
        (= o (.nth this i)) i
        :else (recur (inc i)))))
  (lastIndexOf [this o]
    (loop [i (dec cnt)]
      (cond
        (&lt; i 0) -1
        (= o (.nth this i)) i
        :else (recur (dec i)))))
  (listIterator [this] (.listIterator this 0))
  (listIterator [this i]
    (let [i (java.util.concurrent.atomic.AtomicInteger. i)]
      (reify java.util.ListIterator
        (hasNext [_] (&lt; (.get i) cnt))
        (hasPrevious [_] (pos? i))
        (next [_] (.nth this (dec (.incrementAndGet i))))
        (nextIndex [_] (.get i))
        (previous [_] (.nth this (.decrementAndGet i)))
        (previousIndex [_] (dec (.get i)))
        (add [_ e] (throw (UnsupportedOperationException.)))
        (remove [_] (throw (UnsupportedOperationException.)))
        (set [_ e] (throw (UnsupportedOperationException.))))))
  (subList [this a z] (subvec this a z))
  (add [_ i o] (throw (UnsupportedOperationException.)))
  (addAll [_ i c] (throw (UnsupportedOperationException.)))
  (^Object remove [_ ^int i] (throw (UnsupportedOperationException.)))
  (set [_ i e] (throw (UnsupportedOperationException.))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method ::Vec [v w]
  ((get (methods print-method) clojure.lang.IPersistentVector) v w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro mk-am {:private true} [t]
  (let [garr (gensym)
        tgarr (with-meta garr {:tag (symbol (str t &quot;s&quot;))})]
    `(reify clojure.core.ArrayManager
            (array [_ size#] (~(symbol (str t &quot;-array&quot;)) size#))
            (alength [_ ~garr] (alength ~tgarr))
            (aclone [_ ~garr] (aclone ~tgarr))
            (aget [_ ~garr i#] (aget ~tgarr i#))
            (aset [_ ~garr i# val#] (aset ~tgarr i# (~t val#))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} ams
     {:int (mk-am int)
      :long (mk-am long)
      :float (mk-am float)
      :double (mk-am double)
      :byte (mk-am byte)
      :short (mk-am short)
      :char (mk-am char)
      :boolean (mk-am boolean)})</pre></td></tr><tr><td class="docs"><p>Creates a new vector of a single primitive type t, where t is one
  of :int :long :float :double :byte :short :char or :boolean. The
  resulting vector complies with the interface of vectors in general,
  but stores the values unboxed internally.</p>

<p>  Optionally takes one or more elements to populate the vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn vector-of 
  {:added &quot;1.2&quot;
   :arglists '([t] [t &amp; elements])}
  ([t]
   (let [am ^clojure.core.ArrayManager (ams t)]
     (Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))
  ([t x1]
   (let [am ^clojure.core.ArrayManager (ams t)
         arr (.array am 1)]
     (.aset am arr 0 x1)
     (Vec. am 1 5 EMPTY-NODE arr nil)))
  ([t x1 x2]
   (let [am ^clojure.core.ArrayManager (ams t)
         arr (.array am 2)]
     (.aset am arr 0 x1)
     (.aset am arr 1 x2)
     (Vec. am 2 5 EMPTY-NODE arr nil)))
  ([t x1 x2 x3]
   (let [am ^clojure.core.ArrayManager (ams t)
         arr (.array am 3)]
     (.aset am arr 0 x1)
     (.aset am arr 1 x2)
     (.aset am arr 2 x3)
     (Vec. am 3 5 EMPTY-NODE arr nil)))
  ([t x1 x2 x3 x4]
   (let [am ^clojure.core.ArrayManager (ams t)
         arr (.array am 4)]
     (.aset am arr 0 x1)
     (.aset am arr 1 x2)
     (.aset am arr 2 x3)
     (.aset am arr 3 x4)
     (Vec. am 4 5 EMPTY-NODE arr nil)))
  ([t x1 x2 x3 x4 &amp; xn]
   (loop [v  (vector-of t x1 x2 x3 x4)
          xn xn]
     (if xn
       (recur (.cons v (first xn)) (next xn))
       v))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.inspector" name="clojure.inspector"><h1 class="project-name">clojure.inspector</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Graphical object inspector for Clojure data structures.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
    clojure.inspector
    (:import
     (java.awt BorderLayout)
     (java.awt.event ActionEvent ActionListener)
     (javax.swing.tree TreeModel)
     (javax.swing.table TableModel AbstractTableModel)
     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn atom? [x]
  (not (coll? x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn collection-tag [x]
  (cond 
   (instance? java.util.Map$Entry x) :entry
   (instance? java.util.Map x) :map
   (sequential? x) :seq
   :else :atom))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti is-leaf collection-tag)
(defmulti get-child (fn [parent index] (collection-tag parent)))
(defmulti get-child-count collection-tag)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod is-leaf :default [node]
  (atom? node))
(defmethod get-child :default [parent index]
  (nth parent index))
(defmethod get-child-count :default [parent]
  (count parent))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod is-leaf :entry [e]
  (is-leaf (val e)))
(defmethod get-child :entry [e index]
  (get-child (val e) index))
(defmethod get-child-count :entry [e]
  (count (val e)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod is-leaf :map [m]
  false)
(defmethod get-child :map [m index]
  (nth (seq m) index))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tree-model [data]
  (proxy [TreeModel] []
    (getRoot [] data)
    (addTreeModelListener [treeModelListener])
    (getChild [parent index]
      (get-child parent index))
    (getChildCount [parent]
       (get-child-count parent))
    (isLeaf [node]
      (is-leaf node))
    (valueForPathChanged [path newValue])
    (getIndexOfChild [parent child]
      -1)
    (removeTreeModelListener [treeModelListener])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn old-table-model [data]
  (let [row1 (first data)
	colcnt (count row1)
	cnt (count data)
	vals (if (map? row1) vals identity)]
    (proxy [TableModel] []
      (addTableModelListener [tableModelListener])
      (getColumnClass [columnIndex] Object)
      (getColumnCount [] colcnt)
      (getColumnName [columnIndex]
	(if (map? row1)
	  (name (nth (keys row1) columnIndex))
	  (str columnIndex)))
      (getRowCount [] cnt)
      (getValueAt [rowIndex columnIndex]
	(nth (vals (nth data rowIndex)) columnIndex))
      (isCellEditable [rowIndex columnIndex] false)
      (removeTableModelListener [tableModelListener]))))</pre></td></tr><tr><td class="docs"><p>creates a graphical (Swing) inspector on the supplied hierarchical data</p>
</td><td class="codes"><pre class="brush: clojure">(defn inspect-tree 
  {:added &quot;1.0&quot;}
  [data]
  (doto (JFrame. &quot;Clojure Inspector&quot;)
    (.add (JScrollPane. (JTree. (tree-model data))))
    (.setSize 400 600)
    (.setVisible true)))</pre></td></tr><tr><td class="docs"><p>creates a graphical (Swing) inspector on the supplied regular
  data, which must be a sequential data structure of data structures
  of equal length</p>
</td><td class="codes"><pre class="brush: clojure">(defn inspect-table 
  {:added &quot;1.0&quot;}
    [data]
  (doto (JFrame. &quot;Clojure Inspector&quot;)
    (.add (JScrollPane. (JTable. (old-table-model data))))
    (.setSize 400 600)
    (.setVisible true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti list-provider class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod list-provider :default [x]
  {:nrows 1 :get-value (fn [i] x) :get-label (fn [i] (.getName (class x)))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod list-provider java.util.List [c]
  (let [v (if (vector? c) c (vec c))]
    {:nrows (count v) 
     :get-value (fn [i] (v i)) 
     :get-label (fn [i] i)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod list-provider java.util.Map [c]
  (let [v (vec (sort (map (fn [[k v]] (vector k v)) c)))]
    {:nrows (count v) 
     :get-value (fn [i] ((v i) 1)) 
     :get-label (fn [i] ((v i) 0))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn list-model [provider]
  (let [{:keys [nrows get-value get-label]} provider]
    (proxy [AbstractTableModel] []
      (getColumnCount [] 2)
      (getRowCount [] nrows)
      (getValueAt [rowIndex columnIndex]
        (cond 
         (= 0 columnIndex) (get-label rowIndex)
         (= 1 columnIndex) (print-str (get-value rowIndex)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti table-model class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod table-model :default [x]
  (proxy [AbstractTableModel] []
    (getColumnCount [] 2)
    (getRowCount [] 1)
    (getValueAt [rowIndex columnIndex]
      (if (zero? columnIndex)
        (class x)
        x))))</pre></td></tr><tr><td class="docs"><p>(defn make-inspector [x]
 (agent {:frame frame :data x :parent nil :index 0}))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>creates a graphical (Swing) inspector on the supplied object</p>
</td><td class="codes"><pre class="brush: clojure">(defn inspect
  {:added &quot;1.0&quot;}
  [x]
  (doto (JFrame. &quot;Clojure Inspector&quot;)
    (.add
      (doto (JPanel. (BorderLayout.))
        (.add (doto (JToolBar.)
                (.add (JButton. &quot;Back&quot;))
                (.addSeparator)
                (.add (JButton. &quot;List&quot;))
                (.add (JButton. &quot;Table&quot;))
                (.add (JButton. &quot;Bean&quot;))
                (.add (JButton. &quot;Line&quot;))
                (.add (JButton. &quot;Bar&quot;))
                (.addSeparator)
                (.add (JButton. &quot;Prev&quot;))
                (.add (JButton. &quot;Next&quot;)))
              BorderLayout/NORTH)
        (.add
          (JScrollPane. 
            (doto (JTable. (list-model (list-provider x)))
              (.setAutoResizeMode JTable/AUTO_RESIZE_LAST_COLUMN)))
          BorderLayout/CENTER)))
    (.setSize 400 400)
    (.setVisible true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

(load-file &quot;src/inspector.clj&quot;)
(refer 'inspector)
(inspect-tree {:a 1 :b 2 :c [1 2 3 {:d 4 :e 5 :f [6 7 8]}]})
(inspect-table [[1 2 3][4 5 6][7 8 9][10 11 12]])

)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.instant" name="clojure.instant"><h1 class="project-name">clojure.instant</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns clojure.instant
  (:import [java.util Calendar Date GregorianCalendar TimeZone]
           [java.sql Timestamp]))</pre></td></tr><tr><td class="docs"><p><hr />
convenience macros</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private fail
  [msg]
  `(throw (RuntimeException. ~msg)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:private verify
  ([test msg] `(when-not ~test (fail ~msg)))
  ([test] `(verify ~test ~(str &quot;failed: &quot; (pr-str test)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- divisible?
  [num div]
  (zero? (mod num div)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- indivisible?
  [num div]
  (not (divisible? num div)))</pre></td></tr><tr><td class="docs"><p><hr />
parser implementation</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-int [^String s]
  (Long/parseLong s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- zero-fill-right [^String s width]
  (cond (= width (count s)) s
        (&lt; width (count s)) (.substring s 0 width)
        :else (loop [b (StringBuilder. s)]
                (if (&lt; (.length b) width)
                  (recur (.append b \0))
                  (.toString b)))))</pre></td></tr><tr><td class="docs"><p>Parse a string containing an RFC3339-like like timestamp.</p>

<p>The function new-instant is called with the following arguments.</p>

<pre><code>            min  max           default
            ---  ------------  -------
</code></pre>

<p>  years          0           9999      N/A (s must provide years)
  months         1             12        1
  days           1             31        1 (actual max days depends
  hours          0             23        0  on month and year)
  minutes        0             59        0
  seconds        0             60        0 (though 60 is only valid
  nanoseconds    0      999999999        0  when minutes is 59)
  offset-sign   -1              1        0
  offset-hours   0             23        0
  offset-minutes 0             59        0</p>

<p>These are all integers and will be non-nil. (The listed defaults
will be passed if the corresponding field is not present in s.)</p>

<p>Grammar (of s):</p>

<p>  date-fullyear   = 4DIGIT
  date-month      = 2DIGIT  ; 01-12
  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                            ; month/year
  time-hour       = 2DIGIT  ; 00-23
  time-minute     = 2DIGIT  ; 00-59
  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                            ; rules
  time-secfrac    = '.' 1*DIGIT
  time-numoffset  = ('+' / '-') time-hour ':' time-minute
  time-offset     = 'Z' / time-numoffset</p>

<p>  time-part       = time-hour [ ':' time-minute [ ':' time-second
                    [time-secfrac] [time-offset] ] ]</p>

<p>  timestamp       = date-year [ '-' date-month [ '-' date-mday
                    [ 'T' time-part ] ] ]</p>

<p>Unlike RFC3339:</p>

<ul>
<li>we only parse the timestamp format</li>
<li>timestamp can elide trailing components</li>
<li>time-offset is optional (defaults to +00:00)</li>
</ul>

<p>Though time-offset is syntactically optional, a missing time-offset
will be treated as if the time-offset zero (+00:00) had been
specified.</p>
</td><td class="codes"><pre class="brush: clojure">(def parse-timestamp
     (let [timestamp #&quot;(\d\d\d\d)(?:-(\d\d)(?:-(\d\d)(?:[T](\d\d)(?::(\d\d)(?::(\d\d)(?:[.](\d+))?)?)?)?)?)?(?:[Z]|([-+])(\d\d):(\d\d))?&quot;]
       (fn [new-instant ^CharSequence cs]
         (if-let [[_ years months days hours minutes seconds fraction
                   offset-sign offset-hours offset-minutes]
                  (re-matches timestamp cs)]
           (new-instant
            (parse-int years)
            (if-not months   1 (parse-int months))
            (if-not days     1 (parse-int days))
            (if-not hours    0 (parse-int hours))
            (if-not minutes  0 (parse-int minutes))
            (if-not seconds  0 (parse-int seconds))
            (if-not fraction 0 (parse-int (zero-fill-right fraction 9)))
            (cond (= &quot;-&quot; offset-sign) -1
                  (= &quot;+&quot; offset-sign)  1
                  :else                0)
            (if-not offset-hours   0 (parse-int offset-hours))
            (if-not offset-minutes 0 (parse-int offset-minutes)))
           (fail (str &quot;Unrecognized date/time syntax: &quot; cs))))))</pre></td></tr><tr><td class="docs"><p><hr />
Verification of Extra-Grammatical Restrictions from RFC3339</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- leap-year?
  [year]
  (and (divisible? year 4)
       (or (indivisible? year 100)
           (divisible? year 400))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private days-in-month
     (let [dim-norm [nil 31 28 31 30 31 30 31 31 30 31 30 31]
           dim-leap [nil 31 29 31 30 31 30 31 31 30 31 30 31]]
       (fn [month leap-year?]
         ((if leap-year? dim-leap dim-norm) month))))</pre></td></tr><tr><td class="docs"><p>Return a function which constructs and instant by calling constructor
after first validting that those arguments are in range and otherwise
plausible. The resulting function will throw an exception if called
with invalid arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn validated
  [new-instance]
  (fn [years months days hours minutes seconds nanoseconds
       offset-sign offset-hours offset-minutes]
    (verify (&lt;= 1 months 12))
    (verify (&lt;= 1 days (days-in-month months (leap-year? years))))
    (verify (&lt;= 0 hours 23))
    (verify (&lt;= 0 minutes 59))
    (verify (&lt;= 0 seconds (if (= minutes 59) 60 59)))
    (verify (&lt;= 0 nanoseconds 999999999))
    (verify (&lt;= -1 offset-sign 1))
    (verify (&lt;= 0 offset-hours 23))
    (verify (&lt;= 0 offset-minutes 59))
    (new-instance years months days hours minutes seconds nanoseconds
                  offset-sign offset-hours offset-minutes)))</pre></td></tr><tr><td class="docs"><p><hr />
print integration</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private thread-local-utc-date-format
  ;; SimpleDateFormat is not thread-safe, so we use a ThreadLocal proxy for access.
  ;; http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335
  (proxy [ThreadLocal] []
    (initialValue []
      (doto (java.text.SimpleDateFormat. &quot;yyyy-MM-dd'T'HH:mm:ss.SSS-00:00&quot;)
        ;; RFC3339 says to use -00:00 when the timezone is unknown (+00:00 implies a known GMT)
        (.setTimeZone (java.util.TimeZone/getTimeZone &quot;GMT&quot;))))))</pre></td></tr><tr><td class="docs"><p>Print a java.util.Date as RFC3339 timestamp, always in UTC.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- print-date
  [^java.util.Date d, ^java.io.Writer w]
  (let [utc-format (.get thread-local-utc-date-format)]
    (.write w &quot;#inst \&quot;&quot;)
    (.write w (.format utc-format d))
    (.write w &quot;\&quot;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.Date
  [^java.util.Date d, ^java.io.Writer w]
  (print-date d w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.Date
  [^java.util.Date d, ^java.io.Writer w]
  (print-date d w))</pre></td></tr><tr><td class="docs"><p>Print a java.util.Calendar as RFC3339 timestamp, preserving timezone.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- print-calendar
  [^java.util.Calendar c, ^java.io.Writer w]
  (let [calstr (format &quot;%1$tFT%1$tT.%1$tL%1$tz&quot; c)
        offset-minutes (- (.length calstr) 2)]
    ;; calstr is almost right, but is missing the colon in the offset
    (.write w &quot;#inst \&quot;&quot;)
    (.write w calstr 0 offset-minutes)
    (.write w &quot;:&quot;)
    (.write w calstr offset-minutes 2)
    (.write w &quot;\&quot;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.Calendar
  [^java.util.Calendar c, ^java.io.Writer w]
  (print-calendar c w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.Calendar
  [^java.util.Calendar c, ^java.io.Writer w]
  (print-calendar c w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private thread-local-utc-timestamp-format
  ;; SimpleDateFormat is not thread-safe, so we use a ThreadLocal proxy for access.
  ;; http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335
  (proxy [ThreadLocal] []
    (initialValue []
      (doto (java.text.SimpleDateFormat. &quot;yyyy-MM-dd'T'HH:mm:ss&quot;)
        (.setTimeZone (java.util.TimeZone/getTimeZone &quot;GMT&quot;))))))</pre></td></tr><tr><td class="docs"><p>Print a java.sql.Timestamp as RFC3339 timestamp, always in UTC.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- print-timestamp
  [^java.sql.Timestamp ts, ^java.io.Writer w]
  (let [utc-format (.get thread-local-utc-timestamp-format)]
    (.write w &quot;#inst \&quot;&quot;)
    (.write w (.format utc-format ts))
    ;; add on nanos and offset
    ;; RFC3339 says to use -00:00 when the timezone is unknown (+00:00 implies a known GMT)
    (.write w (format &quot;.%09d-00:00&quot; (.getNanos ts)))
    (.write w &quot;\&quot;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.sql.Timestamp
  [^java.sql.Timestamp ts, ^java.io.Writer w]
  (print-timestamp ts w))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.sql.Timestamp
  [^java.sql.Timestamp ts, ^java.io.Writer w]
  (print-timestamp ts w))</pre></td></tr><tr><td class="docs"><p><hr />
reader integration</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Construct a java.util.Calendar, which preserves, preserving the timezone
offset, but truncating the subsecond fraction to milliseconds.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- construct-calendar
  ^GregorianCalendar
  [years months days hours minutes seconds nanoseconds
   offset-sign offset-hours offset-minutes]
  (doto (GregorianCalendar. years (dec months) days hours minutes seconds)
    (.set Calendar/MILLISECOND (quot nanoseconds 1000000))
    (.setTimeZone (TimeZone/getTimeZone
                   (format &quot;GMT%s%02d:%02d&quot;
                           (if (neg? offset-sign) &quot;-&quot; &quot;+&quot;)
                           offset-hours offset-minutes)))))</pre></td></tr><tr><td class="docs"><p>Construct a java.util.Date, which expresses the original instant as
milliseconds since the epoch, GMT.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- construct-date
  [years months days hours minutes seconds nanoseconds
   offset-sign offset-hours offset-minutes]
  (.getTime (construct-calendar years months days
                                hours minutes seconds nanoseconds
                                offset-sign offset-hours offset-minutes)))</pre></td></tr><tr><td class="docs"><p>Construct a java.sql.Timestamp, which has nanosecond precision.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- construct-timestamp
  [years months days hours minutes seconds nanoseconds
   offset-sign offset-hours offset-minutes]
  (doto (Timestamp.
         (.getTimeInMillis
          (construct-calendar years months days
                              hours minutes seconds 0
                              offset-sign offset-hours offset-minutes)))
    ;; nanos must be set separately, pass 0 above for the base calendar
    (.setNanos nanoseconds)))</pre></td></tr><tr><td class="docs"><p>To read an instant as a java.util.Date, bind <em>data-readers</em> to a map with
this var as the value for the 'inst key. The timezone offset will be used
to convert into UTC.</p>
</td><td class="codes"><pre class="brush: clojure">(def read-instant-date
  (partial parse-timestamp (validated construct-date)))</pre></td></tr><tr><td class="docs"><p>To read an instant as a java.util.Calendar, bind <em>data-readers</em> to a map with
this var as the value for the 'inst key.  Calendar preserves the timezone
offset.</p>
</td><td class="codes"><pre class="brush: clojure">(def read-instant-calendar
  (partial parse-timestamp (validated construct-calendar)))</pre></td></tr><tr><td class="docs"><p>To read an instant as a java.sql.Timestamp, bind <em>data-readers</em> to a
map with this var as the value for the 'inst key. Timestamp preserves
fractional seconds with nanosecond precision. The timezone offset will
be used to convert into UTC.</p>
</td><td class="codes"><pre class="brush: clojure">(def read-instant-timestamp
  (partial parse-timestamp (validated construct-timestamp)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.java.browse" name="clojure.java.browse"><h1 class="project-name">clojure.java.browse</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Start a web browser from Clojure</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Christophe Grand&quot;,
    :doc }
  clojure.java.browse
  (:require [clojure.java.shell :as sh]) 
  (:import (java.net URI)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- macosx? []
  (-&gt; &quot;os.name&quot; System/getProperty .toLowerCase
    (.startsWith &quot;mac os x&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *open-url-script* (when (macosx?) &quot;/usr/bin/open&quot;))</pre></td></tr><tr><td class="docs"><p>Opens url (a string) in the default system web browser.  May not
  work on all platforms.  Returns url on success, nil if not
  supported.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- open-url-in-browser
  [url]
  (try 
    (when (clojure.lang.Reflector/invokeStaticMethod &quot;java.awt.Desktop&quot; 
      &quot;isDesktopSupported&quot; (to-array nil))
      (-&gt; (clojure.lang.Reflector/invokeStaticMethod &quot;java.awt.Desktop&quot; 
            &quot;getDesktop&quot; (to-array nil))
        (.browse (URI. url)))
      url)
    (catch ClassNotFoundException e
      nil)))        </pre></td></tr><tr><td class="docs"><p>Opens url (a string) in a Swing window.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- open-url-in-swing
 [url]
  ; the implementation of this function resides in another namespace to be loaded &quot;on demand&quot;
  ; this fixes a bug on mac os x where the process turns into a GUI app
  ; see http://code.google.com/p/clojure-contrib/issues/detail?id=32
  (require 'clojure.java.browse-ui)
  ((find-var 'clojure.java.browse-ui/open-url-in-swing) url))</pre></td></tr><tr><td class="docs"><p>Open url in a browser</p>
</td><td class="codes"><pre class="brush: clojure">(defn browse-url
  {:added &quot;1.2&quot;}
  [url]
  (or (open-url-in-browser url)
      (when *open-url-script* (sh/sh *open-url-script* (str url)) true)
      (open-url-in-swing url)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.java.browse-ui" name="clojure.java.browse-ui"><h1 class="project-name">clojure.java.browse-ui</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Helper namespace for clojure.java.browse.
            Prevents console apps from becoming GUI unnecessarily.</p>
</td><td class="codes"><pre class="brush: clojure">(ns
    ^{:author &quot;Christophe Grand&quot;,
      :doc }
  clojure.java.browse-ui)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- open-url-in-swing
  [url]
  (let [htmlpane (javax.swing.JEditorPane. url)]
    (.setEditable htmlpane false)
    (.addHyperlinkListener htmlpane
      (proxy [javax.swing.event.HyperlinkListener] []
        (hyperlinkUpdate [#^javax.swing.event.HyperlinkEvent e]
          (when (= (.getEventType e) (. javax.swing.event.HyperlinkEvent$EventType ACTIVATED))
            (if (instance? javax.swing.text.html.HTMLFrameHyperlinkEvent e)
              (-&gt; htmlpane .getDocument (.processHTMLFrameHyperlinkEvent e))
              (.setPage htmlpane (.getURL e)))))))
    (doto (javax.swing.JFrame.)
      (.setContentPane (javax.swing.JScrollPane. htmlpane))
      (.setBounds 32 32 700 900)
      (.show))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.java.io" name="clojure.java.io"><h1 class="project-name">clojure.java.io</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>This file defines polymorphic I/O utility functions for Clojure.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Stuart Sierra, Chas Emerick, Stuart Halloway&quot;,
     :doc }
    clojure.java.io
    (:require clojure.string)
    (:import 
     (java.io Reader InputStream InputStreamReader PushbackReader
              BufferedReader File OutputStream
              OutputStreamWriter BufferedWriter Writer
              FileInputStream FileOutputStream ByteArrayOutputStream
              StringReader ByteArrayInputStream
              BufferedInputStream BufferedOutputStream
              CharArrayReader Closeable)
     (java.net URI URL MalformedURLException Socket)))</pre></td></tr><tr><td class="docs"><p>Type object for a Java primitive byte array.</p>
</td><td class="codes"><pre class="brush: clojure">(def
    ^{:doc 
      :private true
      }
 byte-array-type (class (make-array Byte/TYPE 0)))</pre></td></tr><tr><td class="docs"><p>Type object for a Java primitive char array.</p>
</td><td class="codes"><pre class="brush: clojure">(def
    ^{:doc 
      :private true}
 char-array-type (class (make-array Character/TYPE 0)))</pre></td></tr><tr><td class="docs"><p>Coerce between various 'resource-namish' things.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol ^{:added &quot;1.2&quot;} Coercions
  (^{:tag java.io.File, :added &quot;1.2&quot;} as-file [x] &quot;Coerce argument to a file.&quot;)
  (^{:tag java.net.URL, :added &quot;1.2&quot;} as-url [x] &quot;Coerce argument to a URL.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Coercions
  nil
  (as-file [_] nil)
  (as-url [_] nil)
  
  String
  (as-file [s] (File. s))
  (as-url [s] (URL. s))  
  
  File
  (as-file [f] f)
  (as-url [f] (.toURL (.toURI f)))

  URL
  (as-url [u] u)
  (as-file [u]
    (if (= &quot;file&quot; (.getProtocol u))
      (as-file
        (clojure.string/replace
          (.replace (.getFile u) \/ File/separatorChar)
          #&quot;%..&quot;
          (fn [escape]
            (-&gt; escape
                (.substring 1 3)
                (Integer/parseInt 16)
                (char)
                (str)))))
      (throw (IllegalArgumentException. (str &quot;Not a file: &quot; u)))))

  URI
  (as-url [u] (.toURL u))
  (as-file [u] (as-file (as-url u))))</pre></td></tr><tr><td class="docs"><p>Factory functions that create ready-to-use, buffered versions of
   the various Java I/O stream types, on top of anything that can
   be unequivocally converted to the requested kind of stream.</p>

<p>   Common options include</p>

<pre><code> :append    true to open stream in append mode
 :encoding  string name of encoding to use, e.g. "UTF-8".
</code></pre>

<p>   Callers should generally prefer the higher level API provided by
   reader, writer, input-stream, and output-stream.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol ^{:added &quot;1.2&quot;} IOFactory
  (^{:added &quot;1.2&quot;} make-reader [x opts] &quot;Creates a BufferedReader. See also IOFactory docs.&quot;)
  (^{:added &quot;1.2&quot;} make-writer [x opts] &quot;Creates a BufferedWriter. See also IOFactory docs.&quot;)
  (^{:added &quot;1.2&quot;} make-input-stream [x opts] &quot;Creates a BufferedInputStream. See also IOFactory docs.&quot;)
  (^{:added &quot;1.2&quot;} make-output-stream [x opts] &quot;Creates a BufferedOutputStream. See also IOFactory docs.&quot;))</pre></td></tr><tr><td class="docs"><p>Attempts to coerce its argument into an open java.io.Reader.
   Default implementations always return a java.io.BufferedReader.</p>

<p>   Default implementations are provided for Reader, BufferedReader,
   InputStream, File, URI, URL, Socket, byte arrays, character arrays,
   and String.</p>

<p>   If argument is a String, it tries to resolve it first as a URI, then
   as a local file name.  URIs with a 'file' protocol are converted to
   local file names.</p>

<p>   Should be used inside with-open to ensure the Reader is properly
   closed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^Reader reader
  {:added &quot;1.2&quot;}
  [x &amp; opts]
  (make-reader x (when opts (apply hash-map opts))))</pre></td></tr><tr><td class="docs"><p>Attempts to coerce its argument into an open java.io.Writer.
   Default implementations always return a java.io.BufferedWriter.</p>

<p>   Default implementations are provided for Writer, BufferedWriter,
   OutputStream, File, URI, URL, Socket, and String.</p>

<p>   If the argument is a String, it tries to resolve it first as a URI, then
   as a local file name.  URIs with a 'file' protocol are converted to
   local file names.</p>

<p>   Should be used inside with-open to ensure the Writer is properly
   closed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^Writer writer
  {:added &quot;1.2&quot;}
  [x &amp; opts]
  (make-writer x (when opts (apply hash-map opts))))</pre></td></tr><tr><td class="docs"><p>Attempts to coerce its argument into an open java.io.InputStream.
   Default implementations always return a java.io.BufferedInputStream.</p>

<p>   Default implementations are defined for OutputStream, File, URI, URL,
   Socket, byte array, and String arguments.</p>

<p>   If the argument is a String, it tries to resolve it first as a URI, then
   as a local file name.  URIs with a 'file' protocol are converted to
   local file names.</p>

<p>   Should be used inside with-open to ensure the InputStream is properly
   closed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^InputStream input-stream
  {:added &quot;1.2&quot;}
  [x &amp; opts]
  (make-input-stream x (when opts (apply hash-map opts))))</pre></td></tr><tr><td class="docs"><p>Attempts to coerce its argument into an open java.io.OutputStream.
   Default implementations always return a java.io.BufferedOutputStream.</p>

<p>   Default implementations are defined for OutputStream, File, URI, URL,
   Socket, and String arguments.</p>

<p>   If the argument is a String, it tries to resolve it first as a URI, then
   as a local file name.  URIs with a 'file' protocol are converted to
   local file names.</p>

<p>   Should be used inside with-open to ensure the OutputStream is
   properly closed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^OutputStream output-stream
  {:added &quot;1.2&quot;}
  [x &amp; opts]
  (make-output-stream x (when opts (apply hash-map opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ^Boolean append? [opts]
  (boolean (:append opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ^String encoding [opts]
  (or (:encoding opts) &quot;UTF-8&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- buffer-size [opts]
  (or (:buffer-size opts) 1024))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-streams-impl
  {:make-reader (fn [x opts] (make-reader (make-input-stream x opts) opts))
   :make-writer (fn [x opts] (make-writer (make-output-stream x opts) opts))
   :make-input-stream (fn [x opts]
                        (throw (IllegalArgumentException.
                                (str &quot;Cannot open &lt;&quot; (pr-str x) &quot;&gt; as an InputStream.&quot;))))
   :make-output-stream (fn [x opts]
                         (throw (IllegalArgumentException.
                                 (str &quot;Cannot open &lt;&quot; (pr-str x) &quot;&gt; as an OutputStream.&quot;))))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- inputstream-&gt;reader
  [^InputStream is opts]
  (make-reader (InputStreamReader. is (encoding opts)) opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- outputstream-&gt;writer
  [^OutputStream os opts]
  (make-writer (OutputStreamWriter. os (encoding opts)) opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend BufferedInputStream
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [x opts] x)
    :make-reader inputstream-&gt;reader))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend InputStream
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [x opts] (BufferedInputStream. x))
    :make-reader inputstream-&gt;reader))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend Reader
  IOFactory
  (assoc default-streams-impl
    :make-reader (fn [x opts] (BufferedReader. x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend BufferedReader
  IOFactory
  (assoc default-streams-impl
    :make-reader (fn [x opts] x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend Writer
  IOFactory
  (assoc default-streams-impl
    :make-writer (fn [x opts] (BufferedWriter. x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend BufferedWriter
  IOFactory
  (assoc default-streams-impl
    :make-writer (fn [x opts] x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend OutputStream
  IOFactory
  (assoc default-streams-impl
    :make-output-stream (fn [x opts] (BufferedOutputStream. x))
    :make-writer outputstream-&gt;writer))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend BufferedOutputStream
  IOFactory
  (assoc default-streams-impl
    :make-output-stream (fn [x opts] x)
    :make-writer outputstream-&gt;writer))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend File
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [^File x opts] (make-input-stream (FileInputStream. x) opts))
    :make-output-stream (fn [^File x opts] (make-output-stream (FileOutputStream. x (append? opts)) opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend URL
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [^URL x opts]
                         (make-input-stream
                          (if (= &quot;file&quot; (.getProtocol x))
                            (FileInputStream. (as-file x))
                            (.openStream x)) opts))
    :make-output-stream (fn [^URL x opts]
                          (if (= &quot;file&quot; (.getProtocol x))
                            (make-output-stream (as-file x) opts)
                            (throw (IllegalArgumentException. (str &quot;Can not write to non-file URL &lt;&quot; x &quot;&gt;&quot;)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend URI
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [^URI x opts] (make-input-stream (.toURL x) opts))
    :make-output-stream (fn [^URI x opts] (make-output-stream (.toURL x) opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend String
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [^String x opts]
                         (try
                          (make-input-stream (URL. x) opts)
                          (catch MalformedURLException e
                            (make-input-stream (File. x) opts))))
    :make-output-stream (fn [^String x opts]
                          (try
                           (make-output-stream (URL. x) opts)
                           (catch MalformedURLException err
                             (make-output-stream (File. x) opts))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend Socket
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [^Socket x opts] (make-input-stream (.getInputStream x) opts))
    :make-output-stream (fn [^Socket x opts] (make-output-stream (.getOutputStream x) opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend byte-array-type
  IOFactory
  (assoc default-streams-impl
    :make-input-stream (fn [x opts] (make-input-stream (ByteArrayInputStream. x) opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend char-array-type
  IOFactory
  (assoc default-streams-impl
    :make-reader (fn [x opts] (make-reader (CharArrayReader. x) opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend Object
  IOFactory
  default-streams-impl)</pre></td></tr><tr><td class="docs"><p>Internal helper for copy</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti
  #^{:doc 
     :private true
     :arglists '([input output opts])}
  do-copy
  (fn [input output opts] [(type input) (type output)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [InputStream OutputStream] [#^InputStream input #^OutputStream output opts]
  (let [buffer (make-array Byte/TYPE (buffer-size opts))]
    (loop []
      (let [size (.read input buffer)]
        (when (pos? size)
          (do (.write output buffer 0 size)
              (recur)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [InputStream Writer] [#^InputStream input #^Writer output opts]
  (let [#^&quot;[C&quot; buffer (make-array Character/TYPE (buffer-size opts))
        in (InputStreamReader. input (encoding opts))]
    (loop []
      (let [size (.read in buffer 0 (alength buffer))]
        (if (pos? size)
          (do (.write output buffer 0 size)
              (recur)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [InputStream File] [#^InputStream input #^File output opts]
  (with-open [out (FileOutputStream. output)]
    (do-copy input out opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [Reader OutputStream] [#^Reader input #^OutputStream output opts]
  (let [#^&quot;[C&quot; buffer (make-array Character/TYPE (buffer-size opts))
        out (OutputStreamWriter. output (encoding opts))]
    (loop []
      (let [size (.read input buffer)]
        (if (pos? size)
          (do
            (.write out buffer 0 size)
            (recur))
          (.flush out))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [Reader Writer] [#^Reader input #^Writer output opts]
  (let [#^&quot;[C&quot; buffer (make-array Character/TYPE (buffer-size opts))]
    (loop []
      (let [size (.read input buffer)]
        (when (pos? size)
          (do (.write output buffer 0 size)
              (recur)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [Reader File] [#^Reader input #^File output opts]
  (with-open [out (FileOutputStream. output)]
    (do-copy input out opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [File OutputStream] [#^File input #^OutputStream output opts]
  (with-open [in (FileInputStream. input)]
    (do-copy in output opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [File Writer] [#^File input #^Writer output opts]
  (with-open [in (FileInputStream. input)]
    (do-copy in output opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [File File] [#^File input #^File output opts]
  (with-open [in (FileInputStream. input)
              out (FileOutputStream. output)]
    (do-copy in out opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [String OutputStream] [#^String input #^OutputStream output opts]
  (do-copy (StringReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [String Writer] [#^String input #^Writer output opts]
  (do-copy (StringReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [String File] [#^String input #^File output opts]
  (do-copy (StringReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [char-array-type OutputStream] [input #^OutputStream output opts]
  (do-copy (CharArrayReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [char-array-type Writer] [input #^Writer output opts]
  (do-copy (CharArrayReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [char-array-type File] [input #^File output opts]
  (do-copy (CharArrayReader. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [byte-array-type OutputStream] [#^&quot;[B&quot; input #^OutputStream output opts]
  (do-copy (ByteArrayInputStream. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [byte-array-type Writer] [#^&quot;[B&quot; input #^Writer output opts]
  (do-copy (ByteArrayInputStream. input) output opts))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod do-copy [byte-array-type File] [#^&quot;[B&quot; input #^Writer output opts]
  (do-copy (ByteArrayInputStream. input) output opts))</pre></td></tr><tr><td class="docs"><p>Copies input to output.  Returns nil or throws IOException.
  Input may be an InputStream, Reader, File, byte[], or String.
  Output may be an OutputStream, Writer, or File.</p>

<p>  Options are key/value pairs and may be one of</p>

<pre><code>:buffer-size  buffer size to use, default is 1024.
:encoding     encoding to use if converting between
              byte and char streams.
</code></pre>

<p>  Does not close any streams except those it opens itself 
  (on a File).</p>
</td><td class="codes"><pre class="brush: clojure">(defn copy
  {:added &quot;1.2&quot;}
  [input output &amp; opts]
  (do-copy input output (when opts (apply hash-map opts))))</pre></td></tr><tr><td class="docs"><p>Take an as-file-able thing and return a string if it is
   a relative path, else IllegalArgumentException.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String as-relative-path
  {:added &quot;1.2&quot;}
  [x]
  (let [^File f (as-file x)]
    (if (.isAbsolute f)
      (throw (IllegalArgumentException. (str f &quot; is not a relative path&quot;)))
      (.getPath f))))</pre></td></tr><tr><td class="docs"><p>Returns a java.io.File, passing each arg to as-file.  Multiple-arg
   versions treat the first argument as parent and subsequent args as
   children relative to the parent.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^File file
  {:added &quot;1.2&quot;}
  ([arg]                      
     (as-file arg))
  ([parent child]             
     (File. ^File (as-file parent) ^String (as-relative-path child)))
  ([parent child &amp; more]
     (reduce file (file parent child) more)))</pre></td></tr><tr><td class="docs"><p>Delete file f. Raise an exception if it fails unless silently is true.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delete-file
  {:added &quot;1.2&quot;}
  [f &amp; [silently]]
  (or (.delete (file f))
      silently
      (throw (java.io.IOException. (str &quot;Couldn't delete &quot; f)))))</pre></td></tr><tr><td class="docs"><p>Given the same arg(s) as for file, creates all parent directories of
   the file they represent.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-parents
  {:added &quot;1.2&quot;}
  [f &amp; more]
  (when-let [parent (.getParentFile ^File (apply file f more))]
    (.mkdirs parent)))</pre></td></tr><tr><td class="docs"><p>Returns the URL for a named resource. Use the context class loader
   if no loader is specified.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^URL resource
  {:added &quot;1.2&quot;}
  ([n] (resource n (.getContextClassLoader (Thread/currentThread))))
  ([n ^ClassLoader loader] (.getResource loader n)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.java.javadoc" name="clojure.java.javadoc"><h1 class="project-name">clojure.java.javadoc</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A repl helper to quickly open javadocs.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Christophe Grand, Stuart Sierra&quot;,
     :doc }
  clojure.java.javadoc
  (:use [clojure.java.browse :only (browse-url)] )
  (:import
   (java.io File)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *feeling-lucky-url* &quot;http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&amp;q=allinurl:&quot;)
(def ^:dynamic *feeling-lucky* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *local-javadocs* (ref (list)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *core-java-api*
  (case (System/getProperty &quot;java.specification.version&quot;)
    &quot;1.5&quot; &quot;http://java.sun.com/j2se/1.5.0/docs/api/&quot;
    &quot;1.6&quot; &quot;http://java.sun.com/javase/6/docs/api/&quot;
    &quot;http://java.sun.com/javase/7/docs/api/&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *remote-javadocs*
 (ref (sorted-map
       &quot;java.&quot; *core-java-api*
       &quot;javax.&quot; *core-java-api*
       &quot;org.ietf.jgss.&quot; *core-java-api*
       &quot;org.omg.&quot; *core-java-api*
       &quot;org.w3c.dom.&quot; *core-java-api*
       &quot;org.xml.sax.&quot; *core-java-api*
       &quot;org.apache.commons.codec.&quot; &quot;http://commons.apache.org/codec/api-release/&quot;
       &quot;org.apache.commons.io.&quot; &quot;http://commons.apache.org/io/api-release/&quot;
       &quot;org.apache.commons.lang.&quot; &quot;http://commons.apache.org/lang/api-release/&quot;)))</pre></td></tr><tr><td class="docs"><p>Adds to the list of local Javadoc paths.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-local-javadoc
  {:added &quot;1.2&quot;}
  [path]
  (dosync (commute *local-javadocs* conj path)))</pre></td></tr><tr><td class="docs"><p>Adds to the list of remote Javadoc URLs.  package-prefix is the
  beginning of the package name that has docs at this URL.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-remote-javadoc
  {:added &quot;1.2&quot;}
  [package-prefix url]
  (dosync (commute *remote-javadocs* assoc package-prefix url)))</pre></td></tr><tr><td class="docs"><p>Searches for a URL for the given class name.  Tries
  <em>local-javadocs</em> first, then <em>remote-javadocs</em>.  Returns a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- javadoc-url
  {:tag String,
   :added &quot;1.2&quot;}
  [^String classname]
  (let [file-path (.replace classname \. File/separatorChar)
        url-path (.replace classname \. \/)]
    (if-let [file ^File (first
                           (filter #(.exists ^File %)
                             (map #(File. (str %) (str file-path &quot;.html&quot;))
                               @*local-javadocs*)))]
      (-&gt; file .toURI str)
      ;; If no local file, try remote URLs:
      (or (some (fn [[prefix url]]
                  (when (.startsWith classname prefix)
                    (str url url-path &quot;.html&quot;)))
            @*remote-javadocs*)
        ;; if *feeling-lucky* try a web search
        (when *feeling-lucky* (str *feeling-lucky-url* url-path &quot;.html&quot;))))))</pre></td></tr><tr><td class="docs"><p>Opens a browser window displaying the javadoc for the argument.
  Tries <em>local-javadocs</em> first, then <em>remote-javadocs</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn javadoc
  {:added &quot;1.2&quot;}
  [class-or-object]
  (let [^Class c (if (instance? Class class-or-object) 
                    class-or-object 
                    (class class-or-object))]
    (if-let [url (javadoc-url (.getName c))]
      (browse-url url)
      (println &quot;Could not find Javadoc for&quot; c))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.java.shell" name="clojure.java.shell"><h1 class="project-name">clojure.java.shell</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Conveniently launch a sub-process providing its stdin and
collecting its stdout</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Chris Houser, Stuart Halloway&quot;,
    :doc }
  clojure.java.shell
  (:use [clojure.java.io :only (as-file copy)])
  (:import (java.io ByteArrayOutputStream StringWriter)
           (java.nio.charset Charset)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *sh-dir* nil)
(def ^:dynamic *sh-env* nil)</pre></td></tr><tr><td class="docs"><p>Sets the directory for use with sh, see sh for details.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-sh-dir
  {:added &quot;1.2&quot;}
  [dir &amp; forms]
  `(binding [*sh-dir* ~dir]
     ~@forms))</pre></td></tr><tr><td class="docs"><p>Sets the environment for use with sh, see sh for details.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-sh-env
  {:added &quot;1.2&quot;}
  [env &amp; forms]
  `(binding [*sh-env* ~env]
     ~@forms))</pre></td></tr><tr><td class="docs"><p>Concatenates arrays of given type.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- aconcat
  [type &amp; xs]
  (let [target (make-array type (apply + (map count xs)))]
    (loop [i 0 idx 0]
      (when-let [a (nth xs i nil)]
        (System/arraycopy a 0 target idx (count a))
        (recur (inc i) (+ idx (count a)))))
    target))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-args
  [args]
  (let [default-encoding &quot;UTF-8&quot; ;; see sh doc string
        default-opts {:out-enc default-encoding :in-enc default-encoding :dir *sh-dir* :env *sh-env*}
        [cmd opts] (split-with string? args)]
    [cmd (merge default-opts (apply hash-map opts))]))</pre></td></tr><tr><td class="docs"><p>Helper so that callers can pass a Clojure map for the :env to sh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ^&quot;[Ljava.lang.String;&quot; as-env-strings 
  [arg]
  (cond
   (nil? arg) nil
   (map? arg) (into-array String (map (fn [[k v]] (str (name k) &quot;=&quot; v)) arg))
   true arg))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- stream-to-bytes
  [in]
  (with-open [bout (ByteArrayOutputStream.)]
    (copy in bout)
    (.toByteArray bout)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- stream-to-string
  ([in] (stream-to-string in (.name (Charset/defaultCharset))))
  ([in enc]
     (with-open [bout (StringWriter.)]
       (copy in bout :encoding enc)
       (.toString bout))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- stream-to-enc
  [stream enc]
  (if (= enc :bytes)
    (stream-to-bytes stream)
    (stream-to-string stream enc)))</pre></td></tr><tr><td class="docs"><p>Passes the given strings to Runtime.exec() to launch a sub-process.</p>

<p>  Options are</p>

<p>  :in      may be given followed by any legal input source for
           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],
           or String, to be fed to the sub-process's stdin.
  :in-enc  option may be given followed by a String, used as a character
           encoding name (for example "UTF-8" or "ISO-8859-1") to
           convert the input string specified by the :in option to the
           sub-process's stdin.  Defaults to UTF-8.
           If the :in option provides a byte array, then the bytes are passed
           unencoded, and this option is ignored.
  :out-enc option may be given followed by :bytes or a String. If a
           String is given, it will be used as a character encoding
           name (for example "UTF-8" or "ISO-8859-1") to convert
           the sub-process's stdout to a String which is returned.
           If :bytes is given, the sub-process's stdout will be stored
           in a byte array and returned.  Defaults to UTF-8.
  :env     override the process env with a map (or the underlying Java
           String[] if you are a masochist).
  :dir     override the process dir with a String or java.io.File.</p>

<p>  You can bind :env or :dir for multiple operations using with-sh-env
  and with-sh-dir.</p>

<p>  sh returns a map of
    :exit => sub-process's exit code
    :out  => sub-process's stdout (as byte[] or String)
    :err  => sub-process's stderr (String via platform default encoding)</p>
</td><td class="codes"><pre class="brush: clojure">(defn sh
  {:added &quot;1.2&quot;}
  [&amp; args]
  (let [[cmd opts] (parse-args args)
        proc (.exec (Runtime/getRuntime) 
               ^&quot;[Ljava.lang.String;&quot; (into-array cmd)
               (as-env-strings (:env opts))
               (as-file (:dir opts)))
        {:keys [in in-enc out-enc]} opts]
    (if in
      (future
        (with-open [os (.getOutputStream proc)]
          (copy in os :encoding in-enc)))
      (.close (.getOutputStream proc)))
    (with-open [stdout (.getInputStream proc)
                stderr (.getErrorStream proc)]
      (let [out (future (stream-to-enc stdout out-enc))
            err (future (stream-to-string stderr))
            exit-code (.waitFor proc)]
        {:exit exit-code :out @out :err @err}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

(println (sh &quot;ls&quot; &quot;-l&quot;))
(println (sh &quot;ls&quot; &quot;-l&quot; &quot;/no-such-thing&quot;))
(println (sh &quot;sed&quot; &quot;s/[aeiou]/oo/g&quot; :in &quot;hello there\n&quot;))
(println (sh &quot;sed&quot; &quot;s/[aeiou]/oo/g&quot; :in (java.io.StringReader. &quot;hello there\n&quot;)))
(println (sh &quot;cat&quot; :in &quot;x\u25bax\n&quot;))
(println (sh &quot;echo&quot; &quot;x\u25bax&quot;))
(println (sh &quot;echo&quot; &quot;x\u25bax&quot; :out-enc &quot;ISO-8859-1&quot;)) ; reads 4 single-byte chars
(println (sh &quot;cat&quot; &quot;myimage.png&quot; :out-enc :bytes)) ; reads binary file into bytes[]
(println (sh &quot;cmd&quot; &quot;/c dir 1&gt;&amp;2&quot;))

)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.main" name="clojure.main"><h1 class="project-name">clojure.main</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Copyright (c) Rich Hickey All rights reserved. The use and
distribution terms for this software are covered by the Eclipse Public
License 1.0 (http://opensource.org/licenses/eclipse-1.0.php) which can be found
in the file epl-v10.html at the root of this distribution. By using this
software in any fashion, you are agreeing to be bound by the terms of
this license. You must not remove this notice, or any other, from this
software.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Originally contributed by Stephen C. Gilardi</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Top-level main function for Clojure REPL and scripts.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Stephen C. Gilardi and Rich Hickey&quot;}
  clojure.main
  (:refer-clojure :exclude [with-bindings])
  (:import (clojure.lang Compiler Compiler$CompilerException
                         LineNumberingPushbackReader RT))
  ;;(:use [clojure.repl :only (demunge root-cause stack-element-str)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare main)</pre></td></tr><tr><td class="docs"><p>redundantly copied from clojure.repl to avoid dep ;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">#_(defn root-cause [x] x)
#_(defn stack-element-str
  &quot;Returns a (possibly unmunged) string representation of a StackTraceElement&quot;
  {:added &quot;1.3&quot;}
  [^StackTraceElement el]
  (.getClassName el))
(def ^:private demunge-map
  (into {&quot;$&quot; &quot;/&quot;} (map (fn [[k v]] [v k]) clojure.lang.Compiler/CHAR_MAP)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private demunge-pattern
  (re-pattern (apply str (interpose &quot;|&quot; (map #(str &quot;\\Q&quot; % &quot;\\E&quot;)
                                             (keys demunge-map))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- re-replace [re s f]
  (let [m (re-matcher re s)
        mseq (take-while identity
                         (repeatedly #(when (re-find m)
                                        [(re-groups m) (.start m) (.end m)])))]
    (apply str
           (concat
             (mapcat (fn [[_ _ start] [groups end]]
                       (if end
                         [(subs s start end) (f groups)]
                         [(subs s start)]))
                     (cons [0 0 0] mseq)
                     (concat mseq [nil]))))))</pre></td></tr><tr><td class="docs"><p>Given a string representation of a fn class,
  as in a stack trace element, returns a readable version.</p>
</td><td class="codes"><pre class="brush: clojure">(defn demunge
  {:added &quot;1.3&quot;}
  [fn-name]
  (re-replace demunge-pattern fn-name demunge-map))</pre></td></tr><tr><td class="docs"><p>Returns the initial cause of an exception or error by peeling off all of
  its wrappers</p>
</td><td class="codes"><pre class="brush: clojure">(defn root-cause
  {:added &quot;1.3&quot;}
  [^Throwable t]
  (loop [cause t]
    (if (and (instance? clojure.lang.Compiler$CompilerException cause)
             (not= (.source ^clojure.lang.Compiler$CompilerException cause) &quot;NO_SOURCE_FILE&quot;))
      cause
      (if-let [cause (.getCause cause)]
        (recur cause)
        cause))))</pre></td></tr><tr><td class="docs"><p>Returns a (possibly unmunged) string representation of a StackTraceElement</p>
</td><td class="codes"><pre class="brush: clojure">(defn stack-element-str
  {:added &quot;1.3&quot;}
  [^StackTraceElement el]
  (let [file (.getFileName el)
        clojure-fn? (and file (or (.endsWith file &quot;.clj&quot;)
                                  (= file &quot;NO_SOURCE_FILE&quot;)))]
    (str (if clojure-fn?
           (demunge (.getClassName el))
           (str (.getClassName el) &quot;.&quot; (.getMethodName el)))
         &quot; (&quot; (.getFileName el) &quot;:&quot; (.getLineNumber el) &quot;)&quot;)))</pre></td></tr><tr><td class="docs"><p>end of redundantly copied from clojure.repl to avoid dep ;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Executes body in the context of thread-local bindings for several vars
  that often need to be set!: <em>ns</em> <em>warn-on-reflection</em> <em>math-context</em>
  <em>print-meta</em> <em>print-length</em> <em>print-level</em> <em>compile-path</em>
  <em>command-line-args</em> *1 *2 *3 *e</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-bindings
  [&amp; body]
  `(binding [*ns* *ns*
             *warn-on-reflection* *warn-on-reflection*
             *math-context* *math-context*
             *print-meta* *print-meta*
             *print-length* *print-length*
             *print-level* *print-level*
             *data-readers* *data-readers*
             *compile-path* (System/getProperty &quot;clojure.compile.path&quot; &quot;classes&quot;)
             *command-line-args* *command-line-args*
             *unchecked-math* *unchecked-math*
             *assert* *assert*
             *1 nil
             *2 nil
             *3 nil
             *e nil]
     ~@body))</pre></td></tr><tr><td class="docs"><p>Default :prompt hook for repl</p>
</td><td class="codes"><pre class="brush: clojure">(defn repl-prompt
  []
  (printf &quot;%s=&gt; &quot; (ns-name *ns*)))</pre></td></tr><tr><td class="docs"><p>If the next character on stream s is a newline, skips it, otherwise
  leaves the stream untouched. Returns :line-start, :stream-end, or :body
  to indicate the relative location of the next character on s. The stream
  must either be an instance of LineNumberingPushbackReader or duplicate
  its behavior of both supporting .unread and collapsing all of CR, LF, and
  CRLF to a single \newline.</p>
</td><td class="codes"><pre class="brush: clojure">(defn skip-if-eol
  &quot;If the next character on stream s is a newline, skips it, otherwise
  leaves the stream untouched. Returns :line-start, :stream-end, or :body
  to indicate the relative location of the next character on s. The stream
  must either be an instance of LineNumberingPushbackReader or duplicate
  its behavior of both supporting .unread and collapsing all of CR, LF, and
  CRLF to a single \\newline.&quot;
  [s]
  (let [c (.read s)]
    (cond
     (= c (int \newline)) :line-start
     (= c -1) :stream-end
     :else (do (.unread s c) :body))))</pre></td></tr><tr><td class="docs"><p>Skips whitespace characters on stream s. Returns :line-start, :stream-end,
  or :body to indicate the relative location of the next character on s.
  Interprets comma as whitespace and semicolon as comment to end of line.
  Does not interpret #! as comment to end of line because only one
  character of lookahead is available. The stream must either be an
  instance of LineNumberingPushbackReader or duplicate its behavior of both
  supporting .unread and collapsing all of CR, LF, and CRLF to a single
  \newline.</p>
</td><td class="codes"><pre class="brush: clojure">(defn skip-whitespace
  &quot;Skips whitespace characters on stream s. Returns :line-start, :stream-end,
  or :body to indicate the relative location of the next character on s.
  Interprets comma as whitespace and semicolon as comment to end of line.
  Does not interpret #! as comment to end of line because only one
  character of lookahead is available. The stream must either be an
  instance of LineNumberingPushbackReader or duplicate its behavior of both
  supporting .unread and collapsing all of CR, LF, and CRLF to a single
  \\newline.&quot;
  [s]
  (loop [c (.read s)]
    (cond
     (= c (int \newline)) :line-start
     (= c -1) :stream-end
     (= c (int \;)) (do (.readLine s) :line-start)
     (or (Character/isWhitespace (char c)) (= c (int \,))) (recur (.read s))
     :else (do (.unread s c) :body))))</pre></td></tr><tr><td class="docs"><p>Default :read hook for repl. Reads from <em>in</em> which must either be an
  instance of LineNumberingPushbackReader or duplicate its behavior of both
  supporting .unread and collapsing all of CR, LF, and CRLF into a single
  \newline. repl-read:
    - skips whitespace, then
      - returns request-prompt on start of line, or
      - returns request-exit on end of stream, or
      - reads an object from the input stream, then
        - skips the next input character if it's end of line, then
        - returns the object.</p>
</td><td class="codes"><pre class="brush: clojure">(defn repl-read
  &quot;Default :read hook for repl. Reads from *in* which must either be an
  instance of LineNumberingPushbackReader or duplicate its behavior of both
  supporting .unread and collapsing all of CR, LF, and CRLF into a single
  \\newline. repl-read:
    - skips whitespace, then
      - returns request-prompt on start of line, or
      - returns request-exit on end of stream, or
      - reads an object from the input stream, then
        - skips the next input character if it's end of line, then
        - returns the object.&quot;
  [request-prompt request-exit]
  (or ({:line-start request-prompt :stream-end request-exit}
       (skip-whitespace *in*))
      (let [input (read)]
        (skip-if-eol *in*)
        input)))</pre></td></tr><tr><td class="docs"><p>Returns the root cause of throwables</p>
</td><td class="codes"><pre class="brush: clojure">(defn repl-exception
  [throwable]
  (root-cause throwable))</pre></td></tr><tr><td class="docs"><p>Default :caught hook for repl</p>
</td><td class="codes"><pre class="brush: clojure">(defn repl-caught
  [e]
  (let [ex (repl-exception e)
        tr (.getStackTrace ex)
        el (when-not (zero? (count tr)) (aget tr 0))]
    (binding [*out* *err*]
      (println (str (-&gt; ex class .getSimpleName)
                    &quot; &quot; (.getMessage ex) &quot; &quot;
                    (when-not (instance? clojure.lang.Compiler$CompilerException ex)
                      (str &quot; &quot; (if el (stack-element-str el) &quot;[trace missing]&quot;))))))))</pre></td></tr><tr><td class="docs"><p>Generic, reusable, read-eval-print loop. By default, reads from <em>in</em>,
  writes to <em>out</em>, and prints exception summaries to <em>err</em>. If you use the
  default :read hook, <em>in</em> must either be an instance of
  LineNumberingPushbackReader or duplicate its behavior of both supporting
  .unread and collapsing CR, LF, and CRLF into a single \newline. Options
  are sequential keyword-value pairs. Available options and their defaults:</p>

<pre><code> - :init, function of no arguments, initialization hook called with
   bindings for set!-able vars in place.
   default: #()

 - :need-prompt, function of no arguments, called before each
   read-eval-print except the first, the user will be prompted if it
   returns true.
   default: (if (instance? LineNumberingPushbackReader *in*)
              #(.atLineStart *in*)
              #(identity true))

 - :prompt, function of no arguments, prompts for more input.
   default: repl-prompt

 - :flush, function of no arguments, flushes output
   default: flush

 - :read, function of two arguments, reads from *in*:
     - returns its first argument to request a fresh prompt
       - depending on need-prompt, this may cause the repl to prompt
         before reading again
     - returns its second argument to request an exit from the repl
     - else returns the next object read from the input stream
   default: repl-read

 - :eval, funtion of one argument, returns the evaluation of its
   argument
   default: eval

 - :print, function of one argument, prints its argument to the output
   default: prn

 - :caught, function of one argument, a throwable, called when
   read, eval, or print throws an exception or error
   default: repl-caught
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn repl
  &quot;Generic, reusable, read-eval-print loop. By default, reads from *in*,
  writes to *out*, and prints exception summaries to *err*. If you use the
  default :read hook, *in* must either be an instance of
  LineNumberingPushbackReader or duplicate its behavior of both supporting
  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options
  are sequential keyword-value pairs. Available options and their defaults:
     - :init, function of no arguments, initialization hook called with
       bindings for set!-able vars in place.
       default: #()
     - :need-prompt, function of no arguments, called before each
       read-eval-print except the first, the user will be prompted if it
       returns true.
       default: (if (instance? LineNumberingPushbackReader *in*)
                  #(.atLineStart *in*)
                  #(identity true))
     - :prompt, function of no arguments, prompts for more input.
       default: repl-prompt
     - :flush, function of no arguments, flushes output
       default: flush
     - :read, function of two arguments, reads from *in*:
         - returns its first argument to request a fresh prompt
           - depending on need-prompt, this may cause the repl to prompt
             before reading again
         - returns its second argument to request an exit from the repl
         - else returns the next object read from the input stream
       default: repl-read
     - :eval, funtion of one argument, returns the evaluation of its
       argument
       default: eval
     - :print, function of one argument, prints its argument to the output
       default: prn
     - :caught, function of one argument, a throwable, called when
       read, eval, or print throws an exception or error
       default: repl-caught&quot;
  [&amp; options]
  (let [cl (.getContextClassLoader (Thread/currentThread))]
    (.setContextClassLoader (Thread/currentThread) (clojure.lang.DynamicClassLoader. cl)))
  (let [{:keys [init need-prompt prompt flush read eval print caught]
         :or {init        #()
              need-prompt (if (instance? LineNumberingPushbackReader *in*)
                            #(.atLineStart ^LineNumberingPushbackReader *in*)
                            #(identity true))
              prompt      repl-prompt
              flush       flush
              read        repl-read
              eval        eval
              print       prn
              caught      repl-caught}}
        (apply hash-map options)
        request-prompt (Object.)
        request-exit (Object.)
        read-eval-print
        (fn []
          (try
           (let [input (read request-prompt request-exit)]
             (or (#{request-prompt request-exit} input)
                 (let [value (eval input)]
                   (print value)
                   (set! *3 *2)
                   (set! *2 *1)
                   (set! *1 value))))
           (catch Throwable e
             (caught e)
             (set! *e e))))]
    (with-bindings
     (try
      (init)
      (catch Throwable e
        (caught e)
        (set! *e e)))
     (use '[clojure.repl :only (source apropos dir pst doc find-doc)])
     (use '[clojure.java.javadoc :only (javadoc)])
     (use '[clojure.pprint :only (pp pprint)])
     (prompt)
     (flush)
     (loop []
       (when-not 
       	 (try (identical? (read-eval-print) request-exit)
	  (catch Throwable e
	   (caught e)
	   (set! *e e)
	   nil))
         (when (need-prompt)
           (prompt)
           (flush))
         (recur))))))</pre></td></tr><tr><td class="docs"><p>Loads Clojure source from a file or resource given its path. Paths
  beginning with @ or @/ are considered relative to classpath.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-script
  [^String path]
  (if (.startsWith path &quot;@&quot;)
    (RT/loadResourceScript
     (.substring path (if (.startsWith path &quot;@/&quot;) 2 1)))
    (Compiler/loadFile path)))</pre></td></tr><tr><td class="docs"><p>Load a script</p>
</td><td class="codes"><pre class="brush: clojure">(defn- init-opt
  [path]
  (load-script path))</pre></td></tr><tr><td class="docs"><p>Evals expressions in str, prints each non-nil result using prn</p>
</td><td class="codes"><pre class="brush: clojure">(defn- eval-opt
  [str]
  (let [eof (Object.)
        reader (LineNumberingPushbackReader. (java.io.StringReader. str))]
      (loop [input (read reader false eof)]
        (when-not (= input eof)
          (let [value (eval input)]
            (when-not (nil? value)
              (prn value))
            (recur (read reader false eof)))))))</pre></td></tr><tr><td class="docs"><p>Returns the handler associated with an init opt</p>
</td><td class="codes"><pre class="brush: clojure">(defn- init-dispatch
  [opt]
  ({&quot;-i&quot;     init-opt
    &quot;--init&quot; init-opt
    &quot;-e&quot;     eval-opt
    &quot;--eval&quot; eval-opt} opt))</pre></td></tr><tr><td class="docs"><p>Common initialize routine for repl, script, and null opts</p>
</td><td class="codes"><pre class="brush: clojure">(defn- initialize
  [args inits]
  (in-ns 'user)
  (set! *command-line-args* args)
  (doseq [[opt arg] inits]
    ((init-dispatch opt) arg)))</pre></td></tr><tr><td class="docs"><p>Call the -main function from a namespace with string arguments from
  the command line.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- main-opt
  [[_ main-ns &amp; args] inits]
  (with-bindings
    (initialize args inits)
    (apply (ns-resolve (doto (symbol main-ns) require) '-main) args)))</pre></td></tr><tr><td class="docs"><p>Start a repl with args and inits. Print greeting if no eval options were
  present</p>
</td><td class="codes"><pre class="brush: clojure">(defn- repl-opt
  [[_ &amp; args] inits]
  (when-not (some #(= eval-opt (init-dispatch (first %))) inits)
    (println &quot;Clojure&quot; (clojure-version)))
  (repl :init #(initialize args inits))
  (prn)
  (System/exit 0))</pre></td></tr><tr><td class="docs"><p>Run a script from a file, resource, or standard in with args and inits</p>
</td><td class="codes"><pre class="brush: clojure">(defn- script-opt
  [[path &amp; args] inits]
  (with-bindings
    (initialize args inits)
    (if (= path &quot;-&quot;)
      (load-reader *in*)
      (load-script path))))</pre></td></tr><tr><td class="docs"><p>No repl or script opt present, just bind args and run inits</p>
</td><td class="codes"><pre class="brush: clojure">(defn- null-opt
  [args inits]
  (with-bindings
    (initialize args inits)))</pre></td></tr><tr><td class="docs"><p>Print help text for main</p>
</td><td class="codes"><pre class="brush: clojure">(defn- help-opt
  [_ _]
  (println (:doc (meta (var main)))))</pre></td></tr><tr><td class="docs"><p>Returns the handler associated with a main option</p>
</td><td class="codes"><pre class="brush: clojure">(defn- main-dispatch
  [opt]
  (or
   ({&quot;-r&quot;     repl-opt
     &quot;--repl&quot; repl-opt
     &quot;-m&quot;     main-opt
     &quot;--main&quot; main-opt
     nil      null-opt
     &quot;-h&quot;     help-opt
     &quot;--help&quot; help-opt
     &quot;-?&quot;     help-opt} opt)
   script-opt))</pre></td></tr><tr><td class="docs"><p>Called by the clojure.lang.Repl.main stub to run a repl with args
  specified the old way</p>
</td><td class="codes"><pre class="brush: clojure">(defn- legacy-repl
  [args]
  (println &quot;WARNING: clojure.lang.Repl is deprecated.
Instead, use clojure.main like this:
java -cp clojure.jar clojure.main -i init.clj -r args...&quot;)
  (let [[inits [sep &amp; args]] (split-with (complement #{&quot;--&quot;}) args)]
    (repl-opt (concat [&quot;-r&quot;] args) (map vector (repeat &quot;-i&quot;) inits))))</pre></td></tr><tr><td class="docs"><p>Called by the clojure.lang.Script.main stub to run a script with args
  specified the old way</p>
</td><td class="codes"><pre class="brush: clojure">(defn- legacy-script
  [args]
  (println &quot;WARNING: clojure.lang.Script is deprecated.
Instead, use clojure.main like this:
java -cp clojure.jar clojure.main -i init.clj script.clj args...&quot;)
  (let [[inits [sep &amp; args]] (split-with (complement #{&quot;--&quot;}) args)]
    (null-opt args (map vector (repeat &quot;-i&quot;) inits))))</pre></td></tr><tr><td class="docs"><p>Usage: java -cp clojure.jar clojure.main [init-opt<em>] [main-opt] [arg</em>]</p>

<p>  With no options or args, runs an interactive Read-Eval-Print Loop</p>

<p>  init options:
    -i, --init path     Load a file or resource
    -e, --eval string   Evaluate expressions in string; print non-nil values</p>

<p>  main options:
    -m, --main ns-name  Call the -main function from a namespace with args
    -r, --repl          Run a repl
    path                Run a script from from a file or resource
    -                   Run a script from standard input
    -h, -?, --help      Print this help message and exit</p>

<p>  operation:</p>

<pre><code>- Establishes thread-local bindings for commonly set!-able vars
- Enters the user namespace
- Binds *command-line-args* to a seq of strings containing command line
  args that appear after any main option
- Runs all init options in order
- Calls a -main function or runs a repl or script if requested
</code></pre>

<p>  The init options may be repeated and mixed freely, but must appear before
  any main option. The appearance of any eval option before running a repl
  suppresses the usual repl greeting message: "Clojure ~(clojure-version)".</p>

<p>  Paths may be absolute or relative in the filesystem or relative to
  classpath. Classpath-relative paths have prefix of @ or @/</p>
</td><td class="codes"><pre class="brush: clojure">(defn main
  [&amp; args]
  (try
   (if args
     (loop [[opt arg &amp; more :as args] args inits []]
       (if (init-dispatch opt)
         (recur more (conj inits [opt arg]))
         ((main-dispatch opt) args inits)))
     (repl-opt nil nil))
   (finally 
     (flush))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.parallel" name="clojure.parallel"><h1 class="project-name">clojure.parallel</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>DEPRECATED Wrapper of the ForkJoin library (JSR-166).</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
    clojure.parallel)
(alias 'parallel 'clojure.parallel)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment &quot;
The parallel library wraps the ForkJoin library scheduled for inclusion in JDK 7:

http://gee.cs.oswego.edu/dl/concurrency-interest/index.html

You'll need jsr166y.jar in your classpath in order to use this
library.  The basic idea is that Clojure collections, and most
efficiently vectors, can be turned into parallel arrays for use by
this library with the function par, although most of the functions
take collections and will call par if needed, so normally you will
only need to call par explicitly in order to attach bound/filter/map
ops. Parallel arrays support the attachment of bounds, filters and
mapping functions prior to realization/calculation, which happens as
the result of any of several operations on the
array (pvec/psort/pfilter-nils/pfilter-dupes). Rather than perform
composite operations in steps, as would normally be done with
sequences, maps and filters are instead attached and thus composed by
providing ops to par. Note that there is an order sensitivity to the
attachments - bounds precede filters precede mappings.  All operations
then happen in parallel, using multiple threads and a sophisticated
work-stealing system supported by fork-join, either when the array is
realized, or to perform aggregate operations like preduce/pmin/pmax
etc. A parallel array can be realized into a Clojure vector using
pvec.
&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import '(jsr166y.forkjoin ParallelArray ParallelArrayWithBounds ParallelArrayWithFilter 
                           ParallelArrayWithMapping 
                           Ops$Op Ops$BinaryOp Ops$Reducer Ops$Predicate Ops$BinaryPredicate 
                           Ops$IntAndObjectPredicate Ops$IntAndObjectToObject))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- op [f]
  (proxy [Ops$Op] []
    (op [x] (f x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- binary-op [f]
  (proxy [Ops$BinaryOp] []
    (op [x y] (f x y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- int-and-object-to-object [f]
  (proxy [Ops$IntAndObjectToObject] []
    (op [i x] (f x i))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- reducer [f]
  (proxy [Ops$Reducer] []
    (op [x y] (f x y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- predicate [f]
  (proxy [Ops$Predicate] []
    (op [x] (boolean (f x)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- binary-predicate [f]
  (proxy [Ops$BinaryPredicate] []
    (op [x y] (boolean (f x y)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- int-and-object-predicate [f]
  (proxy [Ops$IntAndObjectPredicate] []
    (op [i x] (boolean (f x i)))))</pre></td></tr><tr><td class="docs"><p>Creates a parallel array from coll. ops, if supplied, perform
  on-the-fly filtering or transformations during parallel realization
  or calculation. ops form a chain, and bounds must precede filters,
  must precede maps. ops must be a set of keyword value pairs of the
  following forms:</p>

<pre><code> :bound [start end]
</code></pre>

<p>  Only elements from start (inclusive) to end (exclusive) will be
  processed when the array is realized.</p>

<pre><code> :filter pred
</code></pre>

<p>  Filter preds remove elements from processing when the array is realized. pred
  must be a function of one argument whose return will be processed
  via boolean.</p>

<pre><code> :filter-index pred2
</code></pre>

<p>  pred2 must be a function of two arguments, which will be an element
  of the collection and the corresponding index, whose return will be
  processed via boolean.</p>

<pre><code> :filter-with [pred2 coll2]
</code></pre>

<p>  pred2 must be a function of two arguments, which will be
  corresponding elements of the 2 collections.</p>

<pre><code> :map f
</code></pre>

<p>  Map fns will be used to transform elements when the array is
  realized. f must be a function of one argument.</p>

<pre><code> :map-index f2
</code></pre>

<p>  f2 must be a function of two arguments, which will be an element of
  the collection and the corresponding index.</p>

<pre><code> :map-with [f2 coll2]
</code></pre>

<p>  f2 must be a function of two arguments, which will be corresponding
  elements of the 2 collections.</p>
</td><td class="codes"><pre class="brush: clojure">(defn par
  ([coll] 
     (if (instance? ParallelArrayWithMapping coll)
       coll
       (. ParallelArray createUsingHandoff  
        (to-array coll) 
        (. ParallelArray defaultExecutor))))
  ([coll &amp; ops]
     (reduce (fn [pa [op args]] 
                 (cond
                  (= op :bound) (. pa withBounds (args 0) (args 1))
                  (= op :filter) (. pa withFilter (predicate args))
                  (= op :filter-with) (. pa withFilter (binary-predicate (args 0)) (par (args 1)))
                  (= op :filter-index) (. pa withIndexedFilter (int-and-object-predicate args))
                  (= op :map) (. pa withMapping (parallel/op args))
                  (= op :map-with) (. pa withMapping (binary-op (args 0)) (par (args 1)))
                  (= op :map-index) (. pa withIndexedMapping (int-and-object-to-object args))
                  :else (throw (Exception. (str &quot;Unsupported par op: &quot; op)))))
             (par coll) 
             (partition 2 ops))))</pre></td></tr><tr><td class="docs"><p>Returns some (random) element of the coll if it satisfies the bound/filter/map</p>

<p>aggregate operations ;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"><pre class="brush: clojure">(defn pany
  [coll] 
  (. (par coll) any))</pre></td></tr><tr><td class="docs"><p>Returns the maximum element, presuming Comparable elements, unless
  a Comparator comp is supplied</p>
</td><td class="codes"><pre class="brush: clojure">(defn pmax
  ([coll] (. (par coll) max))
  ([coll comp] (. (par coll) max comp)))</pre></td></tr><tr><td class="docs"><p>Returns the minimum element, presuming Comparable elements, unless
  a Comparator comp is supplied</p>
</td><td class="codes"><pre class="brush: clojure">(defn pmin
  ([coll] (. (par coll) min))
  ([coll comp] (. (par coll) min comp)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- summary-map [s]
  {:min (.min s) :max (.max s) :size (.size s) :min-index (.indexOfMin s) :max-index (.indexOfMax s)})</pre></td></tr><tr><td class="docs"><p>Returns a map of summary statistics (min. max, size, min-index, max-index, 
  presuming Comparable elements, unless a Comparator comp is supplied</p>
</td><td class="codes"><pre class="brush: clojure">(defn psummary 
  ([coll] (summary-map (. (par coll) summary)))
  ([coll comp] (summary-map (. (par coll) summary comp))))</pre></td></tr><tr><td class="docs"><p>Returns the reduction of the realized elements of coll
  using function f. Note f will not necessarily be called
  consecutively, and so must be commutative. Also note that 
  (f base an-element) might be performed many times, i.e. base is not
  an initial value as with sequential reduce.</p>
</td><td class="codes"><pre class="brush: clojure">(defn preduce 
  [f base coll]
  (. (par coll) (reduce (reducer f) base)))</pre></td></tr><tr><td class="docs"><p>collection-producing operations ;;;;;;;;;;;;;;;;;;;;;;</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pa-to-vec [pa]
  (vec (. pa getArray)))</pre></td></tr><tr><td class="docs"><p>Realizes a copy of the coll as a parallel array, with any bounds/filters/maps applied</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pall
  [coll]
  (if (instance? ParallelArrayWithMapping coll)
    (. coll all)
    (par coll)))</pre></td></tr><tr><td class="docs"><p>Returns the realized contents of the parallel array pa as a Clojure vector</p>
</td><td class="codes"><pre class="brush: clojure">(defn pvec 
  [pa] (pa-to-vec (pall pa)))</pre></td></tr><tr><td class="docs"><p>Returns a parallel array of the distinct elements of coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn pdistinct
  [coll]
  (pa-to-vec (. (pall coll) allUniqueElements)))</pre></td></tr><tr><td class="docs"><p>this doesn't work, passes null to reducer?</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pcumulate [coll f init]
  (.. (pall coll) (precumulate (reducer f) init)))</pre></td></tr><tr><td class="docs"><p>Returns a new vector consisting of the realized items in coll, sorted, 
  presuming Comparable elements, unless a Comparator comp is supplied</p>
</td><td class="codes"><pre class="brush: clojure">(defn psort 
  ([coll] (pa-to-vec (. (pall coll) sort)))
  ([coll comp] (pa-to-vec (. (pall coll) sort comp))))</pre></td></tr><tr><td class="docs"><p>Returns a vector containing the non-nil (realized) elements of coll</p>
</td><td class="codes"><pre class="brush: clojure">(defn pfilter-nils
  [coll]
  (pa-to-vec (. (pall coll) removeNulls)))</pre></td></tr><tr><td class="docs"><p>Returns a vector containing the (realized) elements of coll, 
  without any consecutive duplicates</p>
</td><td class="codes"><pre class="brush: clojure">(defn pfilter-dupes 
  [coll]
  (pa-to-vec (. (pall coll) removeConsecutiveDuplicates)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
(load-file &quot;src/parallel.clj&quot;)
(refer 'parallel)
(pdistinct [1 2 3 2 1])
;(pcumulate [1 2 3 2 1] + 0) ;broken, not exposed
(def a (make-array Object 1000000))
(dotimes i (count a)
  (aset a i (rand-int i)))
(time (reduce + 0 a))
(time (preduce + 0 a))
(time (count (distinct a)))
(time (count (pdistinct a)))
(preduce + 0 [1 2 3 2 1])
(preduce + 0 (psort a))
(pvec (par [11 2 3 2] :filter-index (fn [x i] (&gt; i x))))
(pvec (par [11 2 3 2] :filter-with [(fn [x y] (&gt; y x)) [110 2 33 2]]))
(psummary ;or pvec/pmax etc
 (par [11 2 3 2] 
      :filter-with [(fn [x y] (&gt; y x)) 
                    [110 2 33 2]]
      :map #(* % 2)))
(preduce + 0
  (par [11 2 3 2] 
       :filter-with [&lt; [110 2 33 2]]))
(time (reduce + 0 (map #(* % %) (range 1000000))))
(time (preduce + 0 (par (range 1000000) :map-index *)))
(def v (range 1000000))
(time (preduce + 0 (par v :map-index *)))
(time (preduce + 0 (par v :map  #(* % %))))
(time (reduce + 0 (map #(* % %) v))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.pprint" name="clojure.pprint"><h1 class="project-name">clojure.pprint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>pprint.clj -- Pretty printer and Common Lisp compatible format function (cl-format) for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A Pretty Printer for Clojure</p>

<p>clojure.pprint implements a flexible system for printing structured data
in a pleasing, easy-to-understand format. Basic use of the pretty printer is 
simple, just call pprint instead of println. More advanced users can use 
the building blocks provided to create custom output formats. </p>

<p>Out of the box, pprint supports a simple structured format for basic data 
and a specialized format for Clojure source code. More advanced formats, 
including formats that don't look like Clojure data at all like XML and 
JSON, can be rendered by creating custom dispatch functions. </p>

<p>In addition to the pprint function, this module contains cl-format, a text 
formatting function which is fully compatible with the format function in 
Common Lisp. Because pretty printing directives are directly integrated with
cl-format, it supports very concise custom dispatch. It also provides
a more powerful alternative to Clojure's standard format function.</p>

<p>See documentation for pprint and cl-format for more information or 
complete documentation on the the clojure web site on github.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
    ^{:author &quot;Tom Faulhaber&quot;,
      :doc ,
       :added &quot;1.2&quot;}
    clojure.pprint
    (:refer-clojure :exclude (deftype))
    (:use [clojure.walk :only [walk]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(load &quot;pprint/utilities&quot;)
(load &quot;pprint/column_writer&quot;)
(load &quot;pprint/pretty_writer&quot;)
(load &quot;pprint/pprint_base&quot;)
(load &quot;pprint/cl_format&quot;)
(load &quot;pprint/dispatch&quot;)
(load &quot;pprint/print_table&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">nil
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>cl_format.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements the Common Lisp compatible format function as documented
in "Common Lisp the Language, 2nd edition", Chapter 22 (available online at:
http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs"><p>Forward references</p>
</td><td class="codes"><pre class="brush: clojure">(declare compile-format)
(declare execute-format)
(declare init-navigator)</pre></td></tr><tr><td class="docs"><p>End forward references</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>An implementation of a Common Lisp compatible format function. cl-format formats its
arguments to an output stream or string based on the format control string given. It 
supports sophisticated formatting of structured data.</p>

<p>Writer is an instance of java.io.Writer, true to output to <em>out</em> or nil to output 
to a string, format-in is the format control string and the remaining arguments 
are the data to be formatted.</p>

<p>The format control string is a string to be output with embedded 'format directives' 
describing how to format the various arguments passed in.</p>

<p>If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format 
returns nil.</p>

<p>For example:
 (let [results [46 38 22]]
        (cl-format true "There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%" 
                   (count results) results))</p>

<p>Prints to <em>out</em>:
 There are 3 results: 46, 38, 22</p>

<p>Detailed documentation on format control strings is available in the "Common Lisp the 
Language, 2nd edition", Chapter 22 (available online at:
http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) 
and in the Common Lisp HyperSpec at 
http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</p>
</td><td class="codes"><pre class="brush: clojure">(defn cl-format 
  {:added &quot;1.2&quot;,
   :see-also [[&quot;http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000&quot; 
               &quot;Common Lisp the Language&quot;]
              [&quot;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&quot;
               &quot;Common Lisp HyperSpec&quot;]]}
  [writer format-in &amp; args]
  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)
        navigator (init-navigator args)]
    (execute-format writer compiled-format navigator)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:private true} *format-str* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-error [message offset] 
  (let [full-message (str message \newline *format-str* \newline 
                           (apply str (repeat offset \space)) &quot;^&quot; \newline)]
    (throw (RuntimeException. full-message))))</pre></td></tr><tr><td class="docs"><p>Argument navigators manage the argument list
as the format statement moves through the list
(possibly going forwards and backwards as it does so)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defstruct ^{:private true}
  arg-navigator :seq :rest :pos )</pre></td></tr><tr><td class="docs"><p>Create a new arg-navigator from the sequence with the position set to 0</p>
</td><td class="codes"><pre class="brush: clojure">(defn- init-navigator 
  {:skip-wiki true}
  [s]
  (let [s (seq s)]
    (struct arg-navigator s s 0)))</pre></td></tr><tr><td class="docs"><p>TODO call format-error with offset</p>
</td><td class="codes"><pre class="brush: clojure">(defn- next-arg [ navigator ]
  (let [ rst (:rest navigator) ]
    (if rst
      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]
     (throw (new Exception  &quot;Not enough arguments for format definition&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- next-arg-or-nil [navigator]
  (let [rst (:rest navigator)]
    (if rst
      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]
      [nil navigator])))</pre></td></tr><tr><td class="docs"><p>Get an argument off the arg list and compile it if it's not already compiled</p>
</td><td class="codes"><pre class="brush: clojure">(defn- get-format-arg [navigator]
  (let [[raw-format navigator] (next-arg navigator)
        compiled-format (if (instance? String raw-format) 
                               (compile-format raw-format)
                               raw-format)]
    [compiled-format navigator]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare relative-reposition)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- absolute-reposition [navigator position]
  (if (&gt;= position (:pos navigator))
    (relative-reposition navigator (- (:pos navigator) position))
    (struct arg-navigator (:seq navigator) (drop position (:seq navigator)) position)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- relative-reposition [navigator position]
  (let [newpos (+ (:pos navigator) position)]
    (if (neg? position)
      (absolute-reposition navigator newpos)
      (struct arg-navigator (:seq navigator) (drop position (:rest navigator)) newpos))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defstruct ^{:private true}
  compiled-directive :func :def :params :offset)</pre></td></tr><tr><td class="docs"><p>When looking at the parameter list, we may need to manipulate
the argument list as well (for 'V' and '#' parameter types).
We hide all of this behind a function, but clients need to
manage changing arg navigator</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO: validate parameters when they come from arg list</p>
</td><td class="codes"><pre class="brush: clojure">(defn- realize-parameter [[param [raw-val offset]] navigator]
  (let [[real-param new-navigator]
        (cond 
         (contains? #{ :at :colon } param) ;pass flags through unchanged - this really isn't necessary
         [raw-val navigator]
         (= raw-val :parameter-from-args) 
         (next-arg navigator)
         (= raw-val :remaining-arg-count) 
         [(count (:rest navigator)) navigator]
         true 
         [raw-val navigator])]
    [[param [real-param offset]] new-navigator]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- realize-parameter-list [parameter-map navigator]
  (let [[pairs new-navigator] 
        (map-passing-context realize-parameter navigator parameter-map)]
    [(into {} pairs) new-navigator]))</pre></td></tr><tr><td class="docs"><p>Functions that support individual directives</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Common handling code for ~A and ~S</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare opt-base-str)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     special-radix-markers {2 &quot;#b&quot; 8 &quot;#o&quot;, 16 &quot;#x&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-simple-number [n]
  (cond 
    (integer? n) (if (= *print-base* 10)
                   (str n (if *print-radix* &quot;.&quot;))
                   (str
                    (if *print-radix* (or (get special-radix-markers *print-base*) (str &quot;#&quot; *print-base* &quot;r&quot;)))
                    (opt-base-str *print-base* n)))
    (ratio? n) (str
                (if *print-radix* (or (get special-radix-markers *print-base*) (str &quot;#&quot; *print-base* &quot;r&quot;)))
                (opt-base-str *print-base* (.numerator n))
                &quot;/&quot;
                (opt-base-str *print-base* (.denominator n)))
    :else nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-ascii [print-func params arg-navigator offsets]
  (let [ [arg arg-navigator] (next-arg arg-navigator) 
         ^String base-output (or (format-simple-number arg) (print-func arg))
         base-width (.length base-output)
         min-width (+ base-width (:minpad params))
         width (if (&gt;= min-width (:mincol params)) 
                 min-width
                 (+ min-width 
                    (* (+ (quot (- (:mincol params) min-width 1) 
                                (:colinc params) )
                          1)
                       (:colinc params))))
         chars (apply str (repeat (- width base-width) (:padchar params)))]
    (if (:at params)
      (print (str chars base-output))
      (print (str base-output chars)))
    arg-navigator))</pre></td></tr><tr><td class="docs"><p>Support for the integer directives ~D, ~X, ~O, ~B and some
of ~R</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>returns true if a number is actually an integer (that is, has no fractional part)</p>
</td><td class="codes"><pre class="brush: clojure">(defn- integral?
  [x]
  (cond
   (integer? x) true
   (decimal? x) (&gt;= (.ulp (.stripTrailingZeros (bigdec 0))) 1) ; true iff no fractional part
   (float? x)   (= x (Math/floor x))
   (ratio? x)   (let [^clojure.lang.Ratio r x]
                  (= 0 (rem (.numerator r) (.denominator r))))
   :else        false))</pre></td></tr><tr><td class="docs"><p>Return the list of remainders (essentially the 'digits') of val in the given base</p>
</td><td class="codes"><pre class="brush: clojure">(defn- remainders
  [base val]
  (reverse 
   (first 
    (consume #(if (pos? %) 
                [(rem % base) (quot % base)] 
                [nil nil]) 
             val))))</pre></td></tr><tr><td class="docs"><p>Return val as a string in the given base</p>

<p>TODO: xlated-val does not seem to be used here.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- base-str
  [base val]
  (if (zero? val)
    &quot;0&quot;
    (let [xlated-val (cond
                       (float? val) (bigdec val)
                       (ratio? val) (let [^clojure.lang.Ratio r val] 
                                      (/ (.numerator r) (.denominator r)))
                       :else val)] 
      (apply str 
             (map 
              #(if (&lt; % 10) (char (+ (int \0) %)) (char (+ (int \a) (- % 10)))) 
              (remainders base val))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     java-base-formats {8 &quot;%o&quot;, 10 &quot;%d&quot;, 16 &quot;%x&quot;})</pre></td></tr><tr><td class="docs"><p>Return val as a string in the given base, using clojure.core/format if supported
for improved performance</p>
</td><td class="codes"><pre class="brush: clojure">(defn- opt-base-str
  [base val]
  (let [format-str (get java-base-formats base)]
    (if (and format-str (integer? val) (not (instance? clojure.lang.BigInt val)))
      (clojure.core/format format-str val)
      (base-str base val))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- group-by* [unit lis]
  (reverse
   (first
    (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-integer [base params arg-navigator offsets]
  (let [[arg arg-navigator] (next-arg arg-navigator)]
    (if (integral? arg)
      (let [neg (neg? arg)
            pos-arg (if neg (- arg) arg)
            raw-str (opt-base-str base pos-arg)
            group-str (if (:colon params)
                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))
                              commas (repeat (count groups) (:commachar params))]
                          (apply str (next (interleave commas groups))))
                        raw-str)
            ^String signed-str (cond
                                  neg (str &quot;-&quot; group-str)
                                  (:at params) (str &quot;+&quot; group-str)
                                  true group-str)
            padded-str (if (&lt; (.length signed-str) (:mincol params))
                         (str (apply str (repeat (- (:mincol params) (.length signed-str)) 
                                                 (:padchar params)))
                              signed-str)
                         signed-str)]
        (print padded-str))
      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0 
                               :padchar (:padchar params) :at true} 
                    (init-navigator [arg]) nil))
    arg-navigator))</pre></td></tr><tr><td class="docs"><p>Support for english formats (~R and ~:R)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     english-cardinal-units 
     [&quot;zero&quot; &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;nine&quot;
      &quot;ten&quot; &quot;eleven&quot; &quot;twelve&quot; &quot;thirteen&quot; &quot;fourteen&quot;
      &quot;fifteen&quot; &quot;sixteen&quot; &quot;seventeen&quot; &quot;eighteen&quot; &quot;nineteen&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     english-ordinal-units 
     [&quot;zeroth&quot; &quot;first&quot; &quot;second&quot; &quot;third&quot; &quot;fourth&quot; &quot;fifth&quot; &quot;sixth&quot; &quot;seventh&quot; &quot;eighth&quot; &quot;ninth&quot;
      &quot;tenth&quot; &quot;eleventh&quot; &quot;twelfth&quot; &quot;thirteenth&quot; &quot;fourteenth&quot;
      &quot;fifteenth&quot; &quot;sixteenth&quot; &quot;seventeenth&quot; &quot;eighteenth&quot; &quot;nineteenth&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     english-cardinal-tens
     [  &quot;twenty&quot; &quot;thirty&quot; &quot;forty&quot; &quot;fifty&quot; &quot;sixty&quot; &quot;seventy&quot; &quot;eighty&quot; &quot;ninety&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     english-ordinal-tens
     [  &quot;twentieth&quot; &quot;thirtieth&quot; &quot;fortieth&quot; &quot;fiftieth&quot;
      &quot;sixtieth&quot; &quot;seventieth&quot; &quot;eightieth&quot; &quot;ninetieth&quot;])</pre></td></tr><tr><td class="docs"><p>We use "short scale" for our units (see http://en.wikipedia.org/wiki/Long<em>and</em>short_scales)
Number names from http://www.jimloy.com/math/billion.htm
We follow the rules for writing numbers from the Blue Book
(http://www.grammarbook.com/numbers/numbers.asp)</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     english-scale-numbers 
     [ &quot;thousand&quot; &quot;million&quot; &quot;billion&quot; &quot;trillion&quot; &quot;quadrillion&quot; &quot;quintillion&quot; 
      &quot;sextillion&quot; &quot;septillion&quot; &quot;octillion&quot; &quot;nonillion&quot; &quot;decillion&quot; 
      &quot;undecillion&quot; &quot;duodecillion&quot; &quot;tredecillion&quot; &quot;quattuordecillion&quot; 
      &quot;quindecillion&quot; &quot;sexdecillion&quot; &quot;septendecillion&quot; 
      &quot;octodecillion&quot; &quot;novemdecillion&quot; &quot;vigintillion&quot;])</pre></td></tr><tr><td class="docs"><p>Convert a number less than 1000 to a cardinal english string</p>
</td><td class="codes"><pre class="brush: clojure">(defn- format-simple-cardinal
  [num]
  (let [hundreds (quot num 100)
        tens (rem num 100)]
    (str
     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) &quot; hundred&quot;))
     (if (and (pos? hundreds) (pos? tens)) &quot; &quot;)
     (if (pos? tens) 
       (if (&lt; tens 20) 
         (nth english-cardinal-units tens)
         (let [ten-digit (quot tens 10)
               unit-digit (rem tens 10)]
           (str
            (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))
            (if (and (pos? ten-digit) (pos? unit-digit)) &quot;-&quot;)
            (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))</pre></td></tr><tr><td class="docs"><p>Take a sequence of parts, add scale numbers (e.g., million) and combine into a string
offset is a factor of 10^3 to multiply by</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-english-scales
  [parts offset]
  (let [cnt (count parts)]
    (loop [acc []
           pos (dec cnt)
           this (first parts)
           remainder (next parts)]
      (if (nil? remainder)
        (str (apply str (interpose &quot;, &quot; acc))
             (if (and (not (empty? this)) (not (empty? acc))) &quot;, &quot;)
             this
             (if (and (not (empty? this)) (pos? (+ pos offset)))
               (str &quot; &quot; (nth english-scale-numbers (+ pos offset)))))
        (recur 
         (if (empty? this)
           acc
           (conj acc (str this &quot; &quot; (nth english-scale-numbers (+ pos offset)))))
         (dec pos)
         (first remainder)
         (next remainder))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-cardinal-english [params navigator offsets]
  (let [[arg navigator] (next-arg navigator)]
    (if (= 0 arg)
      (print &quot;zero&quot;)
      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs
            parts (remainders 1000 abs-arg)]
        (if (&lt;= (count parts) (count english-scale-numbers))
          (let [parts-strs (map format-simple-cardinal parts)
                full-str (add-english-scales parts-strs 0)]
            (print (str (if (neg? arg) &quot;minus &quot;) full-str)))
          (format-integer ;; for numbers &gt; 10^63, we fall back on ~D
           10
           { :mincol 0, :padchar \space, :commachar \, :commainterval 3, :colon true}
           (init-navigator [arg])
           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))
    navigator))</pre></td></tr><tr><td class="docs"><p>Convert a number less than 1000 to a ordinal english string
Note this should only be used for the last one in the sequence</p>
</td><td class="codes"><pre class="brush: clojure">(defn- format-simple-ordinal
  [num]
  (let [hundreds (quot num 100)
        tens (rem num 100)]
    (str
     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) &quot; hundred&quot;))
     (if (and (pos? hundreds) (pos? tens)) &quot; &quot;)
     (if (pos? tens) 
       (if (&lt; tens 20) 
         (nth english-ordinal-units tens)
         (let [ten-digit (quot tens 10)
               unit-digit (rem tens 10)]
           (if (and (pos? ten-digit) (not (pos? unit-digit)))
             (nth english-ordinal-tens ten-digit)
             (str
              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))
              (if (and (pos? ten-digit) (pos? unit-digit)) &quot;-&quot;)
              (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))
       (if (pos? hundreds) &quot;th&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-ordinal-english [params navigator offsets]
  (let [[arg navigator] (next-arg navigator)]
    (if (= 0 arg)
      (print &quot;zeroth&quot;)
      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs
            parts (remainders 1000 abs-arg)]
        (if (&lt;= (count parts) (count english-scale-numbers))
          (let [parts-strs (map format-simple-cardinal (drop-last parts))
                head-str (add-english-scales parts-strs 1)
                tail-str (format-simple-ordinal (last parts))]
            (print (str (if (neg? arg) &quot;minus &quot;) 
                        (cond 
                         (and (not (empty? head-str)) (not (empty? tail-str))) 
                         (str head-str &quot;, &quot; tail-str)
                         (not (empty? head-str)) (str head-str &quot;th&quot;)
                         :else tail-str))))
          (do (format-integer ;; for numbers &gt; 10^63, we fall back on ~D
               10
               { :mincol 0, :padchar \space, :commachar \, :commainterval 3, :colon true}
               (init-navigator [arg])
               { :mincol 0, :padchar 0, :commachar 0 :commainterval 0})
              (let [low-two-digits (rem arg 100)
                    not-teens (or (&lt; 11 low-two-digits) (&gt; 19 low-two-digits))
                    low-digit (rem low-two-digits 10)]
                (print (cond 
                        (and (== low-digit 1) not-teens) &quot;st&quot;
                        (and (== low-digit 2) not-teens) &quot;nd&quot;
                        (and (== low-digit 3) not-teens) &quot;rd&quot;
                        :else &quot;th&quot;)))))))
    navigator))</pre></td></tr><tr><td class="docs"><p>Support for roman numeral formats (~@R and ~@:R)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     old-roman-table
     [[ &quot;I&quot; &quot;II&quot; &quot;III&quot; &quot;IIII&quot; &quot;V&quot; &quot;VI&quot; &quot;VII&quot; &quot;VIII&quot; &quot;VIIII&quot;]
      [ &quot;X&quot; &quot;XX&quot; &quot;XXX&quot; &quot;XXXX&quot; &quot;L&quot; &quot;LX&quot; &quot;LXX&quot; &quot;LXXX&quot; &quot;LXXXX&quot;]
      [ &quot;C&quot; &quot;CC&quot; &quot;CCC&quot; &quot;CCCC&quot; &quot;D&quot; &quot;DC&quot; &quot;DCC&quot; &quot;DCCC&quot; &quot;DCCCC&quot;]
      [ &quot;M&quot; &quot;MM&quot; &quot;MMM&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     new-roman-table
     [[ &quot;I&quot; &quot;II&quot; &quot;III&quot; &quot;IV&quot; &quot;V&quot; &quot;VI&quot; &quot;VII&quot; &quot;VIII&quot; &quot;IX&quot;]
      [ &quot;X&quot; &quot;XX&quot; &quot;XXX&quot; &quot;XL&quot; &quot;L&quot; &quot;LX&quot; &quot;LXX&quot; &quot;LXXX&quot; &quot;XC&quot;]
      [ &quot;C&quot; &quot;CC&quot; &quot;CCC&quot; &quot;CD&quot; &quot;D&quot; &quot;DC&quot; &quot;DCC&quot; &quot;DCCC&quot; &quot;CM&quot;]
      [ &quot;M&quot; &quot;MM&quot; &quot;MMM&quot;]])</pre></td></tr><tr><td class="docs"><p>Format a roman numeral using the specified look-up table</p>
</td><td class="codes"><pre class="brush: clojure">(defn- format-roman
  [table params navigator offsets]
  (let [[arg navigator] (next-arg navigator)]
    (if (and (number? arg) (&gt; arg 0) (&lt; arg 4000))
      (let [digits (remainders 10 arg)]
        (loop [acc []
               pos (dec (count digits))
               digits digits]
          (if (empty? digits)
            (print (apply str acc))
            (let [digit (first digits)]
              (recur (if (= 0 digit) 
                       acc 
                       (conj acc (nth (nth table pos) (dec digit))))
                     (dec pos)
                     (next digits))))))
      (format-integer ;; for anything &lt;= 0 or &gt; 3999, we fall back on ~D
           10
           { :mincol 0, :padchar \space, :commachar \, :commainterval 3, :colon true}
           (init-navigator [arg])
           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))
    navigator))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-old-roman [params navigator offsets]
  (format-roman old-roman-table params navigator offsets))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-new-roman [params navigator offsets]
  (format-roman new-roman-table params navigator offsets))</pre></td></tr><tr><td class="docs"><p>Support for character formats (~C)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} 
     special-chars { 8 &quot;Backspace&quot;, 9 &quot;Tab&quot;,  10 &quot;Newline&quot;, 13 &quot;Return&quot;, 32 &quot;Space&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pretty-character [params navigator offsets]
  (let [[c navigator] (next-arg navigator)
        as-int (int c)
        base-char (bit-and as-int 127)
        meta (bit-and as-int 128)
        special (get special-chars base-char)]
    (if (&gt; meta 0) (print &quot;Meta-&quot;))
    (print (cond
            special special
            (&lt; base-char 32) (str &quot;Control-&quot; (char (+ base-char 64)))
            (= base-char 127) &quot;Control-?&quot;
            :else (char base-char)))
    navigator))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- readable-character [params navigator offsets]
  (let [[c navigator] (next-arg navigator)]
    (condp = (:char-format params)
      \o (cl-format true &quot;\\o~3,'0o&quot; (int c))
      \u (cl-format true &quot;\\u~4,'0x&quot; (int c))
      nil (pr c))
    navigator))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- plain-character [params navigator offsets]
  (let [[char navigator] (next-arg navigator)]
    (print char)
    navigator))</pre></td></tr><tr><td class="docs"><p>Check to see if a result is an abort (~^) construct
TODO: move these funcs somewhere more appropriate</p>
</td><td class="codes"><pre class="brush: clojure">(defn- abort? [context]
  (let [token (first context)]
    (or (= :up-arrow token) (= :colon-up-arrow token))))</pre></td></tr><tr><td class="docs"><p>Handle the execution of "sub-clauses" in bracket constructions</p>
</td><td class="codes"><pre class="brush: clojure">(defn- execute-sub-format [format args base-args]
  (second
   (map-passing-context 
    (fn [element context]
      (if (abort? context)
        [nil context] ; just keep passing it along
        (let [[params args] (realize-parameter-list (:params element) context)
              [params offsets] (unzip-map params)
              params (assoc params :base-args base-args)]
          [nil (apply (:func element) [params args offsets])])))
    args
    format)))</pre></td></tr><tr><td class="docs"><p>Support for real number formats</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Produce string parts for the mantissa (normalized 1-9) and exponent</p>

<p>TODO - return exponent as int to eliminate double conversion</p>
</td><td class="codes"><pre class="brush: clojure">(defn- float-parts-base
  [^Object f]
  (let [^String s (.toLowerCase (.toString f))
        exploc (.indexOf s (int \e))]
    (if (neg? exploc)
      (let [dotloc (.indexOf s (int \.))]
        (if (neg? dotloc)
          [s (str (dec (count s)))]
          [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))]))
      [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))])))</pre></td></tr><tr><td class="docs"><p>Take care of leading and trailing zeros in decomposed floats</p>
</td><td class="codes"><pre class="brush: clojure">(defn- float-parts
  [f]
  (let [[m ^String e] (float-parts-base f)
        m1 (rtrim m \0)
        m2 (ltrim m1 \0)
        delta (- (count m1) (count m2))
        ^String e (if (and (pos? (count e)) (= (nth e 0) \+)) (subs e 1) e)]
    (if (empty? m2)
      [&quot;0&quot; 0]
      [m2 (- (Integer/valueOf e) delta)])))</pre></td></tr><tr><td class="docs"><p>Assumption: The input string consists of one or more decimal digits,
and no other characters.  Return a string containing one or more
decimal digits containing a decimal number one larger than the input
string.  The output string will always be the same length as the input
string, or one character longer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ^String inc-s
  [^String s]
  (let [len-1 (dec (count s))]
    (loop [i (int len-1)]
      (cond
       (neg? i) (apply str &quot;1&quot; (repeat (inc len-1) &quot;0&quot;))
       (= \9 (.charAt s i)) (recur (dec i))
       :else (apply str (subs s 0 i)
                    (char (inc (int (.charAt s i))))
                    (repeat (- len-1 i) &quot;0&quot;))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- round-str [m e d w]
  (if (or d w)
    (let [len (count m)
          ;; Every formatted floating point number should include at
          ;; least one decimal digit and a decimal point.
          w (if w (max 2 w))
          round-pos (cond
                     ;; If d was given, that forces the rounding
                     ;; position, regardless of any width that may
                     ;; have been specified.
                     d (+ e d 1)
                     ;; Otherwise w was specified, so pick round-pos
                     ;; based upon that.
                     ;; If e&gt;=0, then abs value of number is &gt;= 1.0,
                     ;; and e+1 is number of decimal digits before the
                     ;; decimal point when the number is written
                     ;; without scientific notation.  Never round the
                     ;; number before the decimal point.
                     (&gt;= e 0) (max (inc e) (dec w))
                     ;; e &lt; 0, so number abs value &lt; 1.0
                     :else (+ w e))
          [m1 e1 round-pos len] (if (= round-pos 0) 
                                  [(str &quot;0&quot; m) (inc e) 1 (inc len)]
                                  [m e round-pos len])]
      (if round-pos
        (if (neg? round-pos)
          [&quot;0&quot; 0 false]
          (if (&gt; len round-pos)
            (let [round-char (nth m1 round-pos)
                  ^String result (subs m1 0 round-pos)]
              (if (&gt;= (int round-char) (int \5))
                (let [round-up-result (inc-s result)
                      expanded (&gt; (count round-up-result) (count result))]
                  [(if expanded
                     (subs round-up-result 0 (dec (count round-up-result)))
                     round-up-result)
                   e1 expanded])
                [result e1 false]))
            [m e false]))
        [m e false]))
    [m e false]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- expand-fixed [m e d]
  (let [[m1 e1] (if (neg? e)
                  [(str (apply str (repeat (dec (- e)) \0)) m) -1]
                  [m e])
        len (count m1)
        target-len (if d (+ e1 d 1) (inc e1))]
    (if (&lt; len target-len) 
      (str m1 (apply str (repeat (- target-len len) \0))) 
      m1)))</pre></td></tr><tr><td class="docs"><p>Insert the decimal point at the right spot in the number to match an exponent</p>
</td><td class="codes"><pre class="brush: clojure">(defn- insert-decimal
  [m e]
  (if (neg? e)
    (str &quot;.&quot; m)
    (let [loc (inc e)]
      (str (subs m 0 loc) &quot;.&quot; (subs m loc)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-fixed [m e d]
  (insert-decimal (expand-fixed m e d) e))</pre></td></tr><tr><td class="docs"><p>Insert the decimal point at the right spot in the number to match an exponent</p>
</td><td class="codes"><pre class="brush: clojure">(defn- insert-scaled-decimal
  [m k]
  (if (neg? k)
    (str &quot;.&quot; m)
    (str (subs m 0 k) &quot;.&quot; (subs m k))))</pre></td></tr><tr><td class="docs"><p>the function to render ~F directives
TODO: support rationals. Back off to ~D/~A is the appropriate cases</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fixed-float [params navigator offsets]
  (let [w (:w params)
        d (:d params)
        [arg navigator] (next-arg navigator)
        [sign abs] (if (neg? arg) [&quot;-&quot; (- arg)] [&quot;+&quot; arg])
        [mantissa exp] (float-parts abs)
        scaled-exp (+ exp (:k params))
        add-sign (or (:at params) (neg? arg))
        append-zero (and (not d) (&lt;= (dec (count mantissa)) scaled-exp))
        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp 
                                                          d (if w (- w (if add-sign 1 0))))
        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)
        fixed-repr (if (and w d
                            (&gt;= d 1)
                            (= (.charAt fixed-repr 0) \0)
                            (= (.charAt fixed-repr 1) \.)
                            (&gt; (count fixed-repr) (- w (if add-sign 1 0))))
                     (subs fixed-repr 1)  ; chop off leading 0
                     fixed-repr)
        prepend-zero (= (first fixed-repr) \.)]
    (if w
      (let [len (count fixed-repr)
            signed-len (if add-sign (inc len) len)
            prepend-zero (and prepend-zero (not (&gt;= signed-len w)))
            append-zero (and append-zero (not (&gt;= signed-len w)))
            full-len (if (or prepend-zero append-zero)
                       (inc signed-len) 
                       signed-len)]
        (if (and (&gt; full-len w) (:overflowchar params))
          (print (apply str (repeat w (:overflowchar params))))
          (print (str
                  (apply str (repeat (- w full-len) (:padchar params)))
                  (if add-sign sign) 
                  (if prepend-zero &quot;0&quot;)
                  fixed-repr
                  (if append-zero &quot;0&quot;)))))
      (print (str
              (if add-sign sign) 
              (if prepend-zero &quot;0&quot;)
              fixed-repr
              (if append-zero &quot;0&quot;))))
    navigator))</pre></td></tr><tr><td class="docs"><p>the function to render ~E directives
TODO: support rationals. Back off to ~D/~A is the appropriate cases
TODO: define ~E representation for Infinity</p>
</td><td class="codes"><pre class="brush: clojure">(defn- exponential-float [params navigator offsets]
  (let [[arg navigator] (next-arg navigator)]
    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]
      (let [w (:w params)
            d (:d params)
            e (:e params)
            k (:k params)
            expchar (or (:exponentchar params) \E)
            add-sign (or (:at params) (neg? arg))
            prepend-zero (&lt;= k 0)
            ^Integer scaled-exp (- exp (dec k))
            scaled-exp-str (str (Math/abs scaled-exp))
            scaled-exp-str (str expchar (if (neg? scaled-exp) \- \+) 
                                (if e (apply str 
                                             (repeat 
                                              (- e 
                                                 (count scaled-exp-str)) 
                                              \0))) 
                                scaled-exp-str)
            exp-width (count scaled-exp-str)
            base-mantissa-width (count mantissa)
            scaled-mantissa (str (apply str (repeat (- k) \0))
                                 mantissa
                                 (if d 
                                   (apply str 
                                          (repeat 
                                           (- d (dec base-mantissa-width)
                                              (if (neg? k) (- k) 0)) \0))))
            w-mantissa (if w (- w exp-width))
            [rounded-mantissa _ incr-exp] (round-str 
                                           scaled-mantissa 0
                                           (cond
                                            (= k 0) (dec d)
                                            (pos? k) d
                                            (neg? k) (dec d))
                                           (if w-mantissa 
                                             (- w-mantissa (if add-sign 1 0))))
            full-mantissa (insert-scaled-decimal rounded-mantissa k)
            append-zero (and (= k (count rounded-mantissa)) (nil? d))]
        (if (not incr-exp)
          (if w
            (let [len (+ (count full-mantissa) exp-width)
                  signed-len (if add-sign (inc len) len)
                  prepend-zero (and prepend-zero (not (= signed-len w)))
                  full-len (if prepend-zero (inc signed-len) signed-len)
                  append-zero (and append-zero (&lt; full-len w))]
              (if (and (or (&gt; full-len w) (and e (&gt; (- exp-width 2) e)))
                       (:overflowchar params))
                (print (apply str (repeat w (:overflowchar params))))
                (print (str
                        (apply str 
                               (repeat 
                                (- w full-len (if append-zero 1 0) )
                                (:padchar params)))
                        (if add-sign (if (neg? arg) \- \+)) 
                        (if prepend-zero &quot;0&quot;)
                        full-mantissa
                        (if append-zero &quot;0&quot;)
                        scaled-exp-str))))
            (print (str
                    (if add-sign (if (neg? arg) \- \+)) 
                    (if prepend-zero &quot;0&quot;)
                    full-mantissa
                    (if append-zero &quot;0&quot;)
                    scaled-exp-str)))
          (recur [rounded-mantissa (inc exp)]))))
    navigator))</pre></td></tr><tr><td class="docs"><p>the function to render ~G directives
This just figures out whether to pass the request off to ~F or ~E based 
on the algorithm in CLtL.
TODO: support rationals. Back off to ~D/~A is the appropriate cases
TODO: refactor so that float-parts isn't called twice</p>
</td><td class="codes"><pre class="brush: clojure">(defn- general-float [params navigator offsets]
  (let [[arg _] (next-arg navigator)
        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))
        w (:w params)
        d (:d params)
        e (:e params)
        n (if (= arg 0.0) 0 (inc exp))
        ee (if e (+ e 2) 4)
        ww (if w (- w ee))
        d (if d d (max (count mantissa) (min n 7)))
        dd (- d n)]
    (if (&lt;= 0 dd d)
      (let [navigator (fixed-float {:w ww, :d dd, :k 0, 
                                    :overflowchar (:overflowchar params),
                                    :padchar (:padchar params), :at (:at params)} 
                                   navigator offsets)]
        (print (apply str (repeat ee \space)))
        navigator)
      (exponential-float params navigator offsets))))</pre></td></tr><tr><td class="docs"><p>the function to render ~$ directives
TODO: support rationals. Back off to ~D/~A is the appropriate cases</p>
</td><td class="codes"><pre class="brush: clojure">(defn- dollar-float [params navigator offsets]
  (let [[^Double arg navigator] (next-arg navigator)
        [mantissa exp] (float-parts (Math/abs arg))
        d (:d params) ; digits after the decimal
        n (:n params) ; minimum digits before the decimal
        w (:w params) ; minimum field width
        add-sign (or (:at params) (neg? arg))
        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)
        ^String fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)
        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr (int \.))) \0)) fixed-repr)
        full-len (+ (count full-repr) (if add-sign 1 0))]
    (print (str
            (if (and (:colon params) add-sign) (if (neg? arg) \- \+))
            (apply str (repeat (- w full-len) (:padchar params)))
            (if (and (not (:colon params)) add-sign) (if (neg? arg) \- \+))
            full-repr))
    navigator))</pre></td></tr><tr><td class="docs"><p>Support for the '~[...~]' conditional construct in its
different flavors</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>~[...~] without any modifiers chooses one of the clauses based on the param or 
next argument
TODO check arg is positive int</p>
</td><td class="codes"><pre class="brush: clojure">(defn- choice-conditional [params arg-navigator offsets]
  (let [arg (:selector params)
        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))
        clauses (:clauses params)
        clause (if (or (neg? arg) (&gt;= arg (count clauses)))
                 (first (:else params))
                 (nth clauses arg))]
    (if clause
      (execute-sub-format clause navigator (:base-args params))
      navigator)))</pre></td></tr><tr><td class="docs"><p>~:[...~] with the colon reads the next argument treating it as a truth value</p>
</td><td class="codes"><pre class="brush: clojure">(defn- boolean-conditional [params arg-navigator offsets]
  (let [[arg navigator] (next-arg arg-navigator)
        clauses (:clauses params)
        clause (if arg
                 (second clauses)
                 (first clauses))]
    (if clause
      (execute-sub-format clause navigator (:base-args params))
      navigator)))</pre></td></tr><tr><td class="docs"><p>~@[...~] with the at sign executes the conditional if the next arg is not
nil/false without consuming the arg</p>
</td><td class="codes"><pre class="brush: clojure">(defn- check-arg-conditional [params arg-navigator offsets]
  (let [[arg navigator] (next-arg arg-navigator)
        clauses (:clauses params)
        clause (if arg (first clauses))]
    (if arg
      (if clause
        (execute-sub-format clause arg-navigator (:base-args params))
        arg-navigator)
      navigator)))</pre></td></tr><tr><td class="docs"><p>Support for the '~{...~}' iteration construct in its
different flavors</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>~{...~} without any modifiers uses the next argument as an argument list that 
is consumed by all the iterations</p>
</td><td class="codes"><pre class="brush: clojure">(defn- iterate-sublist [params navigator offsets]
  (let [max-count (:max-iterations params)
        param-clause (first (:clauses params))
        [clause navigator] (if (empty? param-clause) 
                             (get-format-arg navigator)
                             [param-clause navigator]) 
        [arg-list navigator] (next-arg navigator)
        args (init-navigator arg-list)]
    (loop [count 0
           args args
           last-pos (num -1)]
      (if (and (not max-count) (= (:pos args) last-pos) (&gt; count 1))
        ;; TODO get the offset in here and call format exception
        (throw (RuntimeException. &quot;%{ construct not consuming any arguments: Infinite loop!&quot;)))
      (if (or (and (empty? (:rest args))
                   (or (not (:colon (:right-params params))) (&gt; count 0)))
              (and max-count (&gt;= count max-count)))
        navigator
        (let [iter-result (execute-sub-format clause args (:base-args params))] 
          (if (= :up-arrow (first iter-result))
            navigator
            (recur (inc count) iter-result (:pos args))))))))</pre></td></tr><tr><td class="docs"><p>~:{...~} with the colon treats the next argument as a list of sublists. Each of the
sublists is used as the arglist for a single iteration.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- iterate-list-of-sublists [params navigator offsets]
  (let [max-count (:max-iterations params)
        param-clause (first (:clauses params))
        [clause navigator] (if (empty? param-clause) 
                             (get-format-arg navigator)
                             [param-clause navigator]) 
        [arg-list navigator] (next-arg navigator)]
    (loop [count 0
           arg-list arg-list]
      (if (or (and (empty? arg-list)
                   (or (not (:colon (:right-params params))) (&gt; count 0)))
              (and max-count (&gt;= count max-count)))
        navigator
        (let [iter-result (execute-sub-format 
                           clause 
                           (init-navigator (first arg-list))
                           (init-navigator (next arg-list)))]
          (if (= :colon-up-arrow (first iter-result))
            navigator
            (recur (inc count) (next arg-list))))))))</pre></td></tr><tr><td class="docs"><p>~@{...~} with the at sign uses the main argument list as the arguments to the iterations
is consumed by all the iterations</p>
</td><td class="codes"><pre class="brush: clojure">(defn- iterate-main-list [params navigator offsets]
  (let [max-count (:max-iterations params)
        param-clause (first (:clauses params))
        [clause navigator] (if (empty? param-clause) 
                             (get-format-arg navigator)
                             [param-clause navigator])]
    (loop [count 0
           navigator navigator
           last-pos (num -1)]
      (if (and (not max-count) (= (:pos navigator) last-pos) (&gt; count 1))
        ;; TODO get the offset in here and call format exception
        (throw (RuntimeException. &quot;%@{ construct not consuming any arguments: Infinite loop!&quot;)))
      (if (or (and (empty? (:rest navigator))
                   (or (not (:colon (:right-params params))) (&gt; count 0)))
              (and max-count (&gt;= count max-count)))
        navigator
        (let [iter-result (execute-sub-format clause navigator (:base-args params))] 
          (if (= :up-arrow (first iter-result))
            (second iter-result)
            (recur 
             (inc count) iter-result (:pos navigator))))))))</pre></td></tr><tr><td class="docs"><p>~@:{...~} with both colon and at sign uses the main argument list as a set of sublists, one
of which is consumed with each iteration</p>
</td><td class="codes"><pre class="brush: clojure">(defn- iterate-main-sublists [params navigator offsets]
  (let [max-count (:max-iterations params)
        param-clause (first (:clauses params))
        [clause navigator] (if (empty? param-clause) 
                             (get-format-arg navigator)
                             [param-clause navigator]) 
        ]
    (loop [count 0
           navigator navigator]
      (if (or (and (empty? (:rest navigator))
                   (or (not (:colon (:right-params params))) (&gt; count 0)))
              (and max-count (&gt;= count max-count)))
        navigator
        (let [[sublist navigator] (next-arg-or-nil navigator)
              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]
          (if (= :colon-up-arrow (first iter-result))
            navigator
            (recur (inc count) navigator)))))))</pre></td></tr><tr><td class="docs"><p>The '~&lt; directive has two completely different meanings
in the '~&lt;...~>' form it does justification, but with
~&lt;...~:>' it represents the logical block operation of the
pretty printer.</p>

<p>Unfortunately, the current architecture decides what function
to call at form parsing time before the sub-clauses have been
folded, so it is left to run-time to make the decision.</p>

<p>TODO: make it possible to make these decisions at compile-time.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare format-logical-block)
(declare justify-clauses)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- logical-block-or-justify [params navigator offsets]
  (if (:colon (:right-params params))
    (format-logical-block params navigator offsets)
    (justify-clauses params navigator offsets)))</pre></td></tr><tr><td class="docs"><p>Support for the '~&lt;...~>' justification directive</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- render-clauses [clauses navigator base-navigator]
  (loop [clauses clauses
         acc []
         navigator navigator]
    (if (empty? clauses)
      [acc navigator]
      (let [clause (first clauses)
            [iter-result result-str] (binding [*out* (java.io.StringWriter.)]
                                       [(execute-sub-format clause navigator base-navigator) 
                                        (.toString *out*)])]
        (if (= :up-arrow (first iter-result))
          [acc (second iter-result)]
          (recur (next clauses) (conj acc result-str) iter-result))))))</pre></td></tr><tr><td class="docs"><p>TODO support for ~:; constructions</p>
</td><td class="codes"><pre class="brush: clojure">(defn- justify-clauses [params navigator offsets]
  (let [[[eol-str] new-navigator] (when-let [else (:else params)]
                                    (render-clauses else navigator (:base-args params)))
        navigator (or new-navigator navigator)
        [else-params new-navigator] (when-let [p (:else-params params)]
                                      (realize-parameter-list p navigator))
        navigator (or new-navigator navigator)
        min-remaining (or (first (:min-remaining else-params)) 0)
        max-columns (or (first (:max-columns else-params))
                        (get-max-column *out*))
        clauses (:clauses params)
        [strs navigator] (render-clauses clauses navigator (:base-args params))
        slots (max 1
                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))
        chars (reduce + (map count strs))
        mincol (:mincol params)
        minpad (:minpad params)
        colinc (:colinc params)
        minout (+ chars (* slots minpad))
        result-columns (if (&lt;= minout mincol) 
                         mincol
                         (+ mincol (* colinc
                                      (+ 1 (quot (- minout mincol 1) colinc)))))
        total-pad (- result-columns chars)
        pad (max minpad (quot total-pad slots))
        extra-pad (- total-pad (* pad slots))
        pad-str (apply str (repeat pad (:padchar params)))]
    (if (and eol-str (&gt; (+ (get-column (:base @@*out*)) min-remaining result-columns) 
                        max-columns))
      (print eol-str))
    (loop [slots slots
           extra-pad extra-pad
           strs strs
           pad-only (or (:colon params)
                        (and (= (count strs) 1) (not (:at params))))]
      (if (seq strs)
        (do
          (print (str (if (not pad-only) (first strs))
                      (if (or pad-only (next strs) (:at params)) pad-str)
                      (if (pos? extra-pad) (:padchar params))))
          (recur 
           (dec slots)
           (dec extra-pad)
           (if pad-only strs (next strs))
           false))))
    navigator))</pre></td></tr><tr><td class="docs"><p>Support for case modification with ~(...~).
We do this by wrapping the underlying writer with
a special writer to do the appropriate modification. This
allows us to support arbitrary-sized output and sources
that may block.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a proxy that wraps writer, converting all characters to lower case</p>
</td><td class="codes"><pre class="brush: clojure">(defn- downcase-writer 
  [^java.io.Writer writer]
  (proxy [java.io.Writer] []
    (close [] (.close writer))
    (flush [] (.flush writer))
    (write ([^chars cbuf ^Integer off ^Integer len] 
              (.write writer cbuf off len))
           ([x]
              (condp = (class x)
		String 
		(let [s ^String x]
		  (.write writer (.toLowerCase s)))
		Integer
		(let [c ^Character x]
		  (.write writer (int (Character/toLowerCase (char c))))))))))</pre></td></tr><tr><td class="docs"><p>Returns a proxy that wraps writer, converting all characters to upper case</p>
</td><td class="codes"><pre class="brush: clojure">(defn- upcase-writer 
  [^java.io.Writer writer]
  (proxy [java.io.Writer] []
    (close [] (.close writer))
    (flush [] (.flush writer))
    (write ([^chars cbuf ^Integer off ^Integer len] 
              (.write writer cbuf off len))
           ([x]
              (condp = (class x)
		String 
		(let [s ^String x]
		  (.write writer (.toUpperCase s)))
		Integer
		(let [c ^Character x]
		  (.write writer (int (Character/toUpperCase (char c))))))))))</pre></td></tr><tr><td class="docs"><p>Capitalizes the words in a string. If first? is false, don't capitalize the 
                                      first character of the string even if it's a letter.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- capitalize-string
  [s first?]
  (let [^Character f (first s) 
        s (if (and first? f (Character/isLetter f))
            (str (Character/toUpperCase f) (subs s 1))
            s)]
    (apply str 
           (first
            (consume
             (fn [s]
               (if (empty? s)
                 [nil nil]
                 (let [m (re-matcher #&quot;\W\w&quot; s)
                       match (re-find m)
                       offset (and match (inc (.start m)))]
                   (if offset
                     [(str (subs s 0 offset) 
                           (Character/toUpperCase ^Character (nth s offset)))
                      (subs s (inc offset))]
                     [s nil]))))
             s)))))</pre></td></tr><tr><td class="docs"><p>Returns a proxy that wraps writer, captializing all words</p>
</td><td class="codes"><pre class="brush: clojure">(defn- capitalize-word-writer
  [^java.io.Writer writer]
  (let [last-was-whitespace? (ref true)] 
    (proxy [java.io.Writer] []
      (close [] (.close writer))
      (flush [] (.flush writer))
      (write 
       ([^chars cbuf ^Integer off ^Integer len] 
          (.write writer cbuf off len))
       ([x]
          (condp = (class x)
            String 
            (let [s ^String x]
              (.write writer 
                      ^String (capitalize-string (.toLowerCase s) @last-was-whitespace?))
              (when (pos? (.length s))
                (dosync 
                 (ref-set last-was-whitespace? 
                          (Character/isWhitespace 
                           ^Character (nth s (dec (count s))))))))
            Integer
            (let [c (char x)]
              (let [mod-c (if @last-was-whitespace? (Character/toUpperCase (char x)) c)]
                (.write writer (int mod-c))
                (dosync (ref-set last-was-whitespace? (Character/isWhitespace (char x))))))))))))</pre></td></tr><tr><td class="docs"><p>Returns a proxy that wraps writer, capitalizing the first word</p>
</td><td class="codes"><pre class="brush: clojure">(defn- init-cap-writer
  [^java.io.Writer writer]
  (let [capped (ref false)] 
    (proxy [java.io.Writer] []
      (close [] (.close writer))
      (flush [] (.flush writer))
      (write ([^chars cbuf ^Integer off ^Integer len] 
                (.write writer cbuf off len))
             ([x]
                (condp = (class x)
                 String 
                 (let [s (.toLowerCase ^String x)]
                   (if (not @capped) 
                     (let [m (re-matcher #&quot;\S&quot; s)
                           match (re-find m)
                           offset (and match (.start m))]
                       (if offset
                         (do (.write writer 
                                   (str (subs s 0 offset) 
                                        (Character/toUpperCase ^Character (nth s offset))
                                        (.toLowerCase ^String (subs s (inc offset)))))
                           (dosync (ref-set capped true)))
                         (.write writer s))) 
                     (.write writer (.toLowerCase s))))
                 Integer
                 (let [c ^Character (char x)]
                   (if (and (not @capped) (Character/isLetter c))
                     (do
                       (dosync (ref-set capped true))
                       (.write writer (int (Character/toUpperCase c))))
                     (.write writer (int (Character/toLowerCase c)))))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- modify-case [make-writer params navigator offsets]
  (let [clause (first (:clauses params))]
    (binding [*out* (make-writer *out*)] 
      (execute-sub-format clause navigator (:base-args params)))))</pre></td></tr><tr><td class="docs"><p>If necessary, wrap the writer in a PrettyWriter object</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's 
already a pretty writer. Generally, it is unneccesary to call this function, since pprint,
write, and cl-format all call it if they need to. However if you want the state to be 
preserved across calls, you will want to wrap them with this. </p>

<p>For example, when you want to generate column-aware output with multiple calls to cl-format, 
do it like in this example:</p>

<pre><code>(defn print-table [aseq column-width]
  (binding [*out* (get-pretty-writer *out*)]
    (doseq [row aseq]
      (doseq [col row]
        (cl-format true "~4D~7,vT" col column-width))
      (prn))))
</code></pre>

<p>Now when you run:</p>

<pre><code>user&gt; (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)
</code></pre>

<p>It prints a table of squares and cubes for the numbers from 1 to 10:</p>

<pre><code>   1      1       1    
   2      4       8    
   3      9      27    
   4     16      64    
   5     25     125    
   6     36     216    
   7     49     343    
   8     64     512    
   9     81     729    
  10    100    1000
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn get-pretty-writer 
  {:added &quot;1.2&quot;}
  [writer]
  (if (pretty-writer? writer) 
    writer
    (pretty-writer writer *print-right-margin* *print-miser-width*)))</pre></td></tr><tr><td class="docs"><p>Support for column-aware operations ~&amp;, ~T</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Make a newline if <em>out</em> is not already at the beginning of the line. If <em>out</em> is
not a pretty writer (which keeps track of columns), this function always outputs a newline.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fresh-line
  {:added &quot;1.2&quot;}
  []
  (if (instance? clojure.lang.IDeref *out*)
    (if (not (= 0 (get-column (:base @@*out*))))
      (prn))
    (prn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- absolute-tabulation [params navigator offsets]
  (let [colnum (:colnum params) 
        colinc (:colinc params)
        current (get-column (:base @@*out*))
        space-count (cond
                     (&lt; current colnum) (- colnum current)
                     (= colinc 0) 0
                     :else (- colinc (rem (- current colnum) colinc)))]
    (print (apply str (repeat space-count \space))))
  navigator)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- relative-tabulation [params navigator offsets]
  (let [colrel (:colnum params) 
        colinc (:colinc params)
        start-col (+ colrel (get-column (:base @@*out*)))
        offset (if (pos? colinc) (rem start-col colinc) 0)
        space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]
    (print (apply str (repeat space-count \space))))
  navigator)</pre></td></tr><tr><td class="docs"><p>Support for accessing the pretty printer from a format</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO: support ~@; per-line-prefix separator
TODO: get the whole format wrapped so we can start the lb at any column</p>
</td><td class="codes"><pre class="brush: clojure">(defn- format-logical-block [params navigator offsets]
  (let [clauses (:clauses params)
        clause-count (count clauses)
        prefix (cond
                (&gt; clause-count 1) (:string (:params (first (first clauses))))
                (:colon params) &quot;(&quot;)
        body (nth clauses (if (&gt; clause-count 1) 1 0))
        suffix (cond
                (&gt; clause-count 2) (:string (:params (first (nth clauses 2))))
                (:colon params) &quot;)&quot;)
        [arg navigator] (next-arg navigator)]
    (pprint-logical-block :prefix prefix :suffix suffix
      (execute-sub-format 
       body 
       (init-navigator arg)
       (:base-args params)))
    navigator))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- set-indent [params navigator offsets]
  (let [relative-to (if (:colon params) :current :block)]
    (pprint-indent relative-to (:n params))
    navigator))</pre></td></tr><tr><td class="docs"><p>TODO: support ~:T section options for ~T</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- conditional-newline [params navigator offsets]
  (let [kind (if (:colon params) 
               (if (:at params) :mandatory :fill)
               (if (:at params) :miser :linear))]
    (pprint-newline kind)
    navigator))</pre></td></tr><tr><td class="docs"><p>The table of directives we support, each with its params,
properties, and the compilation function</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>We start with a couple of helpers</p>
</td><td class="codes"><pre class="brush: clojure">(defn- process-directive-table-element [ [ char params flags bracket-info &amp; generator-fn ] ]
  [char, 
   {:directive char,
    :params `(array-map ~@params),
    :flags flags,
    :bracket-info bracket-info,
    :generator-fn (concat '(fn [ params offset]) generator-fn) }])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true}
  defdirectives 
  [ &amp; directives ]
  `(def ^{:private true}
        directive-table (hash-map ~@(mapcat process-directive-table-element directives))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defdirectives 
  (\A 
   [ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\space Character] ] 
   #{ :at :colon :both} {}
   #(format-ascii print-str %1 %2 %3))

  (\S 
   [ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\space Character] ] 
   #{ :at :colon :both} {}
   #(format-ascii pr-str %1 %2 %3))

  (\D
   [ :mincol [0 Integer] :padchar [\space Character] :commachar [\, Character] 
    :commainterval [ 3 Integer]]
   #{ :at :colon :both } {}
   #(format-integer 10 %1 %2 %3))

  (\B
   [ :mincol [0 Integer] :padchar [\space Character] :commachar [\, Character] 
    :commainterval [ 3 Integer]]
   #{ :at :colon :both } {}
   #(format-integer 2 %1 %2 %3))

  (\O
   [ :mincol [0 Integer] :padchar [\space Character] :commachar [\, Character] 
    :commainterval [ 3 Integer]]
   #{ :at :colon :both } {}
   #(format-integer 8 %1 %2 %3))

  (\X
   [ :mincol [0 Integer] :padchar [\space Character] :commachar [\, Character] 
    :commainterval [ 3 Integer]]
   #{ :at :colon :both } {}
   #(format-integer 16 %1 %2 %3))

  (\R
   [:base [nil Integer] :mincol [0 Integer] :padchar [\space Character] :commachar [\, Character] 
    :commainterval [ 3 Integer]]
   #{ :at :colon :both } {}
   (do
     (cond                          ; ~R is overloaded with bizareness
       (first (:base params))     #(format-integer (:base %1) %1 %2 %3)
       (and (:at params) (:colon params))   #(format-old-roman %1 %2 %3)
       (:at params)               #(format-new-roman %1 %2 %3)
       (:colon params)            #(format-ordinal-english %1 %2 %3)
       true                       #(format-cardinal-english %1 %2 %3))))

  (\P
   [ ]
   #{ :at :colon :both } {}
   (fn [params navigator offsets]
     (let [navigator (if (:colon params) (relative-reposition navigator -1) navigator)
           strs (if (:at params) [&quot;y&quot; &quot;ies&quot;] [&quot;&quot; &quot;s&quot;])
           [arg navigator] (next-arg navigator)]
       (print (if (= arg 1) (first strs) (second strs)))
       navigator)))

  (\C
   [:char-format [nil Character]]
   #{ :at :colon :both } {}
   (cond
     (:colon params) pretty-character
     (:at params) readable-character
     :else plain-character))

  (\F
   [ :w [nil Integer] :d [nil Integer] :k [0 Integer] :overflowchar [nil Character] 
    :padchar [\space Character] ]
   #{ :at } {}
   fixed-float)

  (\E
   [ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Integer] 
    :overflowchar [nil Character] :padchar [\space Character] 
    :exponentchar [nil Character] ]
   #{ :at } {}
   exponential-float)

  (\G
   [ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Integer] 
    :overflowchar [nil Character] :padchar [\space Character] 
    :exponentchar [nil Character] ]
   #{ :at } {}
   general-float)

  (\$
   [ :d [2 Integer] :n [1 Integer] :w [0 Integer] :padchar [\space Character]]
   #{ :at :colon :both} {}
   dollar-float)

  (\% 
   [ :count [1 Integer] ] 
   #{ } {}
   (fn [params arg-navigator offsets]
     (dotimes [i (:count params)]
       (prn))
     arg-navigator))

  (\&amp;
   [ :count [1 Integer] ] 
   #{ :pretty } {}
   (fn [params arg-navigator offsets]
     (let [cnt (:count params)]
       (if (pos? cnt) (fresh-line))
       (dotimes [i (dec cnt)]
         (prn)))
     arg-navigator))

  (\| 
   [ :count [1 Integer] ] 
   #{ } {}
   (fn [params arg-navigator offsets]
     (dotimes [i (:count params)]
       (print \formfeed))
     arg-navigator))

  (\~ 
   [ :n [1 Integer] ] 
   #{ } {}
   (fn [params arg-navigator offsets]
     (let [n (:n params)]
       (print (apply str (repeat n \~)))
       arg-navigator)))

  (\newline ;; Whitespace supression is handled in the compilation loop
   [ ] 
   #{:colon :at} {}
   (fn [params arg-navigator offsets]
     (if (:at params)
       (prn))
     arg-navigator))

  (\T
   [ :colnum [1 Integer] :colinc [1 Integer] ] 
   #{ :at :pretty } {}
   (if (:at params)
     #(relative-tabulation %1 %2 %3)
     #(absolute-tabulation %1 %2 %3)))

  (\* 
   [ :n [1 Integer] ] 
   #{ :colon :at } {}
   (fn [params navigator offsets]
     (let [n (:n params)]
       (if (:at params)
         (absolute-reposition navigator n)
         (relative-reposition navigator (if (:colon params) (- n) n)))
       )))

  (\? 
   [ ] 
   #{ :at } {}
   (if (:at params)
     (fn [params navigator offsets]     ; args from main arg list
       (let [[subformat navigator] (get-format-arg navigator)]
         (execute-sub-format subformat navigator  (:base-args params))))
     (fn [params navigator offsets]     ; args from sub-list
       (let [[subformat navigator] (get-format-arg navigator)
             [subargs navigator] (next-arg navigator)
             sub-navigator (init-navigator subargs)]
         (execute-sub-format subformat sub-navigator (:base-args params))
         navigator))))
       

  (\(
   [ ]
   #{ :colon :at :both} { :right \), :allows-separator nil, :else nil }
   (let [mod-case-writer (cond
                           (and (:at params) (:colon params))
                           upcase-writer

                           (:colon params)
                           capitalize-word-writer

                           (:at params)
                           init-cap-writer

                           :else
                           downcase-writer)]
     #(modify-case mod-case-writer %1 %2 %3)))

  (\) [] #{} {} nil) 

  (\[
   [ :selector [nil Integer] ]
   #{ :colon :at } { :right \], :allows-separator true, :else :last }
   (cond
     (:colon params)
     boolean-conditional

     (:at params)
     check-arg-conditional

     true
     choice-conditional))

  (\; [:min-remaining [nil Integer] :max-columns [nil Integer]] 
   #{ :colon } { :separator true } nil) 
   
  (\] [] #{} {} nil) 

  (\{
   [ :max-iterations [nil Integer] ]
   #{ :colon :at :both} { :right \}, :allows-separator false }
   (cond
     (and (:at params) (:colon params))
     iterate-main-sublists

     (:colon params)
     iterate-list-of-sublists

     (:at params)
     iterate-main-list

     true
     iterate-sublist))

   
  (\} [] #{:colon} {} nil) 

  (\&lt;
   [:mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\space Character]]
   #{:colon :at :both :pretty} { :right \&gt;, :allows-separator true, :else :first }
   logical-block-or-justify)

  (\&gt; [] #{:colon} {} nil) 

  ;; TODO: detect errors in cases where colon not allowed
  (\^ [:arg1 [nil Integer] :arg2 [nil Integer] :arg3 [nil Integer]] 
   #{:colon} {} 
   (fn [params navigator offsets]
     (let [arg1 (:arg1 params)
           arg2 (:arg2 params)
           arg3 (:arg3 params)
           exit (if (:colon params) :colon-up-arrow :up-arrow)]
       (cond
         (and arg1 arg2 arg3)
         (if (&lt;= arg1 arg2 arg3) [exit navigator] navigator)

         (and arg1 arg2)
         (if (= arg1 arg2) [exit navigator] navigator)

         arg1
         (if (= arg1 0) [exit navigator] navigator)

         true     ; TODO: handle looking up the arglist stack for info
         (if (if (:colon params) 
               (empty? (:rest (:base-args params)))
               (empty? (:rest navigator)))
           [exit navigator] navigator))))) 

  (\W 
   [] 
   #{:at :colon :both :pretty} {}
   (if (or (:at params) (:colon params))
     (let [bindings (concat
                     (if (:at params) [:level nil :length nil] [])
                     (if (:colon params) [:pretty true] []))]
       (fn [params navigator offsets]
         (let [[arg navigator] (next-arg navigator)]
           (if (apply write arg bindings)
             [:up-arrow navigator]
             navigator))))
     (fn [params navigator offsets]
       (let [[arg navigator] (next-arg navigator)]
         (if (write-out arg)
           [:up-arrow navigator]
           navigator)))))

  (\_
   []
   #{:at :colon :both} {}
   conditional-newline)

  (\I
   [:n [0 Integer]]
   #{:colon} {}
   set-indent)
  )</pre></td></tr><tr><td class="docs"><p>Code to manage the parameters and flags associated with each
directive in the format string.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     param-pattern #&quot;^([vV]|#|('.)|([+-]?\d+)|(?=,))&quot;)
(def ^{:private true}
     special-params #{ :parameter-from-args :remaining-arg-count })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- extract-param [[s offset saw-comma]]
  (let [m (re-matcher param-pattern s)
        param (re-find m)]
    (if param
      (let [token-str (first (re-groups m))
            remainder (subs s (.end m))
            new-offset (+ offset (.end m))]
        (if (not (= \, (nth remainder 0)))
          [ [token-str offset] [remainder new-offset false]]
          [ [token-str offset] [(subs remainder 1) (inc new-offset) true]]))
      (if saw-comma 
        (format-error &quot;Badly formed parameters in format directive&quot; offset)
        [ nil [s offset]]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- extract-params [s offset] 
  (consume extract-param [s offset false]))</pre></td></tr><tr><td class="docs"><p>Translate the string representation of a param to the internalized
                                      representation</p>
</td><td class="codes"><pre class="brush: clojure">(defn- translate-param
  [[^String p offset]]
  [(cond 
    (= (.length p) 0) nil
    (and (= (.length p) 1) (contains? #{\v \V} (nth p 0))) :parameter-from-args
    (and (= (.length p) 1) (= \# (nth p 0))) :remaining-arg-count
    (and (= (.length p) 2) (= \' (nth p 0))) (nth p 1)
    true (new Integer p))
   offset])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     flag-defs { \: :colon, \@ :at })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- extract-flags [s offset]
  (consume
   (fn [[s offset flags]]
     (if (empty? s)
       [nil [s offset flags]]
       (let [flag (get flag-defs (first s))]
         (if flag
           (if (contains? flags flag)
             (format-error 
              (str &quot;Flag \ (first s) &quot;\&quot; appears more than once in a directive&quot;)
              offset)
             [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])
           [nil [s offset flags]]))))
   [s offset {}]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- check-flags [def flags]
  (let [allowed (:flags def)]
    (if (and (not (:at allowed)) (:at flags))
      (format-error (str &quot;\&quot;@\&quot; is an illegal flag for format directive \ (:directive def) &quot;\)
                    (nth (:at flags) 1)))
    (if (and (not (:colon allowed)) (:colon flags))
      (format-error (str &quot;\&quot;:\&quot; is an illegal flag for format directive \ (:directive def) &quot;\)
                    (nth (:colon flags) 1)))
    (if (and (not (:both allowed)) (:at flags) (:colon flags))
      (format-error (str &quot;Cannot combine \&quot;@\&quot; and \&quot;:\&quot; flags for format directive \ 
                         (:directive def) &quot;\)
                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))</pre></td></tr><tr><td class="docs"><p>Takes a directive definition and the list of actual parameters and
a map of flags and returns a map of the parameters and flags with defaults
filled in. We check to make sure that there are the right types and number
of parameters as well.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- map-params
  [def params flags offset]
  (check-flags def flags)
  (if (&gt; (count params) (count (:params def)))
    (format-error 
     (cl-format 
      nil 
      &quot;Too many parameters for directive \&quot;~C\&quot;: ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed&quot;
      (:directive def) (count params) (count (:params def)))
     (second (first params))))
  (doall
   (map #(let [val (first %1)]
           (if (not (or (nil? val) (contains? special-params val) 
                        (instance? (second (second %2)) val)))
             (format-error (str &quot;Parameter &quot; (name (first %2))
                                &quot; has bad type in directive \&quot;&quot; (:directive def) &quot;\&quot;: &quot;
                                (class val))
                           (second %1))) )
        params (:params def)))
  (merge                                ; create the result map
   (into (array-map) ; start with the default values, make sure the order is right
         (reverse (for [[name [default]] (:params def)] [name [default offset]])))
   (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils
   flags))                                ; and finally add the flags</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- compile-directive [s offset]
  (let [[raw-params [rest offset]] (extract-params s offset)
        [_ [rest offset flags]] (extract-flags rest offset)
        directive (first rest)
        def (get directive-table (Character/toUpperCase ^Character directive))
        params (if def (map-params def (map translate-param raw-params) flags offset))]
    (if (not directive)
      (format-error &quot;Format string ended in the middle of a directive&quot; offset))
    (if (not def)
      (format-error (str &quot;Directive \ directive &quot;\&quot; is undefined&quot;) offset))
    [(struct compiled-directive ((:generator-fn def) params offset) def params offset)
     (let [remainder (subs rest 1) 
           offset (inc offset)
           trim? (and (= \newline (:directive def))
                      (not (:colon params)))
           trim-count (if trim? (prefix-count remainder [\space \tab]) 0)
           remainder (subs remainder trim-count)
           offset (+ offset trim-count)]
       [remainder offset])]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- compile-raw-string [s offset]
  (struct compiled-directive (fn [_ a _] (print s) a) nil { :string s } offset))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- right-bracket [this] (:right (:bracket-info (:def this))))
(defn- separator? [this] (:separator (:bracket-info (:def this))))
(defn- else-separator? [this] 
  (and (:separator (:bracket-info (:def this)))
       (:colon (:params this))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare collect-clauses)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- process-bracket [this remainder]
  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))
                                           (:offset this) remainder)]
    [(struct compiled-directive 
             (:func this) (:def this) 
             (merge (:params this) (tuple-map subex (:offset this)))
             (:offset this))
     remainder]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- process-clause [bracket-info offset remainder]
  (consume 
   (fn [remainder]
     (if (empty? remainder)
       (format-error &quot;No closing bracket found.&quot; offset)
       (let [this (first remainder)
             remainder (next remainder)]
         (cond
          (right-bracket this)
          (process-bracket this remainder)
          (= (:right bracket-info) (:directive (:def this)))
          [ nil [:right-bracket (:params this) nil remainder]]
          (else-separator? this)
          [nil [:else nil (:params this) remainder]]
          (separator? this)
          [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;
          true
          [this remainder]))))
   remainder))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- collect-clauses [bracket-info offset remainder]
  (second
   (consume
    (fn [[clause-map saw-else remainder]]
      (let [[clause [type right-params else-params remainder]] 
            (process-clause bracket-info offset remainder)]
        (cond
         (= type :right-bracket)
         [nil [(merge-with concat clause-map 
                           {(if saw-else :else :clauses) [clause] 
                            :right-params right-params})
               remainder]]
         (= type :else)
         (cond
          (:else clause-map)
          (format-error &quot;Two else clauses (\&quot;~:;\&quot;) inside bracket construction.&quot; offset)
          (not (:else bracket-info))
          (format-error &quot;An else clause (\&quot;~:;\&quot;) is in a bracket type that doesn't support it.&quot; 
                        offset)
          (and (= :first (:else bracket-info)) (seq (:clauses clause-map)))
          (format-error
           &quot;The else clause (\&quot;~:;\&quot;) is only allowed in the first position for this directive.&quot; 
           offset)
          true         ; if the ~:; is in the last position, the else clause
                                        ; is next, this was a regular clause
          (if (= :first (:else bracket-info))
            [true [(merge-with concat clause-map { :else [clause] :else-params else-params})
                   false remainder]]
            [true [(merge-with concat clause-map { :clauses [clause] })
                   true remainder]]))
         (= type :separator)
         (cond
          saw-else
          (format-error &quot;A plain clause (with \&quot;~;\&quot;) follows an else clause (\&quot;~:;\&quot;) inside bracket construction.&quot; offset)
          (not (:allows-separator bracket-info))
          (format-error &quot;A separator (\&quot;~;\&quot;) is in a bracket type that doesn't support it.&quot; 
                        offset)
          true
          [true [(merge-with concat clause-map { :clauses [clause] })
                 false remainder]]))))
    [{ :clauses [] } false remainder])))</pre></td></tr><tr><td class="docs"><p>Take a linearly compiled format and process the bracket directives to give it 
   the appropriate tree structure</p>
</td><td class="codes"><pre class="brush: clojure">(defn- process-nesting
  [format]
  (first
   (consume 
    (fn [remainder]
      (let [this (first remainder)
            remainder (next remainder)
            bracket (:bracket-info (:def this))]
        (if (:right bracket)
          (process-bracket this remainder)
          [this remainder])))
    format)))</pre></td></tr><tr><td class="docs"><p>Compiles format-str into a compiled format which can be used as an argument
to cl-format just like a plain format string. Use this function for improved 
performance when you're using the same format string repeatedly</p>
</td><td class="codes"><pre class="brush: clojure">(defn- compile-format 
  [ format-str ]
;  (prlabel compiling format-str)
  (binding [*format-str* format-str]
    (process-nesting
     (first 
      (consume 
       (fn [[^String s offset]]
         (if (empty? s)
           [nil s]
           (let [tilde (.indexOf s (int \~))]
             (cond
              (neg? tilde) [(compile-raw-string s offset) [&quot;&quot; (+ offset (.length s))]]
              (zero? tilde)  (compile-directive (subs s 1) (inc offset))
              true 
              [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))
       [format-str 0])))))</pre></td></tr><tr><td class="docs"><p>determine whether a given compiled format has any directives that depend on the
column number or pretty printing</p>
</td><td class="codes"><pre class="brush: clojure">(defn- needs-pretty 
  [format]
  (loop [format format]
    (if (empty? format)
      false
      (if (or (:pretty (:flags (:def (first format))))
              (some needs-pretty (first (:clauses (:params (first format)))))
              (some needs-pretty (first (:else (:params (first format))))))
        true
        (recur (next format))))))</pre></td></tr><tr><td class="docs"><p>Executes the format with the arguments.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- execute-format 
  {:skip-wiki true}
  ([stream format args]
     (let [^java.io.Writer real-stream (cond 
                                         (not stream) (java.io.StringWriter.)
                                         (true? stream) *out*
                                         :else stream)
           ^java.io.Writer wrapped-stream (if (and (needs-pretty format) 
                                                    (not (pretty-writer? real-stream)))
                                             (get-pretty-writer real-stream)
                                             real-stream)]
       (binding [*out* wrapped-stream]
         (try
          (execute-format format args)
          (finally
           (if-not (identical? real-stream wrapped-stream)
             (.flush wrapped-stream))))
         (if (not stream) (.toString real-stream)))))
  ([format args]
     (map-passing-context 
      (fn [element context]
        (if (abort? context)
          [nil context]
          (let [[params args] (realize-parameter-list 
                               (:params element) context)
                [params offsets] (unzip-map params)
                params (assoc params :base-args args)]
            [nil (apply (:func element) [params args offsets])])))
      args
      format)
     nil))</pre></td></tr><tr><td class="docs"><p>This is a bad idea, but it prevents us from leaking private symbols
This should all be replaced by really compiled formats anyway.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} cached-compile (memoize compile-format))</pre></td></tr><tr><td class="docs"><p>Makes a function which can directly run format-in. The function is
fn [stream &amp; args] ... and returns nil unless the stream is nil (meaning 
output to a string) in which case it returns the resulting string.</p>

<p>format-in can be either a control string or a previously compiled format.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro formatter
  {:added &quot;1.2&quot;}
  [format-in]
  `(let [format-in# ~format-in
         my-c-c# (var-get (get (ns-interns (the-ns 'clojure.pprint))
                               '~'cached-compile))
         my-e-f# (var-get (get (ns-interns (the-ns 'clojure.pprint))
                               '~'execute-format))
         my-i-n# (var-get (get (ns-interns (the-ns 'clojure.pprint))
                               '~'init-navigator))
         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]
     (fn [stream# &amp; args#]
       (let [navigator# (my-i-n# args#)]
         (my-e-f# stream# cf# navigator#)))))</pre></td></tr><tr><td class="docs"><p>Makes a function which can directly run format-in. The function is
fn [&amp; args] ... and returns nil. This version of the formatter macro is
designed to be used with <em>out</em> set to an appropriate Writer. In particular,
this is meant to be used as part of a pretty printer dispatch method.</p>

<p>format-in can be either a control string or a previously compiled format.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro formatter-out
  {:added &quot;1.2&quot;}
  [format-in]
  `(let [format-in# ~format-in
         cf# (if (string? format-in#) (#'clojure.pprint/cached-compile format-in#) format-in#)]
     (fn [&amp; args#]
       (let [navigator# (#'clojure.pprint/init-navigator args#)]
         (#'clojure.pprint/execute-format cf# navigator#)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>column_writer.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009
Revised to use proxy instead of gen-class April 2010</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements a column-aware wrapper around an instance of java.io.Writer</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import [clojure.lang IDeref]
        [java.io Writer])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:private true} *default-page-width* 72)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-field [^Writer this sym]
  (sym @@this))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- set-field [^Writer this sym new-val] 
  (alter @this assoc sym new-val))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-column [this]
  (get-field this :cur))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-line [this]
  (get-field this :line))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-max-column [this]
  (get-field this :max))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- set-max-column [this new-max]
  (dosync (set-field this :max new-max))
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-writer [this]
  (get-field this :base))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- c-write-char [^Writer this ^Integer c]
  (dosync (if (= c (int \newline))
	    (do
              (set-field this :cur 0)
              (set-field this :line (inc (get-field this :line))))
	    (set-field this :cur (inc (get-field this :cur)))))
  (.write ^Writer (get-field this :base) c))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- column-writer   
  ([writer] (column-writer writer *default-page-width*))
  ([writer max-columns]
     (let [fields (ref {:max max-columns, :cur 0, :line 0 :base writer})]
       (proxy [Writer IDeref] []
         (deref [] fields)
         (write
          ([^chars cbuf ^Integer off ^Integer len] 
             (let [^Writer writer (get-field this :base)] 
               (.write writer cbuf off len)))
          ([x]
             (condp = (class x)
               String 
               (let [^String s x
                     nl (.lastIndexOf s (int \newline))]
                 (dosync (if (neg? nl)
                           (set-field this :cur (+ (get-field this :cur) (count s)))
                           (do
                             (set-field this :cur (- (count s) nl 1))
                             (set-field this :line (+ (get-field this :line)
                                                      (count (filter #(= % \newline) s)))))))
                 (.write ^Writer (get-field this :base) s))
               Integer
               (c-write-char this x)
               Long
               (c-write-char this x))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>dispatch.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements the default dispatch tables for pretty printing code and
data.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs"><p>Installs a function as a new method of multimethod associated with dispatch-value. </p>
</td><td class="codes"><pre class="brush: clojure">(defn- use-method
  [multifn dispatch-val func]
  (. multifn addMethod dispatch-val func))</pre></td></tr><tr><td class="docs"><p>Implementations of specific dispatch table entries</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Handle forms that can be "back-translated" to reader macros
Not all reader macros can be dealt with this way or at all. 
Macros that we can't deal with at all are:
  - The comment character is aborbed by the reader and never is part of the form
`  - Is fully processed at read time into a lisp expression (which will contain concats
     and regular quotes).
~@ - Also fully eaten by the processing of ` and can't be used outside.
,  - is whitespace and is lost (like all other whitespace). Formats can generate commas
     where they deem them useful to help readability.
^  - Adding metadata completely disappears at read time and the data appears to be
     completely lost.</p>

<p>Most other syntax stuff is dealt with directly by the formats (like (), [], {}, and #{})
or directly by printing the objects using Clojure's built-in print functions (like
:keyword, \char, or ""). The notable exception is #() which is special-cased.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} reader-macros
     {'quote &quot;'&quot;, 'clojure.core/deref &quot;@&quot;, 
      'var &quot;#'&quot;, 'clojure.core/unquote &quot;~&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-reader-macro [alis]
  (let [^String macro-char (reader-macros (first alis))]
    (when (and macro-char (= 2 (count alis)))
      (.write ^java.io.Writer *out* macro-char)
      (write-out (second alis))
      true)))</pre></td></tr><tr><td class="docs"><p>Dispatch for the basic data types when interpreted
as data (as opposed to code).</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO: inline these formatter statements into funcs so that we
are a little easier on the stack. (Or, do "real" compilation, a
la Common Lisp)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def pprint-simple-list (formatter-out "~:&lt;~@{~w~^ ~_~}~:>"))</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-simple-list [alis]
  (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
    (print-length-loop [alis (seq alis)]
      (when alis
	(write-out (first alis))
	(when (next alis)
	  (.write ^java.io.Writer *out* &quot; &quot;)
	  (pprint-newline :linear)
	  (recur (next alis)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-list [alis]
  (if-not (pprint-reader-macro alis)
    (pprint-simple-list alis)))</pre></td></tr><tr><td class="docs"><p>(def pprint-vector (formatter-out "~&lt;[~;~@{~w~^ ~_~}~;]~:>"))</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-vector [avec]
  (pprint-logical-block :prefix &quot;[&quot; :suffix &quot;]&quot;
    (print-length-loop [aseq (seq avec)]
      (when aseq
	(write-out (first aseq))
	(when (next aseq)
	  (.write ^java.io.Writer *out* &quot; &quot;)
	  (pprint-newline :linear)
	  (recur (next aseq)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} pprint-array (formatter-out &quot;~&lt;[~;~@{~w~^, ~:_~}~;]~:&gt;&quot;))</pre></td></tr><tr><td class="docs"><p>(def pprint-map (formatter-out "~&lt;{~;~@{~&lt;~w~^ ~<em>~w~:>~^, ~</em>~}~;}~:>"))</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-map [amap]
  (pprint-logical-block :prefix &quot;{&quot; :suffix &quot;}&quot;
    (print-length-loop [aseq (seq amap)]
      (when aseq
	(pprint-logical-block 
          (write-out (ffirst aseq))
          (.write ^java.io.Writer *out* &quot; &quot;)
          (pprint-newline :linear)
          (set! *current-length* 0)     ; always print both parts of the [k v] pair
          (write-out (fnext (first aseq))))
        (when (next aseq)
          (.write ^java.io.Writer *out* &quot;, &quot;)
          (pprint-newline :linear)
          (recur (next aseq)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} pprint-set (formatter-out &quot;~&lt;#{~;~@{~w~^ ~:_~}~;}~:&gt;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} 
     type-map {&quot;core$future_call&quot; &quot;Future&quot;,
               &quot;core$promise&quot; &quot;Promise&quot;})</pre></td></tr><tr><td class="docs"><p>Map ugly type names to something simpler</p>
</td><td class="codes"><pre class="brush: clojure">(defn- map-ref-type 
  [name]
  (or (when-let [match (re-find #&quot;^[^$]+\$[^$]+&quot; name)]
        (type-map match))
      name))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-ideref [o]
  (let [prefix (format &quot;#&lt;%s@%x%s: &quot;
                       (map-ref-type (.getSimpleName (class o)))
                       (System/identityHashCode o)
                       (if (and (instance? clojure.lang.Agent o)
                                (agent-error o))
                         &quot; FAILED&quot;))]
    (pprint-logical-block  :prefix prefix :suffix &quot;&gt;&quot;
                           (pprint-indent :block (-&gt; (count prefix) (- 2) -))
                           (pprint-newline :linear)
                           (write-out (cond 
                                       (and (future? o) (not (future-done? o))) :pending
                                       (and (instance? clojure.lang.IPending o) (not (.isRealized o))) :not-delivered
                                       :else @o)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} pprint-pqueue (formatter-out &quot;~&lt;&lt;-(~;~@{~w~^ ~_~}~;)-&lt;~:&gt;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-simple-default [obj]
  (cond 
    (.isArray (class obj)) (pprint-array obj)
    (and *print-suppress-namespaces* (symbol? obj)) (print (name obj))
    :else (pr obj)))</pre></td></tr><tr><td class="docs"><p>The pretty print dispatch function for simple data structure format.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti 
  simple-dispatch
  {:added &quot;1.2&quot; :arglists '[[object]]} 
  class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(use-method simple-dispatch clojure.lang.ISeq pprint-list)
(use-method simple-dispatch clojure.lang.IPersistentVector pprint-vector)
(use-method simple-dispatch clojure.lang.IPersistentMap pprint-map)
(use-method simple-dispatch clojure.lang.IPersistentSet pprint-set)
(use-method simple-dispatch clojure.lang.PersistentQueue pprint-pqueue)
(use-method simple-dispatch clojure.lang.IDeref pprint-ideref)
(use-method simple-dispatch nil pr)
(use-method simple-dispatch :default pprint-simple-default)</pre></td></tr><tr><td class="docs"><p>Dispatch for the code table</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare pprint-simple-code-list)</pre></td></tr><tr><td class="docs"><p>Format something that looks like a simple def (sans metadata, since the reader
won't give it to us now).</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} pprint-hold-first (formatter-out &quot;~:&lt;~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:&gt;&quot;))</pre></td></tr><tr><td class="docs"><p>Format something that looks like a defn or defmacro</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Format the params and body of a defn with a single arity</p>
</td><td class="codes"><pre class="brush: clojure">(defn- single-defn [alis has-doc-str?]
  (if (seq alis)
    (do
      (if has-doc-str?
        ((formatter-out &quot; ~_&quot;))
        ((formatter-out &quot; ~@_&quot;)))
      ((formatter-out &quot;~{~w~^ ~_~}&quot;) alis))))</pre></td></tr><tr><td class="docs"><p>Format the param and body sublists of a defn with multiple arities</p>
</td><td class="codes"><pre class="brush: clojure">(defn- multi-defn [alis has-doc-str?]
  (if (seq alis)
    ((formatter-out &quot; ~_~{~w~^ ~_~}&quot;) alis)))</pre></td></tr><tr><td class="docs"><p>TODO: figure out how to support capturing metadata in defns (we might need a 
special reader)</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-defn [alis]
  (if (next alis) 
    (let [[defn-sym defn-name &amp; stuff] alis
          [doc-str stuff] (if (string? (first stuff))
                            [(first stuff) (next stuff)]
                            [nil stuff])
          [attr-map stuff] (if (map? (first stuff))
                             [(first stuff) (next stuff)]
                             [nil stuff])]
      (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
        ((formatter-out &quot;~w ~1I~@_~w&quot;) defn-sym defn-name)
        (if doc-str
          ((formatter-out &quot; ~_~w&quot;) doc-str))
        (if attr-map
          ((formatter-out &quot; ~_~w&quot;) attr-map))
        ;; Note: the multi-defn case will work OK for malformed defns too
        (cond
         (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))
         :else (multi-defn stuff (or doc-str attr-map)))))
    (pprint-simple-code-list alis)))</pre></td></tr><tr><td class="docs"><p>Format something with a binding form</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-binding-form [binding-vec]
  (pprint-logical-block :prefix &quot;[&quot; :suffix &quot;]&quot;
    (print-length-loop [binding binding-vec]
      (when (seq binding)
        (pprint-logical-block binding
          (write-out (first binding))
          (when (next binding)
            (.write ^java.io.Writer *out* &quot; &quot;)
            (pprint-newline :miser)
            (write-out (second binding))))
        (when (next (rest binding))
          (.write ^java.io.Writer *out* &quot; &quot;)
          (pprint-newline :linear)
          (recur (next (rest binding))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-let [alis]
  (let [base-sym (first alis)]
    (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
      (if (and (next alis) (vector? (second alis)))
        (do
          ((formatter-out &quot;~w ~1I~@_&quot;) base-sym)
          (pprint-binding-form (second alis))
          ((formatter-out &quot; ~_~{~w~^ ~_~}&quot;) (next (rest alis))))
        (pprint-simple-code-list alis)))))</pre></td></tr><tr><td class="docs"><p>Format something that looks like "if"</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} pprint-if (formatter-out &quot;~:&lt;~1I~w~^ ~@_~w~@{ ~_~w~}~:&gt;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-cond [alis]
  (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
    (pprint-indent :block 1)
    (write-out (first alis))
    (when (next alis)
      (.write ^java.io.Writer *out* &quot; &quot;)
      (pprint-newline :linear)
     (print-length-loop [alis (next alis)]
       (when alis
         (pprint-logical-block alis
          (write-out (first alis))
          (when (next alis)
            (.write ^java.io.Writer *out* &quot; &quot;)
            (pprint-newline :miser)
            (write-out (second alis))))
         (when (next (rest alis))
           (.write ^java.io.Writer *out* &quot; &quot;)
           (pprint-newline :linear)
           (recur (next (rest alis)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-condp [alis]
  (if (&gt; (count alis) 3) 
    (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
      (pprint-indent :block 1)
      (apply (formatter-out &quot;~w ~@_~w ~@_~w ~_&quot;) alis)
      (print-length-loop [alis (seq (drop 3 alis))]
        (when alis
          (pprint-logical-block alis
            (write-out (first alis))
            (when (next alis)
              (.write ^java.io.Writer *out* &quot; &quot;)
              (pprint-newline :miser)
              (write-out (second alis))))
          (when (next (rest alis))
            (.write ^java.io.Writer *out* &quot; &quot;)
            (pprint-newline :linear)
            (recur (next (rest alis)))))))
    (pprint-simple-code-list alis)))</pre></td></tr><tr><td class="docs"><p>The map of symbols that are defined in an enclosing #() anonymous function</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:private true} *symbol-map* {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-anon-func [alis]
  (let [args (second alis)
        nlis (first (rest (rest alis)))]
    (if (vector? args)
      (binding [*symbol-map* (if (= 1 (count args)) 
                               {(first args) &quot;%&quot;}
                               (into {} 
                                     (map 
                                      #(vector %1 (str \% %2)) 
                                      args 
                                      (range 1 (inc (count args))))))]
        ((formatter-out &quot;~&lt;#(~;~@{~w~^ ~_~}~;)~:&gt;&quot;) nlis))
      (pprint-simple-code-list alis))))</pre></td></tr><tr><td class="docs"><p>The master definitions for formatting lists in code (that is, (fn args...) or
special forms).</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This is the equivalent of (formatter-out "~:&lt;~1I~@{~w~^ ~_~}~:>"), but is
easier on the stack.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-simple-code-list [alis]
  (pprint-logical-block :prefix &quot;(&quot; :suffix &quot;)&quot;
    (pprint-indent :block 1)
    (print-length-loop [alis (seq alis)]
      (when alis
	(write-out (first alis))
	(when (next alis)
	  (.write ^java.io.Writer *out* &quot; &quot;)
	  (pprint-newline :linear)
	  (recur (next alis)))))))</pre></td></tr><tr><td class="docs"><p>Take a map with symbols as keys and add versions with no namespace.
That is, if ns/sym->val is in the map, add sym->val to the result.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- two-forms [amap]
  (into {} 
        (mapcat 
         identity 
         (for [x amap] 
           [x [(symbol (name (first x))) (second x)]]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- add-core-ns [amap]
  (let [core &quot;clojure.core&quot;]
    (into {}
          (map #(let [[s f] %] 
                  (if (not (or (namespace s) (special-symbol? s)))
                    [(symbol core (name s)) f]
                    %))
               amap))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:private true} *code-table*
     (two-forms
      (add-core-ns
       {'def pprint-hold-first, 'defonce pprint-hold-first, 
	'defn pprint-defn, 'defn- pprint-defn, 'defmacro pprint-defn, 'fn pprint-defn,
        'let pprint-let, 'loop pprint-let, 'binding pprint-let,
        'with-local-vars pprint-let, 'with-open pprint-let, 'when-let pprint-let,
	'if-let pprint-let, 'doseq pprint-let, 'dotimes pprint-let,
	'when-first pprint-let,
        'if pprint-if, 'if-not pprint-if, 'when pprint-if, 'when-not pprint-if,
        'cond pprint-cond, 'condp pprint-condp,
        'fn* pprint-anon-func,
        '. pprint-hold-first, '.. pprint-hold-first, '-&gt; pprint-hold-first,
        'locking pprint-hold-first, 'struct pprint-hold-first,
        'struct-map pprint-hold-first, 
        })))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-code-list [alis]
  (if-not (pprint-reader-macro alis) 
    (if-let [special-form (*code-table* (first alis))]
      (special-form alis)
      (pprint-simple-code-list alis))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pprint-code-symbol [sym] 
  (if-let [arg-num (sym *symbol-map*)]
    (print arg-num)
    (if *print-suppress-namespaces* 
      (print (name sym))
      (pr sym))))</pre></td></tr><tr><td class="docs"><p>The pretty print dispatch function for pretty printing Clojure code.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti 
  code-dispatch
  {:added &quot;1.2&quot; :arglists '[[object]]} 
  class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(use-method code-dispatch clojure.lang.ISeq pprint-code-list)
(use-method code-dispatch clojure.lang.Symbol pprint-code-symbol)</pre></td></tr><tr><td class="docs"><p>The following are all exact copies of simple-dispatch</p>
</td><td class="codes"><pre class="brush: clojure">(use-method code-dispatch clojure.lang.IPersistentVector pprint-vector)
(use-method code-dispatch clojure.lang.IPersistentMap pprint-map)
(use-method code-dispatch clojure.lang.IPersistentSet pprint-set)
(use-method code-dispatch clojure.lang.PersistentQueue pprint-pqueue)
(use-method code-dispatch clojure.lang.IDeref pprint-ideref)
(use-method code-dispatch nil pr)
(use-method code-dispatch :default pprint-simple-default)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set-pprint-dispatch simple-dispatch)</pre></td></tr><tr><td class="docs"><p>An implementation of a Common Lisp compatible format function</p>

<p>For testing</p>
</td><td class="codes"><pre class="brush: clojure">(comment
(with-pprint-dispatch code-dispatch 
  (pprint 
   '(defn cl-format 
      [stream format-in &amp; args]
      (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)
            navigator (init-navigator args)]
        (execute-format stream compiled-format navigator)))))
(with-pprint-dispatch code-dispatch 
  (pprint 
   '(defn cl-format 
      [stream format-in &amp; args]
      (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)
            navigator (init-navigator args)]
        (execute-format stream compiled-format navigator)))))
(with-pprint-dispatch code-dispatch 
  (pprint
   '(defn- -write 
      ([this x]
         (condp = (class x)
           String 
           (let [s0 (write-initial-lines this x)
                 s (.replaceFirst s0 &quot;\\s+$&quot; )
                 white-space (.substring s0 (count s))
                 mode (getf :mode)]
             (if (= mode :writing)
               (dosync
                (write-white-space this)
                (.col_write this s)
                (setf :trailing-white-space white-space))
               (add-to-buffer this (make-buffer-blob s white-space))))
           Integer
           (let [c ^Character x]
             (if (= (getf :mode) :writing)
               (do 
                 (write-white-space this)
                 (.col_write this x))
               (if (= c (int \newline))
                 (write-initial-lines this &quot;\n&quot;)
                 (add-to-buffer this (make-buffer-blob (str (char c)) nil))))))))))
(with-pprint-dispatch code-dispatch 
  (pprint 
   '(defn pprint-defn [writer alis]
      (if (next alis) 
        (let [[defn-sym defn-name &amp; stuff] alis
              [doc-str stuff] (if (string? (first stuff))
                                [(first stuff) (next stuff)]
                                [nil stuff])
              [attr-map stuff] (if (map? (first stuff))
                                 [(first stuff) (next stuff)]
                                 [nil stuff])]
          (pprint-logical-block writer :prefix &quot;(&quot; :suffix &quot;)&quot;
                                (cl-format true &quot;~w ~1I~@_~w&quot; defn-sym defn-name)
                                (if doc-str
                                  (cl-format true &quot; ~_~w&quot; doc-str))
                                (if attr-map
                                  (cl-format true &quot; ~_~w&quot; attr-map))
                                ;; Note: the multi-defn case will work OK for malformed defns too
                                (cond
                                  (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))
                                  :else (multi-defn stuff (or doc-str attr-map)))))
        (pprint-simple-code-list writer alis))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">nil
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>pprint_base.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements the generic pretty print functions and special variables</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs"><p>Variables that control the pretty printer</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p><em>print-length</em>, <em>print-level</em> and <em>print-dup</em> are defined in clojure.core
TODO: use <em>print-dup</em> here (or is it supplanted by other variables?)
TODO: make dispatch items like "(let..." get counted in <em>print-length</em>
constructs</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Bind to true if you want write to use pretty printing</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc , :added &quot;1.2&quot;}
 *print-pretty* true)</pre></td></tr><tr><td class="docs"><p>The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch
to modify.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic ; If folks have added stuff here, don't overwrite
 ^{:doc ,
   :added &quot;1.2&quot;}
 *print-pprint-dispatch* nil)</pre></td></tr><tr><td class="docs"><p>Pretty printing will try to avoid anything going beyond this column.
Set it to nil to have pprint let the line be arbitrarily long. This will ignore all 
non-mandatory newlines.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc ,
   :added &quot;1.2&quot;}
 *print-right-margin* 72)</pre></td></tr><tr><td class="docs"><p>The column at which to enter miser style. Depending on the dispatch table, 
miser style add newlines in more places to try to keep lines short allowing for further 
levels of nesting.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc ,
   :added &quot;1.2&quot;}
 *print-miser-width* 40)</pre></td></tr><tr><td class="docs"><p>Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)</p>

<p>TODO implement output limiting</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:private true,
   :doc }
 *print-lines* nil)</pre></td></tr><tr><td class="docs"><p>Mark circular structures (N.B. This is not yet used)</p>

<p>TODO: implement circle and shared</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:private true,
   :doc }
 *print-circle* nil)</pre></td></tr><tr><td class="docs"><p>Mark repeated structures rather than repeat them (N.B. This is not yet used)</p>

<p>TODO: should we just use <em>print-dup</em> here?</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:private true,
   :doc }
 *print-shared* nil)</pre></td></tr><tr><td class="docs"><p>Don't print namespaces with symbols. This is particularly useful when 
pretty printing the results of macro expansions</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.2&quot;}
 *print-suppress-namespaces* nil)</pre></td></tr><tr><td class="docs"><p>Print a radix specifier in front of integers and rationals. If <em>print-base</em> is 2, 8, 
or 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the 
radix specifier is in the form #XXr where XX is the decimal value of <em>print-base</em> </p>

<p>TODO: support print-base and print-radix in cl-format
TODO: support print-base and print-radix in rationals</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.2&quot;}
 *print-radix* nil)</pre></td></tr><tr><td class="docs"><p>The base to use for printing integers and rationals.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.2&quot;}
 *print-base* 10)</pre></td></tr><tr><td class="docs"><p>Internal variables that keep track of where we are in the 
structure</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def  ^:dynamic ^{ :private true } *current-level* 0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{ :private true } *current-length* nil)</pre></td></tr><tr><td class="docs"><p>TODO: add variables for length, lines.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Support for the write function</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare format-simple-number)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} orig-pr pr)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pr-with-base [x]
  (if-let [s (format-simple-number x)]
    (print s)
    (orig-pr x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} write-option-table
     {;:array            *print-array*
      :base             'clojure.pprint/*print-base*,
      ;;:case             *print-case*,
      :circle           'clojure.pprint/*print-circle*,
      ;;:escape           *print-escape*,
      ;;:gensym           *print-gensym*,
      :length           'clojure.core/*print-length*,
      :level            'clojure.core/*print-level*,
      :lines            'clojure.pprint/*print-lines*,
      :miser-width      'clojure.pprint/*print-miser-width*,
      :dispatch         'clojure.pprint/*print-pprint-dispatch*,
      :pretty           'clojure.pprint/*print-pretty*,
      :radix            'clojure.pprint/*print-radix*,
      :readably         'clojure.core/*print-readably*,
      :right-margin     'clojure.pprint/*print-right-margin*,
      :suppress-namespaces 'clojure.pprint/*print-suppress-namespaces*})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} binding-map [amap &amp; body]
  (let []
    `(do
       (. clojure.lang.Var (pushThreadBindings ~amap))
       (try
        ~@body
        (finally
         (. clojure.lang.Var (popThreadBindings)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- table-ize [t m] 
  (apply hash-map (mapcat 
                   #(when-let [v (get t (key %))] [(find-var v) (val %)]) 
                   m)))</pre></td></tr><tr><td class="docs"><p>Return true iff x is a PrettyWriter</p>
</td><td class="codes"><pre class="brush: clojure">(defn- pretty-writer? 
  [x] (and (instance? clojure.lang.IDeref x) (:pretty-writer @@x)))</pre></td></tr><tr><td class="docs"><p>Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width</p>
</td><td class="codes"><pre class="brush: clojure">(defn- make-pretty-writer 
  [base-writer right-margin miser-width]
  (pretty-writer base-writer right-margin miser-width))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} with-pretty-writer [base-writer &amp; body]
  `(let [base-writer# ~base-writer
         new-writer# (not (pretty-writer? base-writer#))]
     (binding [*out* (if new-writer#
                      (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)
                      base-writer#)]
       ~@body
       (.flush *out*))))</pre></td></tr><tr><td class="docs"><p>Write an object to <em>out</em> subject to the current bindings of the printer control 
variables. Use the kw-args argument to override individual variables for this call (and 
any recursive calls).</p>

<p><em>out</em> must be a PrettyWriter if pretty printing is enabled. This is the responsibility
of the caller.</p>

<p>This method is primarily intended for use by pretty print dispatch functions that 
already know that the pretty printer will have set up their environment appropriately.
Normal library clients should use the standard "write" interface. </p>

<p>TODO: if pretty print is not set, don't use pr but rather something that respects <em>print-base</em>, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defn write-out 
  {:added &quot;1.2&quot;}
  [object]
  (let [length-reached (and 
                        *current-length*
                        *print-length*
                        (&gt;= *current-length* *print-length*))]
    (if-not *print-pretty*
      (pr object)
      (if length-reached
        (print &quot;...&quot;)
        (do
          (if *current-length* (set! *current-length* (inc *current-length*)))
          (*print-pprint-dispatch* object))))
    length-reached))</pre></td></tr><tr><td class="docs"><p>Write an object subject to the current bindings of the printer control variables.
Use the kw-args argument to override individual variables for this call (and any 
recursive calls). Returns the string result if :stream is nil or nil otherwise.</p>

<p>The following keyword arguments can be passed with values:
  Keyword              Meaning                              Default value
  :stream              Writer for output or nil             true (indicates <em>out</em>)
  :base                Base to use for writing rationals    Current value of <em>print-base</em>
  :circle*             If true, mark circular structures    Current value of <em>print-circle</em>
  :length              Maximum elements to show in sublists Current value of <em>print-length</em>
  :level               Maximum depth                        Current value of <em>print-level</em>
  :lines*              Maximum lines of output              Current value of <em>print-lines</em>
  :miser-width         Width to enter miser mode            Current value of <em>print-miser-width</em>
  :dispatch            The pretty print dispatch function   Current value of <em>print-pprint-dispatch</em>
  :pretty              If true, do pretty printing          Current value of <em>print-pretty</em>
  :radix               If true, prepend a radix specifier   Current value of <em>print-radix</em>
  :readably*           If true, print readably              Current value of <em>print-readably</em>
  :right-margin        The column for the right margin      Current value of <em>print-right-margin</em>
  :suppress-namespaces If true, no namespaces in symbols    Current value of <em>print-suppress-namespaces</em></p>

<ul>
<li>= not yet supported</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn write 
  {:added &quot;1.2&quot;}
  [object &amp; kw-args]
  (let [options (merge {:stream true} (apply hash-map kw-args))]
    (binding-map (table-ize write-option-table options) 
      (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) 
        (let [optval (if (contains? options :stream) 
                       (:stream options)
                       true) 
              base-writer (condp = optval
                            nil (java.io.StringWriter.)
                            true *out*
                            optval)]
          (if *print-pretty*
            (with-pretty-writer base-writer
              (write-out object))
            (binding [*out* base-writer]
              (pr object)))
          (if (nil? optval) 
            (.toString ^java.io.StringWriter base-writer)))))))</pre></td></tr><tr><td class="docs"><p>Pretty print object to the optional output writer. If the writer is not provided, 
print the object to the currently bound value of <em>out</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pprint 
  {:added &quot;1.2&quot;}
  ([object] (pprint object *out*)) 
  ([object writer]
     (with-pretty-writer writer
       (binding [*print-pretty* true]
         (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) 
           (write-out object)))
       (if (not (= 0 (get-column *out*)))
         (prn)))))</pre></td></tr><tr><td class="docs"><p>A convenience macro that pretty prints the last thing output. This is
exactly equivalent to (pprint *1).</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro pp 
  {:added &quot;1.2&quot;}
  [] `(pprint *1))</pre></td></tr><tr><td class="docs"><p>Set the pretty print dispatch function to a function matching (fn [obj] ...)
where obj is the object to pretty print. That function will be called with <em>out</em> set
to a pretty printing writer to which it should do its printing.</p>

<p>For example functions, see simple-dispatch and code-dispatch in 
clojure.pprint.dispatch.clj.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-pprint-dispatch  
  {:added &quot;1.2&quot;}
  [function]
  (let [old-meta (meta #'*print-pprint-dispatch*)]
    (alter-var-root #'*print-pprint-dispatch* (constantly function))
    (alter-meta! #'*print-pprint-dispatch* (constantly old-meta)))
  nil)</pre></td></tr><tr><td class="docs"><p>Execute body with the pretty print dispatch function bound to function.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-pprint-dispatch 
  {:added &quot;1.2&quot;}
  [function &amp; body]
  `(binding [*print-pprint-dispatch* ~function]
     ~@body))</pre></td></tr><tr><td class="docs"><p>Support for the functional interface to the pretty printer</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-lb-options [opts body]
  (loop [body body
         acc []]
    (if (opts (first body))
      (recur (drop 2 body) (concat acc (take 2 body)))
      [(apply hash-map acc) body])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- check-enumerated-arg [arg choices]
  (if-not (choices arg)
          (throw
           (IllegalArgumentException.
            ;; TODO clean up choices string
            (str &quot;Bad argument: &quot; arg &quot;. It must be one of &quot; choices)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- level-exceeded []
  (and *print-level* (&gt;= *current-level* *print-level*)))</pre></td></tr><tr><td class="docs"><p>Execute the body as a pretty printing logical block with output to <em>out</em> which 
must be a pretty printing writer. When used from pprint or cl-format, this can be 
assumed. </p>

<p>This function is intended for use when writing custom dispatch functions.</p>

<p>Before the body, the caller can optionally specify options: :prefix, :per-line-prefix, 
and :suffix.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro pprint-logical-block 
  {:added &quot;1.2&quot;, :arglists '[[options* body]]}
  [&amp; args]
  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]
    `(do (if (#'clojure.pprint/level-exceeded) 
           (.write ^java.io.Writer *out* &quot;#&quot;)
           (do 
             (push-thread-bindings {#'clojure.pprint/*current-level*
                                    (inc (var-get #'clojure.pprint/*current-level*))
                                    #'clojure.pprint/*current-length* 0})
             (try  
              (#'clojure.pprint/start-block *out*
                           ~(:prefix options) ~(:per-line-prefix options) ~(:suffix options))
              ~@body
              (#'clojure.pprint/end-block *out*)
              (finally 
               (pop-thread-bindings)))))
         nil)))</pre></td></tr><tr><td class="docs"><p>Print a conditional newline to a pretty printing stream. kind specifies if the 
newline is :linear, :miser, :fill, or :mandatory. </p>

<p>This function is intended for use when writing custom dispatch functions.</p>

<p>Output is sent to <em>out</em> which must be a pretty printing writer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pprint-newline
  {:added &quot;1.2&quot;}
  [kind] 
  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})
  (nl *out* kind))</pre></td></tr><tr><td class="docs"><p>Create an indent at this point in the pretty printing stream. This defines how 
following lines are indented. relative-to can be either :block or :current depending 
whether the indent should be computed relative to the start of the logical block or
the current column position. n is an offset. </p>

<p>This function is intended for use when writing custom dispatch functions.</p>

<p>Output is sent to <em>out</em> which must be a pretty printing writer.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pprint-indent 
  {:added &quot;1.2&quot;}
  [relative-to n] 
  (check-enumerated-arg relative-to #{:block :current})
  (indent *out* relative-to n))</pre></td></tr><tr><td class="docs"><p>Tab at this point in the pretty printing stream. kind specifies whether the tab
is :line, :section, :line-relative, or :section-relative. </p>

<p>Colnum and colinc specify the target column and the increment to move the target
forward if the output is already past the original target.</p>

<p>This function is intended for use when writing custom dispatch functions.</p>

<p>Output is sent to <em>out</em> which must be a pretty printing writer.</p>

<p>THIS FUNCTION IS NOT YET IMPLEMENTED.</p>

<p>TODO a real implementation for pprint-tab</p>
</td><td class="codes"><pre class="brush: clojure">(defn pprint-tab 
  {:added &quot;1.2&quot;}
  [kind colnum colinc] 
  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})
  (throw (UnsupportedOperationException. &quot;pprint-tab is not yet implemented&quot;)))</pre></td></tr><tr><td class="docs"><p>Helpers for dispatch function writing</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pll-mod-body [var-sym body]
  (letfn [(inner [form]
                 (if (seq? form)
                   (let [form (macroexpand form)] 
                     (condp = (first form)
                       'loop* form
                       'recur (concat `(recur (inc ~var-sym)) (rest form))
                       (walk inner identity form)))
                   form))]
    (walk inner identity body)))</pre></td></tr><tr><td class="docs"><p>A version of loop that iterates at most <em>print-length</em> times. This is designed 
for use in pretty-printer dispatch functions.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro print-length-loop
  {:added &quot;1.3&quot;}
  [bindings &amp; body]
  (let [count-var (gensym &quot;length-count&quot;)
        mod-body (pll-mod-body count-var body)]
    `(loop ~(apply vector count-var 0 bindings)
       (if (or (not *print-length*) (&lt; ~count-var *print-length*))
         (do ~@mod-body)
         (.write ^java.io.Writer *out* &quot;...&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">nil
</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>pretty_writer.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009
Revised to use proxy instead of gen-class April 2010</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements a wrapper around a java.io.Writer which implements the
core of the XP algorithm.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(import [clojure.lang IDeref]
        [java.io Writer])</pre></td></tr><tr><td class="docs"><p>TODO: Support for tab directives</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Forward declarations</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare get-miser-width)</pre></td></tr><tr><td class="docs"><p>Macros to simplify dealing with types and classes. These are
really utilities, but I'm experimenting with them here.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Get the value of the field a named by the argument (which should be a keyword).</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} 
  getf 
  [sym]
  `(~sym @@~'this))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} 
  setf [sym new-val] 
  &quot;Set the value of the field SYM to NEW-VAL&quot;
  `(alter @~'this assoc ~sym ~new-val))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} 
  deftype [type-name &amp; fields]
  (let [name-str (name type-name)]
    `(do
       (defstruct ~type-name :type-tag ~@fields)
       (alter-meta! #'~type-name assoc :private true)
       (defn- ~(symbol (str &quot;make-&quot; name-str)) 
         [&amp; vals#] (apply struct ~type-name ~(keyword name-str) vals#))
       (defn- ~(symbol (str name-str &quot;?&quot;)) [x#] (= (:type-tag x#) ~(keyword name-str))))))</pre></td></tr><tr><td class="docs"><p>The data structures used by pretty-writer</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defstruct ^{:private true} logical-block
           :parent :section :start-col :indent
           :done-nl :intra-block-nl
           :prefix :per-line-prefix :suffix
           :logical-block-callback)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ancestor? [parent child]
  (loop [child (:parent child)]
    (cond 
     (nil? child) false
     (identical? parent child) true
     :else (recur (:parent child)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defstruct ^{:private true} section :parent)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- buffer-length [l] 
  (let [l (seq l)]
    (if l 
      (- (:end-pos (last l)) (:start-pos (first l)))
      0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype nl-t :type :logical-block :start-pos :end-pos)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype start-block-t :logical-block :start-pos :end-pos)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype end-block-t :logical-block :start-pos :end-pos)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)</pre></td></tr><tr><td class="docs"><p>Functions to write tokens in the output buffer</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private pp-newline (memoize #(System/getProperty &quot;line.separator&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare emit-nl)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti ^{:private true} write-token #(:type-tag %2))
(defmethod write-token :start-block-t [^Writer this token]
   (when-let [cb (getf :logical-block-callback)] (cb :start))
   (let [lb (:logical-block token)]
    (dosync
     (when-let [^String prefix (:prefix lb)] 
       (.write (getf :base) prefix))
     (let [col (get-column (getf :base))]
       (ref-set (:start-col lb) col)
       (ref-set (:indent lb) col)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod write-token :end-block-t [^Writer this token]
  (when-let [cb (getf :logical-block-callback)] (cb :end))
  (when-let [^String suffix (:suffix (:logical-block token))] 
    (.write (getf :base) suffix)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod write-token :indent-t [^Writer this token]
  (let [lb (:logical-block token)]
    (ref-set (:indent lb) 
             (+ (:offset token)
                (condp = (:relative-to token)
		  :block @(:start-col lb)
		  :current (get-column (getf :base)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod write-token :buffer-blob [^Writer this token]
  (.write (getf :base) ^String (:data token)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod write-token :nl-t [^Writer this token]
;  (prlabel wt @(:done-nl (:logical-block token)))
;  (prlabel wt (:type token) (= (:type token) :mandatory))
  (if (or (= (:type token) :mandatory)
           (and (not (= (:type token) :fill))
                @(:done-nl (:logical-block token))))
    (emit-nl this token)
    (if-let [^String tws (getf :trailing-white-space)]
      (.write (getf :base) tws)))
  (dosync (setf :trailing-white-space nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-tokens [^Writer this tokens force-trailing-whitespace]
  (doseq [token tokens]
    (if-not (= (:type-tag token) :nl-t)
      (if-let [^String tws (getf :trailing-white-space)]
	(.write (getf :base) tws)))
    (write-token this token)
    (setf :trailing-white-space (:trailing-white-space token)))
  (let [^String tws (getf :trailing-white-space)] 
    (when (and force-trailing-whitespace tws)
      (.write (getf :base) tws)
      (setf :trailing-white-space nil))))</pre></td></tr><tr><td class="docs"><p>emit-nl? method defs for each type of new line. This makes
the decision about whether to print this type of new line.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- tokens-fit? [^Writer this tokens]
;;;  (prlabel tf? (get-column (getf :base) (buffer-length tokens))
  (let [maxcol (get-max-column (getf :base))]
    (or 
     (nil? maxcol) 
     (&lt; (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- linear-nl? [this lb section]
;  (prlabel lnl? @(:done-nl lb) (tokens-fit? this section))
  (or @(:done-nl lb)
      (not (tokens-fit? this section))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- miser-nl? [^Writer this lb section]
  (let [miser-width (get-miser-width this)
        maxcol (get-max-column (getf :base))]
    (and miser-width maxcol
         (&gt;= @(:start-col lb) (- maxcol miser-width))
         (linear-nl? this lb section))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod emit-nl? :linear [newl this section _]
  (let [lb (:logical-block newl)]
    (linear-nl? this lb section)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod emit-nl? :miser [newl this section _]
  (let [lb (:logical-block newl)]
    (miser-nl? this lb section)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod emit-nl? :fill [newl this section subsection]
  (let [lb (:logical-block newl)]
    (or @(:intra-block-nl lb)
        (not (tokens-fit? this subsection))
        (miser-nl? this lb section))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod emit-nl? :mandatory [_ _ _ _]
  true)</pre></td></tr><tr><td class="docs"><p>Various support functions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-section [buffer]
  (let [nl (first buffer) 
        lb (:logical-block nl)
        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))
                                 (next buffer)))]
    [section (seq (drop (inc (count section)) buffer))])) </pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-sub-section [buffer]
  (let [nl (first buffer) 
        lb (:logical-block nl)
        section (seq (take-while #(let [nl-lb (:logical-block %)]
                                    (not (and (nl-t? %) (or (= nl-lb lb) (ancestor? nl-lb lb)))))
                            (next buffer)))]
    section)) </pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- update-nl-state [lb]
  (dosync
   (ref-set (:intra-block-nl lb) false)
   (ref-set (:done-nl lb) true)
   (loop [lb (:parent lb)]
     (if lb
       (do (ref-set (:done-nl lb) true)
           (ref-set (:intra-block-nl lb) true)
           (recur (:parent lb)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- emit-nl [^Writer this nl]
  (.write (getf :base) (pp-newline))
  (dosync (setf :trailing-white-space nil))
  (let [lb (:logical-block nl)
        ^String prefix (:per-line-prefix lb)] 
    (if prefix 
      (.write (getf :base) prefix))
    (let [^String istr (apply str (repeat (- @(:indent lb) (count prefix))
					  \space))] 
      (.write (getf :base) istr))
    (update-nl-state lb)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- split-at-newline [tokens]
  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]
    [pre (seq (drop (count pre) tokens))]))</pre></td></tr><tr><td class="docs"><p>Methods for showing token strings for debugging</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti ^{:private true} tok :type-tag)
(defmethod tok :nl-t [token]
  (:type token))
(defmethod tok :buffer-blob [token]
  (str \&quot; (:data token) (:trailing-white-space token) \&quot;))
(defmethod tok :default [token]
  (:type-tag token))
(defn- toks [toks] (map tok toks))</pre></td></tr><tr><td class="docs"><p>write-token-string is called when the set of tokens in the buffer
is longer than the available space on the line</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-token-string [this tokens]
  (let [[a b] (split-at-newline tokens)]
;;    (prlabel wts (toks a) (toks b))
    (if a (write-tokens this a false))
    (if b
      (let [[section remainder] (get-section b)
            newl (first b)]
;;         (prlabel wts (toks section)) (prlabel wts (:type newl)) (prlabel wts (toks remainder)) 
        (let [do-nl (emit-nl? newl this section (get-sub-section b))
              result (if do-nl 
                       (do
;;                          (prlabel emit-nl (:type newl))
                         (emit-nl this newl)
                         (next b))
                       b)
              long-section (not (tokens-fit? this result))
              result (if long-section
                       (let [rem2 (write-token-string this section)]
;;;                              (prlabel recurse (toks rem2))
                         (if (= rem2 section)
                           (do ; If that didn't produce any output, it has no nls
                                        ; so we'll force it
                             (write-tokens this section false)
                             remainder)
                           (into [] (concat rem2 remainder))))
                       result)
;;              ff (prlabel wts (toks result))
              ] 
          result)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-line [^Writer this]
  (dosync
   (loop [buffer (getf :buffer)]
;;     (prlabel wl1 (toks buffer))
     (setf :buffer (into [] buffer))
     (if (not (tokens-fit? this buffer))
       (let [new-buffer (write-token-string this buffer)]
;;          (prlabel wl new-buffer)
         (if-not (identical? buffer new-buffer)
                 (recur new-buffer)))))))</pre></td></tr><tr><td class="docs"><p>Add a buffer token to the buffer and see if it's time to start
writing</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-to-buffer [^Writer this token]
;  (prlabel a2b token)
  (dosync
   (setf :buffer (conj (getf :buffer) token))
   (if (not (tokens-fit? this (getf :buffer)))
     (write-line this))))</pre></td></tr><tr><td class="docs"><p>Write all the tokens that have been buffered</p>
</td><td class="codes"><pre class="brush: clojure">(defn- write-buffered-output [^Writer this]
  (write-line this)
  (if-let [buf (getf :buffer)]
    (do
      (write-tokens this buf true)
      (setf :buffer []))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-white-space [^Writer this]
  (when-let [^String tws (getf :trailing-white-space)]
    ; (prlabel wws (str &quot;*&quot; tws &quot;*&quot;))
    (.write (getf :base) tws)
    (dosync
     (setf :trailing-white-space nil))))</pre></td></tr><tr><td class="docs"><p>If there are newlines in the string, print the lines up until the last newline, 
making the appropriate adjustments. Return the remainder of the string</p>
</td><td class="codes"><pre class="brush: clojure">(defn- write-initial-lines 
  [^Writer this ^String s] 
  (let [lines (.split s &quot;\n&quot; -1)]
    (if (= (count lines) 1)
      s
      (dosync 
       (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))
             ^String l (first lines)] 
         (if (= :buffering (getf :mode))
           (let [oldpos (getf :pos)
                 newpos (+ oldpos (count l))]
             (setf :pos newpos)
             (add-to-buffer this (make-buffer-blob l nil oldpos newpos))
             (write-buffered-output this))
           (do
             (write-white-space this)
             (.write (getf :base) l)))
         (.write (getf :base) (int \newline))
         (doseq [^String l (next (butlast lines))]
           (.write (getf :base) l)
           (.write (getf :base) (pp-newline))
           (if prefix
             (.write (getf :base) prefix)))
         (setf :buffering :writing)
         (last lines))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- p-write-char [^Writer this ^Integer c]
  (if (= (getf :mode) :writing)
    (do 
      (write-white-space this)
      (.write (getf :base) c))
    (if (= c \newline)
      (write-initial-lines this &quot;\n&quot;)
      (let [oldpos (getf :pos)
            newpos (inc oldpos)]
        (dosync
         (setf :pos newpos)
         (add-to-buffer this (make-buffer-blob (str (char c)) nil oldpos newpos)))))))</pre></td></tr><tr><td class="docs"><p>Initialize the pretty-writer instance</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pretty-writer [writer max-columns miser-width]
  (let [lb (struct logical-block nil nil (ref 0) (ref 0) (ref false) (ref false))
        fields (ref {:pretty-writer true
                     :base (column-writer writer max-columns)
                     :logical-blocks lb 
                     :sections nil
                     :mode :writing
                     :buffer []
                     :buffer-block lb
                     :buffer-level 1
                     :miser-width miser-width
                     :trailing-white-space nil
                     :pos 0})]
    (proxy [Writer IDeref] []
      (deref [] fields)
      (write 
       ([x]
          ;;     (prlabel write x (getf :mode))
          (condp = (class x)
            String 
            (let [^String s0 (write-initial-lines this x)
                  ^String s (.replaceFirst s0 &quot;\\s+$&quot; )
                  white-space (.substring s0 (count s))
                  mode (getf :mode)]
              (dosync
               (if (= mode :writing)
                 (do
                   (write-white-space this)
                   (.write (getf :base) s)
                   (setf :trailing-white-space white-space))
                 (let [oldpos (getf :pos)
                       newpos (+ oldpos (count s0))]
                   (setf :pos newpos)
                   (add-to-buffer this (make-buffer-blob s white-space oldpos newpos))))))
            Integer
            (p-write-char this x)
            Long
            (p-write-char this x))))
      (flush []
             (if (= (getf :mode) :buffering)
               (dosync 
                (write-tokens this (getf :buffer) true)
                (setf :buffer []))
               (write-white-space this)))
      (close []
             (.flush this)))))</pre></td></tr><tr><td class="docs"><p>Methods for pretty-writer</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- start-block 
  [^Writer this 
   ^String prefix ^String per-line-prefix ^String suffix]
  (dosync 
   (let [lb (struct logical-block (getf :logical-blocks) nil (ref 0) (ref 0)
                    (ref false) (ref false)
                    prefix per-line-prefix suffix)]
     (setf :logical-blocks lb)
     (if (= (getf :mode) :writing)
       (do
         (write-white-space this)
          (when-let [cb (getf :logical-block-callback)] (cb :start))
          (if prefix 
           (.write (getf :base) prefix))
         (let [col (get-column (getf :base))]
           (ref-set (:start-col lb) col)
           (ref-set (:indent lb) col)))
       (let [oldpos (getf :pos)
             newpos (+ oldpos (if prefix (count prefix) 0))]
         (setf :pos newpos)
         (add-to-buffer this (make-start-block-t lb oldpos newpos)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- end-block [^Writer this]
  (dosync
   (let [lb (getf :logical-blocks)
         ^String suffix (:suffix lb)]
     (if (= (getf :mode) :writing)
       (do
         (write-white-space this)
         (if suffix
           (.write (getf :base) suffix))
         (when-let [cb (getf :logical-block-callback)] (cb :end)))
       (let [oldpos (getf :pos)
             newpos (+ oldpos (if suffix (count suffix) 0))]
         (setf :pos newpos)
         (add-to-buffer this (make-end-block-t lb oldpos newpos))))
     (setf :logical-blocks (:parent lb)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- nl [^Writer this type]
  (dosync 
   (setf :mode :buffering)
   (let [pos (getf :pos)]
     (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- indent [^Writer this relative-to offset]
  (dosync 
   (let [lb (getf :logical-blocks)]
     (if (= (getf :mode) :writing)
       (do
         (write-white-space this)
         (ref-set (:indent lb) 
                  (+ offset (condp = relative-to
			      :block @(:start-col lb)
			      :current (get-column (getf :base))))))
       (let [pos (getf :pos)]
         (add-to-buffer this (make-indent-t lb relative-to offset pos pos)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-miser-width [^Writer this]
  (getf :miser-width))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- set-miser-width [^Writer this new-miser-width]
  (dosync (setf :miser-width new-miser-width)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- set-logical-block-callback [^Writer this f]
  (dosync (setf :logical-block-callback f)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
   Prints a collection of maps in a textual table. Prints table headings
   ks, and then a line of output for each row, corresponding to the keys
   in ks. If ks are not specified, use the keys of the first item in rows.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-table
  {:added &quot;1.3&quot;}
  ([ks rows]
     (when (seq rows)
       (let [widths (map
                     (fn [k]
                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))
                     ks)
             fmts (map #(str &quot;%-&quot; % &quot;s&quot;) widths)
             fmt-row (fn [row]
                       (apply str (interpose &quot; | &quot;
                                             (for [[col fmt] (map vector (map #(get row %) ks) fmts)]
                                               (format fmt (str col))))))
             header (fmt-row (zipmap ks ks))
             bar (apply str (repeat (count header) &quot;=&quot;))]
         (println bar)
         (println header)
         (println bar)
         (doseq [row rows]
           (println (fmt-row row)))
         (println bar))))
  ([rows] (print-table (keys (first rows)) rows)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>utilities.clj -- part of the pretty printer for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Author: Tom Faulhaber
April 3, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This module implements some utility function used in formatting and pretty
printing. The functions here could go in a more general purpose library,
perhaps.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.pprint)</pre></td></tr><tr><td class="docs"><p>Helper functions for digesting formats in the various
phases of their lives.
These functions are actually pretty general.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- map-passing-context [func initial-context lis]
  (loop [context initial-context
         lis lis
         acc []]
    (if (empty? lis)
      [acc context]
    (let [this (first lis)
          remainder (next lis)
          [result new-context] (apply func [this context])]
      (recur new-context remainder (conj acc result))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- consume [func initial-context]
  (loop [context initial-context
         acc []]
    (let [[result new-context] (apply func [context])]
      (if (not result)
        [acc new-context]
      (recur new-context (conj acc result))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- consume-while [func initial-context]
  (loop [context initial-context
         acc []]
    (let [[result continue new-context] (apply func [context])]
      (if (not continue)
        [acc context]
      (recur new-context (conj acc result))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- unzip-map [m]
  &quot;Take a  map that has pairs in the value slots and produce a pair of maps, 
   the first having all the first elements of the pairs and the second all 
   the second elements of the pairs&quot;
  [(into {} (for [[k [v1 v2]] m] [k v1]))
   (into {} (for [[k [v1 v2]] m] [k v2]))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- tuple-map [m v1]
  &quot;For all the values, v, in the map, replace them with [v v1]&quot;
  (into {} (for [[k v] m] [k [v v1]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- rtrim [s c]
  &quot;Trim all instances of c from the end of sequence s&quot;
  (let [len (count s)]
    (if (and (pos? len) (= (nth s (dec (count s))) c))
      (loop [n (dec len)]
        (cond 
         (neg? n) 
         (not (= (nth s n) c)) (subs s 0 (inc n))
         true (recur (dec n))))
      s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ltrim [s c]
  &quot;Trim all instances of c from the beginning of sequence s&quot;
  (let [len (count s)]
    (if (and (pos? len) (= (nth s 0) c))
      (loop [n 0]
        (if (or (= n len) (not (= (nth s n) c)))
          (subs s n)
          (recur (inc n))))
      s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- prefix-count [aseq val]
  &quot;Return the number of times that val occurs at the start of sequence aseq, 
if val is a seq itself, count the number of times any element of val occurs at the
beginning of aseq&quot;
  (let [test (if (coll? val) (set val) #{val})]
    (loop [pos 0]
     (if (or (= pos (count aseq)) (not (test (nth aseq pos))))
       pos
       (recur (inc pos))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- prerr [&amp; args]
  &quot;Println to *err*&quot;
  (binding [*out* *err*]
    (apply println args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:private true} prlabel [prefix arg &amp; more-args]
  &quot;Print args to *err* in name = value format&quot;
  `(prerr ~@(cons (list 'quote prefix) (mapcat #(list (list 'quote %) &quot;=&quot; %) 
                                                  (cons arg (seq more-args))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.reflect" name="clojure.reflect"><h1 class="project-name">clojure.reflect</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Reflection on Host Types
Alpha - subject to change.</p>

<p>Two main entry points: </p>

<ul>
<li>type-reflect reflects on something that implements TypeReference.</li>
<li>reflect (for REPL use) reflects on the class of an instance, or
on a class if passed a class</li>
</ul>

<p>Key features:</p>

<ul>
<li><p>Exposes the read side of reflection as pure data. Reflecting
on a type returns a map with keys :bases, :flags, and :members.</p></li>
<li><p>Canonicalizes class names as Clojure symbols. Types can extend
to the TypeReference protocol to indicate that they can be
unambiguously resolved as a type name. The canonical format
requires one non-Java-ish convention: array brackets are &lt;>
instead of [] so they can be part of a Clojure symbol.</p></li>
<li><p>Pluggable Reflectors for different implementations. The default
JavaReflector is good when you have a class in hand, or use
the AsmReflector for "hands off" reflection without forcing
classes to load.</p></li>
</ul>

<p>Platform implementers must:</p>

<ul>
<li>Create an implementation of Reflector.</li>
<li>Create one or more implementations of TypeReference.</li>
<li>def default-reflector to be an instance that satisfies Reflector.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:author &quot;Stuart Halloway&quot;
      :added &quot;1.3&quot;
      :doc }
  clojure.reflect
  (:require [clojure.set :as set]))</pre></td></tr><tr><td class="docs"><p>Protocol for reflection implementers.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol Reflector
  (do-reflect [reflector typeref]))</pre></td></tr><tr><td class="docs"><p>A TypeReference can be unambiguously converted to a type name on
   the host platform.</p>

<p>   All typerefs are normalized into symbols. If you need to
   normalize a typeref yourself, call typesym.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol TypeReference
  (typename [o] &quot;Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare default-reflector)</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
   Reflect on a typeref, returning a map with :bases, :flags, and
  :members. In the discussion below, names are always Clojure symbols.</p>

<p>   :bases            a set of names of the type's bases
   :flags            a set of keywords naming the boolean attributes
                     of the type.
   :members          a set of the type's members. Each membrer is a map
                     and can be a constructor, method, or field.</p>

<p>   Keys common to all members:
   :name             name of the type 
   :declaring-class  name of the declarer
   :flags            keyword naming boolean attributes of the member</p>

<p>   Keys specific to constructors:
   :parameter-types  vector of parameter type names
   :exception-types  vector of exception type names</p>

<p>   Key specific to methods:
   :parameter-types  vector of parameter type names
   :exception-types  vector of exception type names
   :return-type      return type name</p>

<p>   Keys specific to fields:
   :type             type name</p>

<p>   Options:</p>

<pre><code> :ancestors     in addition to the keys described above, also
                include an :ancestors key with the entire set of
                ancestors, and add all ancestor members to
                :members.
 :reflector     implementation to use. Defaults to JavaReflector,
                AsmReflector is also an option.
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn type-reflect
  {:added &quot;1.3&quot;}
  [typeref &amp; options]
  (let [{:keys [ancestors reflector]}
        (merge {:reflector default-reflector}
               (apply hash-map options))
        refl (partial do-reflect reflector)
        result (refl typeref)]
    ;; could make simpler loop of two args: names an
    (if ancestors
      (let [make-ancestor-map (fn [names]
                            (zipmap names (map refl names)))]
        (loop [reflections (make-ancestor-map (:bases result))]
          (let [ancestors-visited (set (keys reflections))
                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))
                                               ancestors-visited)]
            (if (seq ancestors-to-visit)
              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))
              (apply merge-with into result {:ancestors ancestors-visited}
                     (map #(select-keys % [:members]) (vals reflections)))))))
      result)))</pre></td></tr><tr><td class="docs"><p>Alpha - subject to change.
   Reflect on the type of obj (or obj itself if obj is a class).
   Return value and options are the same as for type-reflect. </p>
</td><td class="codes"><pre class="brush: clojure">(defn reflect
  {:added &quot;1.3&quot;}
  [obj &amp; options]
  (apply type-reflect (if (class? obj) obj (class obj)) options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(load &quot;reflect/java&quot;)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#" name=""><h1 class="project-name"></h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Java-specific parts of clojure.reflect</p>
</td><td class="codes"><pre class="brush: clojure">(in-ns 'clojure.reflect)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require '[clojure.set :as set]
         '[clojure.string :as str])
(import '[clojure.asm ClassReader ClassVisitor Type]
         '[java.lang.reflect Modifier]
         java.io.InputStream)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol TypeReference
  clojure.lang.Symbol
  (typename [s] (str/replace (str s) &quot;&lt;&gt;&quot; &quot;[]&quot;))
  
  Class
  ;; neither .getName not .getSimpleName returns the right thing, so best to delegate to Type
  (typename
   [c]
   (typename (Type/getType c)))
  
  Type
  (typename
   [t]
   (-&gt; (.getClassName t))))</pre></td></tr><tr><td class="docs"><p>Given a typeref, create a legal Clojure symbol version of the
   type's name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- typesym
  [t]
  (-&gt; (typename t)
      (str/replace &quot;[]&quot; &quot;&lt;&gt;&quot;)
      (symbol)))</pre></td></tr><tr><td class="docs"><p>Given a typeref, return implied resource name. Used by Reflectors
   such as ASM that need to find and read classbytes from files.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- resource-name
  [typeref]
  (-&gt; (typename typeref)
      (str/replace &quot;.&quot; &quot;/&quot;)
      (str &quot;.class&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- access-flag
  [[name flag &amp; contexts]]
  {:name name :flag flag :contexts (set (map keyword contexts))})</pre></td></tr><tr><td class="docs"><p>Convert a Java field descriptor to a Clojure class symbol. Field
   descriptors are described in section 4.3.2 of the JVM spec, 2nd ed.:
   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152</p>
</td><td class="codes"><pre class="brush: clojure">(defn- field-descriptor-&gt;class-symbol
  [^String d]
  {:pre [(string? d)]}
  (typesym (Type/getType d)))</pre></td></tr><tr><td class="docs"><p>Convert a Java internal name to a Clojure class symbol. Internal
   names uses slashes instead of dots, e.g. java/lang/String. See
   Section 4.2 of the JVM spec, 2nd ed.:</p>

<p>   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757</p>
</td><td class="codes"><pre class="brush: clojure">(defn- internal-name-&gt;class-symbol
  [d]
  {:pre [(string? d)]}
  (typesym (Type/getObjectType d)))</pre></td></tr><tr><td class="docs"><p>The Java access bitflags, along with their friendly names and
the kinds of objects to which they can apply.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  flag-descriptors
  (vec
   (map access-flag
        [[:public 0x0001 :class :field :method]
         [:private 0x002 :class :field :method]
         [:protected 0x0004  :class :field :method]
         [:static 0x0008  :field :method]
         [:final 0x0010  :class :field :method]
         ;; :super is ancient history and is unfindable (?) by
         ;; reflection. skip it
         #_[:super 0x0020  :class]        
         [:synchronized 0x0020  :method]
         [:volatile 0x0040  :field]
         [:bridge 0x0040  :method]
         [:varargs 0x0080  :method]
         [:transient 0x0080  :field]
         [:native 0x0100  :method]
         [:interface 0x0200  :class]
         [:abstract 0x0400  :class :method]
         [:strict 0x0800  :method]
         [:synthetic 0x1000  :class :field :method]
         [:annotation 0x2000  :class]
         [:enum 0x4000  :class :field :inner]])))</pre></td></tr><tr><td class="docs"><p>Convert reflection bitflags into a set of keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- parse-flags
  [flags context]
  (reduce
   (fn [result fd]
     (if (and (get (:contexts fd) context)
              (not (zero? (bit-and flags (:flag fd)))))
       (conj result (:name fd))
       result))
   #{}
   flag-descriptors))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Constructor
  [name declaring-class parameter-types exception-types flags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- constructor-&gt;map
  [^java.lang.reflect.Constructor constructor]
  (Constructor.
   (symbol (.getName constructor))
   (typesym (.getDeclaringClass constructor))
   (vec (map typesym (.getParameterTypes constructor)))
   (vec (map typesym (.getExceptionTypes constructor)))
   (parse-flags (.getModifiers constructor) :method)))</pre></td></tr><tr><td class="docs"><p>Return a set of the declared constructors of class as a Clojure map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- declared-constructors
  [^Class cls]
  (set (map
        constructor-&gt;map
        (.getDeclaredConstructors cls))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Method
  [name return-type declaring-class parameter-types exception-types flags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- method-&gt;map
  [^java.lang.reflect.Method method]
  (Method.
   (symbol (.getName method))
   (typesym (.getReturnType method))
   (typesym (.getDeclaringClass method))
   (vec (map typesym (.getParameterTypes method)))
   (vec (map typesym (.getExceptionTypes method)))
   (parse-flags (.getModifiers method) :method)))</pre></td></tr><tr><td class="docs"><p>Return a set of the declared constructors of class as a Clojure map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- declared-methods
  [^Class cls]
  (set (map
        method-&gt;map
        (.getDeclaredMethods cls))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Field
  [name type declaring-class flags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- field-&gt;map
  [^java.lang.reflect.Field field]
  (Field.
   (symbol (.getName field))
   (typesym (.getType field))
   (typesym (.getDeclaringClass field))
   (parse-flags (.getModifiers field) :field)))</pre></td></tr><tr><td class="docs"><p>Return a set of the declared fields of class as a Clojure map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- declared-fields
  [^Class cls]
  (set (map
        field-&gt;map
        (.getDeclaredFields cls))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype JavaReflector [classloader]
  Reflector
  (do-reflect [_ typeref]
           (let [cls (Class/forName (typename typeref) false classloader)]
             {:bases (not-empty (set (map typesym (bases cls))))
              :flags (parse-flags (.getModifiers cls) :class)
              :members (set/union (declared-fields cls)
                                  (declared-methods cls)
                                  (declared-constructors cls))})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private default-reflector
     (JavaReflector. (.getContextClassLoader (Thread/currentThread))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-method-descriptor
  [^String md]
  {:parameter-types (vec (map typesym (Type/getArgumentTypes md)))
   :return-type (typesym (Type/getReturnType md))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ClassResolver
  (^InputStream resolve-class [this name]
                &quot;Given a class name, return that typeref's class bytes as an InputStream.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol ClassResolver
  clojure.lang.Fn
  (resolve-class [this typeref] (this typeref))
  
  ClassLoader
  (resolve-class [this typeref]
                 (.getResourceAsStream this (resource-name typeref))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype AsmReflector [class-resolver]
  Reflector
  (do-reflect [_ typeref]
    (with-open [is (resolve-class class-resolver typeref)]
      (let [class-symbol (typesym typeref)
            r (ClassReader. is)
            result (atom {:bases #{} :flags #{} :members #{}})]
        (.accept
         r
         (reify
          ClassVisitor
          (visit [_ version access name signature superName interfaces]
                 (let [flags (parse-flags access :class)
                       ;; ignore java.lang.Object on interfaces to match reflection
                       superName (if (and (flags :interface)
                                          (= superName &quot;java/lang/Object&quot;))
                                   nil
                                   superName)
                       bases (-&gt;&gt; (cons superName interfaces)
                                  (remove nil?)
                                  (map internal-name-&gt;class-symbol)
                                  (map symbol)
                                  (set)
                                  (not-empty))]
                   (swap! result merge {:bases bases 
                                        :flags flags})))
          (visitSource [_ name debug])
          (visitInnerClass [_ name outerName innerName access])
          (visitField [_ access name desc signature value]
                      (swap! result update-in [:members] (fnil conj #{})
                             (Field. (symbol name)
                                     (field-descriptor-&gt;class-symbol desc)
                                     class-symbol
                                     (parse-flags access :field)))
                      nil)
          (visitMethod [_ access name desc signature exceptions]
                       (when-not (= name &quot;&lt;clinit&gt;&quot;)
                         (let [constructor? (= name &quot;&lt;init&gt;&quot;)]
                           (swap! result update-in [:members] (fnil conj #{})
                                  (let [{:keys [parameter-types return-type]} (parse-method-descriptor desc)
                                        flags (parse-flags access :method)]
                                    (if constructor?
                                      (Constructor. class-symbol
                                                    class-symbol
                                                    parameter-types
                                                    (vec (map internal-name-&gt;class-symbol exceptions))
                                                    flags)
                                      (Method. (symbol name)
                                               return-type
                                               class-symbol
                                               parameter-types
                                               (vec (map internal-name-&gt;class-symbol exceptions))
                                               flags))))))
                       nil)
          (visitEnd [_])) 0)
        @result))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.repl" name="clojure.repl"><h1 class="project-name">clojure.repl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities meant to be used interactively at the REPL</p>
</td><td class="codes"><pre class="brush: clojure">(ns
  #^{:author &quot;Chris Houser, Christophe Grand, Stephen Gilardi, Michel Salim&quot;
     :doc }
  clojure.repl
  (:import (java.io LineNumberReader InputStreamReader PushbackReader)
           (clojure.lang RT Reflector)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private special-doc-map
  '{. {:url &quot;java_interop#dot&quot;
       :forms [(.instanceMember instance args*)
               (.instanceMember Classname args*)
               (Classname/staticMethod args*)
               Classname/staticField]
       :doc &quot;The instance member form works for both fields and methods.
  They all expand into calls to the dot operator at macroexpansion time.&quot;}
    def {:forms [(def symbol doc-string? init?)]
         :doc &quot;Creates and interns a global var with the name
  of symbol in the current namespace (*ns*) or locates such a var if
  it already exists.  If init is supplied, it is evaluated, and the
  root binding of the var is set to the resulting value.  If init is
  not supplied, the root binding of the var is unaffected.&quot;}
    do {:forms [(do exprs*)]
        :doc &quot;Evaluates the expressions in order and returns the value of
  the last. If no expressions are supplied, returns nil.&quot;}
    if {:forms [(if test then else?)]
        :doc &quot;Evaluates test. If not the singular values nil or false,
  evaluates and yields then, otherwise, evaluates and yields else. If
  else is not supplied it defaults to nil.&quot;}
    monitor-enter {:forms [(monitor-enter x)]
                   :doc &quot;Synchronization primitive that should be avoided
  in user code. Use the 'locking' macro.&quot;}
    monitor-exit {:forms [(monitor-exit x)]
                  :doc &quot;Synchronization primitive that should be avoided
  in user code. Use the 'locking' macro.&quot;}
    new {:forms [(Classname. args*) (new Classname args*)]
         :url &quot;java_interop#new&quot;
         :doc &quot;The args, if any, are evaluated from left to right, and
  passed to the constructor of the class named by Classname. The
  constructed object is returned.&quot;}
    quote {:forms [(quote form)]
           :doc &quot;Yields the unevaluated form.&quot;}
    recur {:forms [(recur exprs*)]
           :doc &quot;Evaluates the exprs in order, then, in parallel, rebinds
  the bindings of the recursion point to the values of the exprs.
  Execution then jumps back to the recursion point, a loop or fn method.&quot;}
    set! {:forms[(set! var-symbol expr)
                 (set! (. instance-expr instanceFieldName-symbol) expr)
                 (set! (. Classname-symbol staticFieldName-symbol) expr)]
          :url &quot;vars#set&quot;
          :doc &quot;Used to set thread-local-bound vars, Java object instance
fields, and Java class static fields.&quot;}
    throw {:forms [(throw expr)]
           :doc &quot;The expr is evaluated and thrown, therefore it should
  yield an instance of some derivee of Throwable.&quot;}
    try {:forms [(try expr* catch-clause* finally-clause?)]
         :doc &quot;catch-clause =&gt; (catch classname name expr*)
  finally-clause =&gt; (finally expr*)
  Catches and handles Java exceptions.&quot;}
    var {:forms [(var symbol)]
         :doc &quot;The symbol must resolve to a var, and the Var object
itself (not its value) is returned. The reader macro #'x expands to (var x).&quot;}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- special-doc [name-symbol]
  (assoc (or (special-doc-map name-symbol) (meta (resolve name-symbol)))
         :name name-symbol
         :special-form true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- namespace-doc [nspace]
  (assoc (meta nspace) :name (ns-name nspace)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-doc [m]
  (println &quot;-------------------------&quot;)
  (println (str (when-let [ns (:ns m)] (str (ns-name ns) &quot;/&quot;)) (:name m)))
  (cond
    (:forms m) (doseq [f (:forms m)]
                 (print &quot;  &quot;)
                 (prn f))
    (:arglists m) (prn (:arglists m)))
  (if (:special-form m)
    (do
      (println &quot;Special Form&quot;)
      (println &quot; &quot; (:doc m)) 
      (if (contains? m :url)
        (when (:url m)
          (println (str &quot;\n  Please see http://clojure.org/&quot; (:url m))))
        (println (str &quot;\n  Please see http://clojure.org/special_forms#&quot;
                      (:name m)))))
    (do
      (when (:macro m)
        (println &quot;Macro&quot;)) 
      (println &quot; &quot; (:doc m)))))</pre></td></tr><tr><td class="docs"><p>Prints documentation for any var whose documentation or name
 contains a match for re-string-or-pattern</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-doc
  {:added &quot;1.0&quot;}
  [re-string-or-pattern]
    (let [re (re-pattern re-string-or-pattern)
          ms (concat (mapcat #(sort-by :name (map meta (vals (ns-interns %))))
                             (all-ns))
                     (map namespace-doc (all-ns))
                     (map special-doc (keys special-doc-map)))]
      (doseq [m ms
              :when (and (:doc m)
                         (or (re-find (re-matcher re (:doc m)))
                             (re-find (re-matcher re (str (:name m))))))]
               (print-doc m))))</pre></td></tr><tr><td class="docs"><p>Prints documentation for a var or special form given its name</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro doc
  {:added &quot;1.0&quot;}
  [name]
  (if-let [special-name ('{&amp; fn catch try finally try} name)]
    (#'print-doc (#'special-doc special-name))
    (cond
      (special-doc-map name) `(#'print-doc (#'special-doc '~name))
      (resolve name) `(#'print-doc (meta (var ~name)))
      (find-ns name) `(#'print-doc (namespace-doc (find-ns '~name))))))</pre></td></tr><tr><td class="docs"><p><hr />
Examine Clojure functions (Vars, really)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a string of the source code for the given symbol, if it can
  find it.  This requires that the symbol resolve to a Var defined in
  a namespace for which the .clj is in the classpath.  Returns nil if
  it can't find the source.  For most REPL usage, 'source' is more
  convenient.</p>

<p>  Example: (source-fn 'filter)</p>
</td><td class="codes"><pre class="brush: clojure">(defn source-fn
  [x]
  (when-let [v (resolve x)]
    (when-let [filepath (:file (meta v))]
      (when-let [strm (.getResourceAsStream (RT/baseLoader) filepath)]
        (with-open [rdr (LineNumberReader. (InputStreamReader. strm))]
          (dotimes [_ (dec (:line (meta v)))] (.readLine rdr))
          (let [text (StringBuilder.)
                pbr (proxy [PushbackReader] [rdr]
                      (read [] (let [i (proxy-super read)]
                                 (.append text (char i))
                                 i)))]
            (read (PushbackReader. pbr))
            (str text)))))))</pre></td></tr><tr><td class="docs"><p>Prints the source code for the given symbol, if it can find it.
  This requires that the symbol resolve to a Var defined in a
  namespace for which the .clj is in the classpath.</p>

<p>  Example: (source filter)</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro source
  [n]
  `(println (or (source-fn '~n) (str &quot;Source not found&quot;))))</pre></td></tr><tr><td class="docs"><p>Given a regular expression or stringable thing, return a seq of
all definitions in all currently-loaded namespaces that match the
str-or-pattern.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apropos
  [str-or-pattern]
  (let [matches? (if (instance? java.util.regex.Pattern str-or-pattern)
                   #(re-find str-or-pattern (str %))
                   #(.contains (str %) (str str-or-pattern)))]
    (mapcat (fn [ns]
              (filter matches? (keys (ns-publics ns))))
            (all-ns))))</pre></td></tr><tr><td class="docs"><p>Returns a sorted seq of symbols naming public vars in
  a namespace</p>
</td><td class="codes"><pre class="brush: clojure">(defn dir-fn
  [ns]
  (sort (map first (ns-publics (the-ns ns)))))</pre></td></tr><tr><td class="docs"><p>Prints a sorted directory of public vars in a namespace</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro dir
  [nsname]
  `(doseq [v# (dir-fn '~nsname)]
     (println v#)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private demunge-map
  (into {&quot;$&quot; &quot;/&quot;} (map (fn [[k v]] [v k]) clojure.lang.Compiler/CHAR_MAP)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private demunge-pattern
  (re-pattern (apply str (interpose &quot;|&quot; (map #(str &quot;\\Q&quot; % &quot;\\E&quot;)
                                             (keys demunge-map))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- re-replace [re s f]
  (let [m (re-matcher re s)
        mseq (take-while identity
                         (repeatedly #(when (re-find m)
                                        [(re-groups m) (.start m) (.end m)])))]
    (apply str
           (concat
             (mapcat (fn [[_ _ start] [groups end]]
                       (if end
                         [(subs s start end) (f groups)]
                         [(subs s start)]))
                     (cons [0 0 0] mseq)
                     (concat mseq [nil]))))))</pre></td></tr><tr><td class="docs"><p>Given a string representation of a fn class,
  as in a stack trace element, returns a readable version.</p>
</td><td class="codes"><pre class="brush: clojure">(defn demunge
  {:added &quot;1.3&quot;}
  [fn-name]
  (re-replace demunge-pattern fn-name demunge-map))</pre></td></tr><tr><td class="docs"><p>Returns the initial cause of an exception or error by peeling off all of
  its wrappers</p>
</td><td class="codes"><pre class="brush: clojure">(defn root-cause
  {:added &quot;1.3&quot;}
  [^Throwable t]
  (loop [cause t]
    (if (and (instance? clojure.lang.Compiler$CompilerException cause)
             (not= (.source ^clojure.lang.Compiler$CompilerException cause) &quot;NO_SOURCE_FILE&quot;))
      cause
      (if-let [cause (.getCause cause)]
        (recur cause)
        cause))))</pre></td></tr><tr><td class="docs"><p>Returns a (possibly unmunged) string representation of a StackTraceElement</p>
</td><td class="codes"><pre class="brush: clojure">(defn stack-element-str
  {:added &quot;1.3&quot;}
  [^StackTraceElement el]
  (let [file (.getFileName el)
        clojure-fn? (and file (or (.endsWith file &quot;.clj&quot;)
                                  (= file &quot;NO_SOURCE_FILE&quot;)))]
    (str (if clojure-fn?
           (demunge (.getClassName el))
           (str (.getClassName el) &quot;.&quot; (.getMethodName el)))
         &quot; (&quot; (.getFileName el) &quot;:&quot; (.getLineNumber el) &quot;)&quot;)))</pre></td></tr><tr><td class="docs"><p>Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the
  most recent repl exception (*e), and a depth of 12.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pst
  {:added &quot;1.3&quot;}
  ([] (pst 12))
  ([e-or-depth]
     (if (instance? Throwable e-or-depth)
       (pst e-or-depth 12)
       (when-let [e *e]
         (pst (root-cause e) e-or-depth))))
  ([^Throwable e depth]
     (binding [*out* *err*]
       (println (str (-&gt; e class .getSimpleName) &quot; &quot;
                     (.getMessage e)
                     (when-let [info (ex-data e)] (str &quot; &quot; (pr-str info)))))
       (let [st (.getStackTrace e)
             cause (.getCause e)]
         (doseq [el (take depth
                          (remove #(#{&quot;clojure.lang.RestFn&quot; &quot;clojure.lang.AFn&quot;} (.getClassName %))
                                  st))]
           (println (str \tab (stack-element-str el))))
         (when cause
           (println &quot;Caused by:&quot;)
           (pst cause (min depth
                           (+ 2 (- (count (.getStackTrace cause))
                                   (count st))))))))))</pre></td></tr><tr><td class="docs"><p><hr />
Handle Ctrl-C keystrokes</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a function that takes one arg and uses that as an exception message
  to stop the given thread.  Defaults to the current thread</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-stopper
  ([] (thread-stopper (Thread/currentThread)))
  ([thread] (fn [msg] (.stop thread (Error. msg)))))</pre></td></tr><tr><td class="docs"><p>Register INT signal handler.  After calling this, Ctrl-C will cause
  the given function f to be called with a single argument, the signal.
  Uses thread-stopper if no function given.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-break-handler!
  ([] (set-break-handler! (thread-stopper)))
  ([f]
   (sun.misc.Signal/handle
     (sun.misc.Signal. &quot;INT&quot;)
     (proxy [sun.misc.SignalHandler] []
       (handle [signal]
         (f (str &quot;-- caught signal &quot; signal)))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.set" name="clojure.set"><h1 class="project-name">clojure.set</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Set operations such as union/intersection.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
       clojure.set)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- bubble-max-key [k coll]
  &quot;Move a maximal element of coll according to fn k (which returns a number) 
   to the front of coll.&quot;
  (let [max (apply max-key k coll)]
    (cons max (remove #(identical? max %) coll))))</pre></td></tr><tr><td class="docs"><p>Return a set that is the union of the input sets</p>
</td><td class="codes"><pre class="brush: clojure">(defn union
  {:added &quot;1.0&quot;}
  ([] #{})
  ([s1] s1)
  ([s1 s2]
     (if (&lt; (count s1) (count s2))
       (reduce conj s2 s1)
       (reduce conj s1 s2)))
  ([s1 s2 &amp; sets]
     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]
       (reduce into (first bubbled-sets) (rest bubbled-sets)))))</pre></td></tr><tr><td class="docs"><p>Return a set that is the intersection of the input sets</p>
</td><td class="codes"><pre class="brush: clojure">(defn intersection
  {:added &quot;1.0&quot;}
  ([s1] s1)
  ([s1 s2]
     (if (&lt; (count s2) (count s1))
       (recur s2 s1)
       (reduce (fn [result item]
                   (if (contains? s2 item)
		     result
                     (disj result item)))
	       s1 s1)))
  ([s1 s2 &amp; sets] 
     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]
       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))</pre></td></tr><tr><td class="docs"><p>Return a set that is the first set without elements of the remaining sets</p>
</td><td class="codes"><pre class="brush: clojure">(defn difference
  {:added &quot;1.0&quot;}
  ([s1] s1)
  ([s1 s2] 
     (if (&lt; (count s1) (count s2))
       (reduce (fn [result item] 
                   (if (contains? s2 item) 
                     (disj result item) 
                     result))
               s1 s1)
       (reduce disj s1 s2)))
  ([s1 s2 &amp; sets] 
     (reduce difference s1 (conj sets s2))))</pre></td></tr><tr><td class="docs"><p>Returns a set of the elements for which pred is true</p>
</td><td class="codes"><pre class="brush: clojure">(defn select
  {:added &quot;1.0&quot;}
  [pred xset]
    (reduce (fn [s k] (if (pred k) s (disj s k)))
            xset xset))</pre></td></tr><tr><td class="docs"><p>Returns a rel of the elements of xrel with only the keys in ks</p>
</td><td class="codes"><pre class="brush: clojure">(defn project
  {:added &quot;1.0&quot;}
  [xrel ks]
    (set (map #(select-keys % ks) xrel)))</pre></td></tr><tr><td class="docs"><p>Returns the map with the keys in kmap renamed to the vals in kmap</p>
</td><td class="codes"><pre class="brush: clojure">(defn rename-keys
  {:added &quot;1.0&quot;}
  [map kmap]
    (reduce 
     (fn [m [old new]]
       (if (contains? map old)
         (assoc m new (get map old))
         m)) 
     (apply dissoc map (keys kmap)) kmap))</pre></td></tr><tr><td class="docs"><p>Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap</p>
</td><td class="codes"><pre class="brush: clojure">(defn rename
  {:added &quot;1.0&quot;}
  [xrel kmap]
    (set (map #(rename-keys % kmap) xrel)))</pre></td></tr><tr><td class="docs"><p>Returns a map of the distinct values of ks in the xrel mapped to a
  set of the maps in xrel with the corresponding values of ks.</p>
</td><td class="codes"><pre class="brush: clojure">(defn index
  {:added &quot;1.0&quot;}
  [xrel ks]
    (reduce
     (fn [m x]
       (let [ik (select-keys x ks)]
         (assoc m ik (conj (get m ik #{}) x))))
     {} xrel))</pre></td></tr><tr><td class="docs"><p>Returns the map with the vals mapped to the keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-invert
  {:added &quot;1.0&quot;}
  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))</pre></td></tr><tr><td class="docs"><p>When passed 2 rels, returns the rel corresponding to the natural
  join. When passed an additional keymap, joins on the corresponding
  keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn join
  {:added &quot;1.0&quot;}
  ([xrel yrel] ;natural join
   (if (and (seq xrel) (seq yrel))
     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))
           [r s] (if (&lt;= (count xrel) (count yrel))
                   [xrel yrel]
                   [yrel xrel])
           idx (index r ks)]
       (reduce (fn [ret x]
                 (let [found (idx (select-keys x ks))]
                   (if found
                     (reduce #(conj %1 (merge %2 x)) ret found)
                     ret)))
               #{} s))
     #{}))
  ([xrel yrel km] ;arbitrary key mapping
   (let [[r s k] (if (&lt;= (count xrel) (count yrel))
                   [xrel yrel (map-invert km)]
                   [yrel xrel km])
         idx (index r (vals k))]
     (reduce (fn [ret x]
               (let [found (idx (rename-keys (select-keys x (keys k)) k))]
                 (if found
                   (reduce #(conj %1 (merge %2 x)) ret found)
                   ret)))
             #{} s))))</pre></td></tr><tr><td class="docs"><p>Is set1 a subset of set2?</p>
</td><td class="codes"><pre class="brush: clojure">(defn subset? 
  {:added &quot;1.2&quot;,
   :tag Boolean}
  [set1 set2]
  (and (&lt;= (count set1) (count set2))
       (every? #(contains? set2 %) set1)))</pre></td></tr><tr><td class="docs"><p>Is set1 a superset of set2?</p>
</td><td class="codes"><pre class="brush: clojure">(defn superset? 
  {:added &quot;1.2&quot;,
   :tag Boolean}
  [set1 set2]
  (and (&gt;= (count set1) (count set2))
       (every? #(contains? set1 %) set2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
(refer 'set)
(def xs #{{:a 11 :b 1 :c 1 :d 4}
         {:a 2 :b 12 :c 2 :d 6}
         {:a 3 :b 3 :c 3 :d 8 :f 42}})
(def ys #{{:a 11 :b 11 :c 11 :e 5}
         {:a 12 :b 11 :c 12 :e 3}
         {:a 3 :b 3 :c 3 :e 7 }})
(join xs ys)
(join xs (rename ys {:b :yb :c :yc}) {:a :a})
(union #{:a :b :c} #{:c :d :e })
(difference #{:a :b :c} #{:c :d :e})
(intersection #{:a :b :c} #{:c :d :e})
(index ys [:b]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.stacktrace" name="clojure.stacktrace"><h1 class="project-name">clojure.stacktrace</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>stacktrace.clj: print Clojure-centric stack traces</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>by Stuart Sierra
January 6, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Print stack traces oriented towards Clojure, not Java.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Stuart Sierra&quot;}
  clojure.stacktrace)</pre></td></tr><tr><td class="docs"><p>Returns the last 'cause' Throwable in a chain of Throwables.</p>
</td><td class="codes"><pre class="brush: clojure">(defn root-cause
  {:added &quot;1.1&quot;}
  [tr]
  (if-let [cause (.getCause tr)]
    (recur cause)
    tr))</pre></td></tr><tr><td class="docs"><p>Prints a Clojure-oriented view of one element in a stack trace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-trace-element
  {:added &quot;1.1&quot;}
  [e]
  (let [class (.getClassName e)
	method (.getMethodName e)] 
    (let [match (re-matches #&quot;^([A-Za-z0-9_.-]+)\$(\w+)__\d+$&quot; (str class))]
      (if (and match (= &quot;invoke&quot; method))
	(apply printf &quot;%s/%s&quot; (rest match))
	(printf &quot;%s.%s&quot; class method))))
  (printf &quot; (%s:%d)&quot; (or (.getFileName e) &quot;&quot;) (.getLineNumber e)))</pre></td></tr><tr><td class="docs"><p>Prints the class and message of a Throwable.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-throwable
  {:added &quot;1.1&quot;}
  [tr]
  (printf &quot;%s: %s&quot; (.getName (class tr)) (.getMessage tr)))</pre></td></tr><tr><td class="docs"><p>Prints a Clojure-oriented stack trace of tr, a Throwable.
  Prints a maximum of n stack frames (default: unlimited).
  Does not print chained exceptions (causes).</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-stack-trace
  {:added &quot;1.1&quot;}
  ([tr] (print-stack-trace tr nil))
  ([tr n]
     (let [st (.getStackTrace tr)]
       (print-throwable tr)
       (newline)
       (print &quot; at &quot;) 
       (print-trace-element (first st))
       (newline)
       (doseq [e (if (nil? n)
		   (rest st)
		   (take (dec n) (rest st)))]
	 (print &quot;    &quot;)
	 (print-trace-element e)
	 (newline)))))</pre></td></tr><tr><td class="docs"><p>Like print-stack-trace but prints chained exceptions (causes).</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-cause-trace
  {:added &quot;1.1&quot;}
  ([tr] (print-cause-trace tr nil))
  ([tr n]
     (print-stack-trace tr n)
     (when-let [cause (.getCause tr)]
       (print &quot;Caused by: &quot; )
       (recur cause n))))</pre></td></tr><tr><td class="docs"><p>REPL utility.  Prints a brief stack trace for the root cause of the
  most recent exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn e
  {:added &quot;1.1&quot;}
  []
  (print-stack-trace (root-cause *e) 8))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.string" name="clojure.string"><h1 class="project-name">clojure.string</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Clojure String utilities</p>

<p>It is poor form to (:use clojure.string). Instead, use require
with :as to specify a prefix, e.g.</p>

<p>(ns your.namespace.here
  (:require [clojure.string :as str]))</p>

<p>Design notes for clojure.string:</p>

<ol>
<li><p>Strings are objects (as opposed to sequences). As such, the
string being manipulated is the first argument to a function;
passing nil will result in a NullPointerException unless
documented otherwise. If you want sequence-y behavior instead,
use a sequence.</p></li>
<li><p>Functions are generally not lazy, and call straight to host
methods where those are available and efficient.</p></li>
<li><p>Functions take advantage of String implementation details to
write high-performing loop/recurs instead of using higher-order
functions. (This is not idiomatic in general-purpose application
code.)</p></li>
<li><p>When a function is documented to accept a string argument, it
will take any implementation of the correct <em>interface</em> on the
host platform. In Java, this is CharSequence, which is more
general than String. In ordinary usage you will almost always
pass concrete strings. If you are doing something unusual,
e.g. passing a mutable implementation of CharSequence, then
thead-safety is your responsibility.</p></li>
</ol>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
      :author &quot;Stuart Sierra, Stuart Halloway, David Liebke&quot;}
  clojure.string
  (:refer-clojure :exclude (replace reverse))
  (:import (java.util.regex Pattern)
           clojure.lang.LazilyPersistentVector))</pre></td></tr><tr><td class="docs"><p>Returns s with its characters reversed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String reverse
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (.toString (.reverse (StringBuilder. s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- replace-by
  [^CharSequence s re f]
  (let [m (re-matcher re s)]
    (let [buffer (StringBuffer. (.length s))]
      (loop []
        (if (.find m)
          (do (.appendReplacement m buffer (f (re-groups m)))
              (recur))
          (do (.appendTail m buffer)
              (.toString buffer)))))))</pre></td></tr><tr><td class="docs"><p>Replaces all instance of match with replacement in s.</p>

<p>   match/replacement can be:</p>

<p>   string / string
   char / char
   pattern / (string or function of match).</p>

<p>   See also replace-first.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String replace
  {:added &quot;1.2&quot;}
  [^CharSequence s match replacement]
  (let [s (.toString s)]
    (cond 
     (instance? Character match) (.replace s ^Character match ^Character replacement)
     (instance? CharSequence match) (.replace s ^CharSequence match ^CharSequence replacement)
     (instance? Pattern match) (if (instance? CharSequence replacement)
                                 (.replaceAll (re-matcher ^Pattern match s)
                                              (.toString ^CharSequence replacement))
                                 (replace-by s match replacement))
     :else (throw (IllegalArgumentException. (str &quot;Invalid match arg: &quot; match))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- replace-first-by
  [^CharSequence s ^Pattern re f]
  (let [m (re-matcher re s)]
    (let [buffer (StringBuffer. (.length s))]
      (if (.find m)
        (let [rep (f (re-groups m))]
          (.appendReplacement m buffer rep)
          (.appendTail m buffer)
          (str buffer))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- replace-first-char
  [^CharSequence s ^Character match replace]
  (let [s (.toString s)
        i (.indexOf s (int match))]
    (if (= -1 i)
      s
      (str (subs s 0 i) replace (subs s (inc i))))))</pre></td></tr><tr><td class="docs"><p>Replaces the first instance of match with replacement in s.</p>

<p>   match/replacement can be:</p>

<p>   char / char
   string / string
   pattern / (string or function of match).</p>

<p>   See also replace-all.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String replace-first
  {:added &quot;1.2&quot;}
  [^CharSequence s match replacement]
  (let [s (.toString s)]
    (cond
     (instance? Character match)
     (replace-first-char s match replacement)
     (instance? CharSequence match)
     (.replaceFirst s (Pattern/quote (.toString ^CharSequence match))
                    (.toString ^CharSequence replacement))
     (instance? Pattern match)
     (if (instance? CharSequence replacement)
       (.replaceFirst (re-matcher ^Pattern match s)
                      (.toString ^CharSequence replacement))
       (replace-first-by s match replacement))
     :else (throw (IllegalArgumentException. (str &quot;Invalid match arg: &quot; match))))))</pre></td></tr><tr><td class="docs"><p>Returns a string of all elements in coll, as returned by (seq coll),
   separated by an optional separator.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String join
  {:added &quot;1.2&quot;}
  ([coll]
     (apply str coll))
  ([separator coll]
     (loop [sb (StringBuilder. (str (first coll)))
            more (next coll)
            sep (str separator)]
       (if more
         (recur (-&gt; sb (.append sep) (.append (str (first more))))
                (next more)
                sep)
         (str sb)))))</pre></td></tr><tr><td class="docs"><p>Converts first character of the string to upper-case, all other
  characters to lower-case.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String capitalize
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (let [s (.toString s)]
    (if (&lt; (count s) 2)
      (.toUpperCase s)
      (str (.toUpperCase (subs s 0 1))
           (.toLowerCase (subs s 1))))))</pre></td></tr><tr><td class="docs"><p>Converts string to all upper-case.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String upper-case
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (.. s toString toUpperCase))</pre></td></tr><tr><td class="docs"><p>Converts string to all lower-case.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String lower-case
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (.. s toString toLowerCase))</pre></td></tr><tr><td class="docs"><p>Splits string on a regular expression.  Optional argument limit is
  the maximum number of splits. Not lazy. Returns vector of the splits.</p>
</td><td class="codes"><pre class="brush: clojure">(defn split
  {:added &quot;1.2&quot;}
  ([^CharSequence s ^Pattern re]
     (LazilyPersistentVector/createOwning (.split re s)))
  ([ ^CharSequence s ^Pattern re limit]
     (LazilyPersistentVector/createOwning (.split re s limit))))</pre></td></tr><tr><td class="docs"><p>Splits s on \n or \r\n.</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-lines
  &quot;Splits s on \\n or \\r\\n.&quot;
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (split s #&quot;\r?\n&quot;))</pre></td></tr><tr><td class="docs"><p>Removes whitespace from both ends of string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String trim
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (.. s toString trim))</pre></td></tr><tr><td class="docs"><p>Removes whitespace from the left side of string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String triml
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (loop [index (int 0)]
    (if (= (.length s) index)
      &quot;&quot;
      (if (Character/isWhitespace (.charAt s index))
        (recur (inc index))
        (.. s (subSequence index (.length s)) toString)))))</pre></td></tr><tr><td class="docs"><p>Removes whitespace from the right side of string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String trimr
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (loop [index (.length s)]
    (if (zero? index)
      &quot;&quot;
      (if (Character/isWhitespace (.charAt s (dec index)))
        (recur (dec index))
        (.. s (subSequence 0 index) toString)))))</pre></td></tr><tr><td class="docs"><p>Removes all trailing newline \n or return \r characters from
  string.  Similar to Perl's chomp.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String trim-newline
  &quot;Removes all trailing newline \\n or return \\r characters from
  string.  Similar to Perl's chomp.&quot;
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (loop [index (.length s)]
    (if (zero? index)
      &quot;&quot;
      (let [ch (.charAt s (dec index))]
        (if (or (= ch \newline) (= ch \return))
          (recur (dec index))
          (.. s (subSequence 0 index) toString))))))</pre></td></tr><tr><td class="docs"><p>True if s is nil, empty, or contains only whitespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blank?
  {:added &quot;1.2&quot;}
  [^CharSequence s]
  (if s
    (loop [index (int 0)]
      (if (= (.length s) index)
        true
        (if (Character/isWhitespace (.charAt s index))
          (recur (inc index))
          false)))
    true))</pre></td></tr><tr><td class="docs"><p>Return a new string, using cmap to escape each character ch
   from s as follows:</p>

<p>   If (cmap ch) is nil, append ch to the new string.
   If (cmap ch) is non-nil, append (str (cmap ch)) instead.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^String escape
  {:added &quot;1.2&quot;}
  [^CharSequence s cmap]
  (loop [index (int 0)
         buffer (StringBuilder. (.length s))]
    (if (= (.length s) index)
      (.toString buffer)
      (let [ch (.charAt s index)]
        (if-let [replacement (cmap ch)]
          (.append buffer replacement)
          (.append buffer ch))
        (recur (inc index) buffer)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.template" name="clojure.template"><h1 class="project-name">clojure.template</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>template.clj - anonymous functions that pre-evaluate sub-expressions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>By Stuart Sierra
June 23, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>CHANGE LOG</p>

<p>June 23, 2009: complete rewrite, eliminated <em>1,</em>2,... argument
syntax</p>

<p>January 20, 2009: added "template?" and checks for valid template
expressions.</p>

<p>December 15, 2008: first version</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Macros that expand to repeated copies of a template expression.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Stuart Sierra&quot;}
  clojure.template
  (:require [clojure.walk :as walk]))</pre></td></tr><tr><td class="docs"><p>For use in macros.  argv is an argument list, as in defn.  expr is
  a quoted expression using the symbols in argv.  values is a sequence
  of values to be used for the arguments.</p>

<p>  apply-template will recursively replace argument symbols in expr
  with their corresponding values, returning a modified expr.</p>

<p>  Example: (apply-template '[x] '(+ x x) '[2])
           ;=> (+ 2 2)</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-template
  [argv expr values]
  (assert (vector? argv))
  (assert (every? symbol? argv))
  (walk/prewalk-replace (zipmap argv values) expr))</pre></td></tr><tr><td class="docs"><p>Repeatedly copies expr (in a do block) for each group of arguments
  in values.  values are automatically partitioned by the number of
  arguments in argv, an argument vector as in defn.</p>

<p>  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))
           ;=> (do (+ 4 2) (+ 5 3))</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro do-template
  [argv expr &amp; values]
  (let [c (count argv)]
    `(do ~@(map (fn [a] (apply-template argv expr a)) 
                (partition c values)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.test" name="clojure.test"><h1 class="project-name">clojure.test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>test.clj: test framework for Clojure</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>by Stuart Sierra
March 28, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Thanks to Chas Emerick, Allen Rohner, and Stuart Halloway for
contributions and suggestions.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A unit testing framework.</p>

<p>   ASSERTIONS</p>

<p>   The core of the library is the "is" macro, which lets you make
   assertions of any arbitrary expression:</p>

<p>   (is (= 4 (+ 2 2)))
   (is (instance? Integer 256))
   (is (.startsWith "abcde" "ab"))</p>

<p>   You can type an "is" expression directly at the REPL, which will
   print a message if it fails.</p>

<pre><code>   user&gt; (is (= 5 (+ 2 2)))

   FAIL in  (:1)
   expected: (= 5 (+ 2 2))
     actual: (not (= 5 4))
   false
</code></pre>

<p>   The "expected:" line shows you the original expression, and the
   "actual:" shows you what actually happened.  In this case, it
   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the
   "false" on the last line is the value returned from the
   expression.  The "is" macro always returns the result of the
   inner expression.</p>

<p>   There are two special assertions for testing exceptions.  The
   "(is (thrown? c ...))" form tests if an exception of class c is
   thrown:</p>

<p>   (is (thrown? ArithmeticException (/ 1 0))) </p>

<p>   "(is (thrown-with-msg? c re ...))" does the same thing and also
   tests that the message on the exception matches the regular
   expression re:</p>

<p>   (is (thrown-with-msg? ArithmeticException #"Divide by zero"
                         (/ 1 0)))</p>

<p>   DOCUMENTING TESTS</p>

<p>   "is" takes an optional second argument, a string describing the
   assertion.  This message will be included in the error report.</p>

<p>   (is (= 5 (+ 2 2)) "Crazy arithmetic")</p>

<p>   In addition, you can document groups of assertions with the
   "testing" macro, which takes a string followed by any number of
   assertions.  The string will be included in failure reports.
   Calls to "testing" may be nested, and all of the strings will be
   joined together with spaces in the final report, in a style
   similar to RSpec <a href="http://rspec.info/">http://rspec.info/</a></p>

<p>   (testing "Arithmetic"
     (testing "with positive integers"
       (is (= 4 (+ 2 2)))
       (is (= 7 (+ 3 4))))
     (testing "with negative integers"
       (is (= -4 (+ -2 -2)))
       (is (= -1 (+ 3 -4)))))</p>

<p>   Note that, unlike RSpec, the "testing" macro may only be used
   INSIDE a "deftest" or "with-test" form (see below).</p>

<p>   DEFINING TESTS</p>

<p>   There are two ways to define tests.  The "with-test" macro takes
   a defn or def form as its first argument, followed by any number
   of assertions.  The tests will be stored as metadata on the
   definition.</p>

<p>   (with-test
       (defn my-function [x y]
         (+ x y))
     (is (= 4 (my-function 2 2)))
     (is (= 7 (my-function 3 4))))</p>

<p>   As of Clojure SVN rev. 1221, this does not work with defmacro.
   See http://code.google.com/p/clojure/issues/detail?id=51</p>

<p>   The other way lets you define tests separately from the rest of
   your code, even in a different namespace:</p>

<p>   (deftest addition
     (is (= 4 (+ 2 2)))
     (is (= 7 (+ 3 4))))</p>

<p>   (deftest subtraction
     (is (= 1 (- 4 3)))
     (is (= 3 (- 7 4))))</p>

<p>   This creates functions named "addition" and "subtraction", which
   can be called like any other function.  Therefore, tests can be
   grouped and composed, in a style similar to the test framework in
   Peter Seibel's "Practical Common Lisp"
   <a href="http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html">http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html</a></p>

<p>   (deftest arithmetic
     (addition)
     (subtraction))</p>

<p>   The names of the nested tests will be joined in a list, like
   "(arithmetic addition)", in failure reports.  You can use nested
   tests to set up a context shared by several tests.</p>

<p>   RUNNING TESTS</p>

<p>   Run tests with the function "(run-tests namespaces...)":</p>

<p>   (run-tests 'your.namespace 'some.other.namespace)</p>

<p>   If you don't specify any namespaces, the current namespace is
   used.  To run all tests in all namespaces, use "(run-all-tests)".</p>

<p>   By default, these functions will search for all tests defined in
   a namespace and run them in an undefined order.  However, if you
   are composing tests, as in the "arithmetic" example above, you
   probably do not want the "addition" and "subtraction" tests run
   separately.  In that case, you must define a special function
   named "test-ns-hook" that runs your tests in the correct order:</p>

<p>   (defn test-ns-hook []
     (arithmetic))</p>

<p>   Note: test-ns-hook prevents execution of fixtures (see below).</p>

<p>   OMITTING TESTS FROM PRODUCTION CODE</p>

<p>   You can bind the variable "<em>load-tests</em>" to false when loading or
   compiling code in production.  This will prevent any tests from
   being created by "with-test" or "deftest".</p>

<p>   FIXTURES</p>

<p>   Fixtures allow you to run code before and after tests, to set up
   the context in which tests should be run.</p>

<p>   A fixture is just a function that calls another function passed as
   an argument.  It looks like this:</p>

<p>   (defn my-fixture [f]
      Perform setup, establish bindings, whatever.
     (f)  Then call the function we were passed.
      Tear-down / clean-up code here.
    )</p>

<p>   Fixtures are attached to namespaces in one of two ways.  "each"
   fixtures are run repeatedly, once for each test function created
   with "deftest" or "with-test".  "each" fixtures are useful for
   establishing a consistent before/after state for each test, like
   clearing out database tables.</p>

<p>   "each" fixtures can be attached to the current namespace like this:
   (use-fixtures :each fixture1 fixture2 ...)
   The fixture1, fixture2 are just functions like the example above.
   They can also be anonymous functions, like this:
   (use-fixtures :each (fn [f] setup... (f) cleanup...))</p>

<p>   The other kind of fixture, a "once" fixture, is only run once,
   around ALL the tests in the namespace.  "once" fixtures are useful
   for tasks that only need to be performed once, like establishing
   database connections, or for time-consuming tasks.</p>

<p>   Attach "once" fixtures to the current namespace like this:
   (use-fixtures :once fixture1 fixture2 ...)</p>

<p>   Note: Fixtures and test-ns-hook are mutually incompatible.  If you
   are using test-ns-hook, fixture functions will <em>never</em> be run.</p>

<p>   SAVING TEST OUTPUT TO A FILE</p>

<p>   All the test reporting functions write to the var <em>test-out</em>.  By
   default, this is the same as <em>out</em>, but you can rebind it to any
   PrintWriter.  For example, it could be a file opened with
   clojure.java.io/writer.</p>

<p>   EXTENDING TEST-IS (ADVANCED)</p>

<p>   You can extend the behavior of the "is" macro by defining new
   methods for the "assert-expr" multimethod.  These methods are
   called during expansion of the "is" macro, so they should return
   quoted forms to be evaluated.</p>

<p>   You can plug in your own test-reporting framework by rebinding
   the "report" function: (report event)</p>

<p>   The 'event' argument is a map.  It will always have a :type key,
   whose value will be a keyword signaling the type of event being
   reported.  Standard events with :type value of :pass, :fail, and
   :error are called when an assertion passes, fails, and throws an
   exception, respectively.  In that case, the event will also have
   the following keys:</p>

<pre><code> :expected   The form that was expected to be true
 :actual     A form representing what actually occurred
 :message    The string message given as an argument to 'is'
</code></pre>

<p>   The "testing" strings will be a list in "<em>testing-contexts</em>", and
   the vars being tested will be a list in "<em>testing-vars</em>".</p>

<p>   Your "report" function should wrap any printing calls in the
   "with-test-out" macro, which rebinds <em>out</em> to the current value
   of <em>test-out</em>.</p>

<p>   For additional event types, see the examples in the code.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Stuart Sierra, with contributions and suggestions by 
  Chas Emerick, Allen Rohner, and Stuart Halloway&quot;,
     :doc }
  clojure.test
  (:require [clojure.template :as temp]
            [clojure.stacktrace :as stack]))</pre></td></tr><tr><td class="docs"><p>Nothing is marked "private" here, so you can rebind things to plug
in your own testing or reporting frameworks.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>USER-MODIFIABLE GLOBALS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>True by default.  If set to false, no test functions will
   be created by deftest, set-test, or with-test.  Use this to omit
   tests when compiling or loading production code.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic
  ^{:doc 
    :added &quot;1.1&quot;}
  *load-tests* true)</pre></td></tr><tr><td class="docs"><p>The maximum depth of stack traces to print when an Exception
  is thrown during a test.  Defaults to nil, which means print the 
  complete stack trace.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic
 ^{:doc 
   :added &quot;1.1&quot;}
 *stack-trace-depth* nil)</pre></td></tr><tr><td class="docs"><p>GLOBALS USED BY THE REPORTING FUNCTIONS</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *report-counters* nil)	  ; bound to a ref of a map in test-ns</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *initial-report-counters*  ; used to initialize *report-counters*
     {:test 0, :pass 0, :fail 0, :error 0})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *testing-vars* (list))  ; bound to hierarchy of vars being tested</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *testing-contexts* (list)) ; bound to hierarchy of &quot;testing&quot; strings</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *test-out* *out*)         ; PrintWriter for test reporting output</pre></td></tr><tr><td class="docs"><p>Runs body with <em>out</em> bound to the value of <em>test-out</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-test-out
  {:added &quot;1.1&quot;}
  [&amp; body]
  `(binding [*out* *test-out*]
     ~@body))</pre></td></tr><tr><td class="docs"><p>UTILITIES FOR REPORTING FUNCTIONS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a vector [filename line-number] for the nth call up the
  stack.</p>

<p>  Deprecated in 1.2: The information needed for test reporting is
  now on :file and :line keys in the result map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-position
  {:added &quot;1.1&quot;
   :deprecated &quot;1.2&quot;}
  [n]
  (let [^StackTraceElement s (nth (.getStackTrace (new java.lang.Throwable)) n)]
    [(.getFileName s) (.getLineNumber s)]))</pre></td></tr><tr><td class="docs"><p>Returns a string representation of the current test.  Renders names
  in <em>testing-vars</em> as a list, then the source file and line of
  current assertion.</p>
</td><td class="codes"><pre class="brush: clojure">(defn testing-vars-str
  {:added &quot;1.1&quot;}
  [m]
  (let [{:keys [file line]} m]
    (str
     ;; Uncomment to include namespace in failure report:
     ;;(ns-name (:ns (meta (first *testing-vars*)))) &quot;/ &quot;
     (reverse (map #(:name (meta %)) *testing-vars*))
     &quot; (&quot; file &quot;:&quot; line &quot;)&quot;)))</pre></td></tr><tr><td class="docs"><p>Returns a string representation of the current test context. Joins
  strings in <em>testing-contexts</em> with spaces.</p>
</td><td class="codes"><pre class="brush: clojure">(defn testing-contexts-str
  {:added &quot;1.1&quot;}
  []
  (apply str (interpose &quot; &quot; (reverse *testing-contexts*))))</pre></td></tr><tr><td class="docs"><p>Increments the named counter in <em>report-counters</em>, a ref to a map.
  Does nothing if <em>report-counters</em> is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn inc-report-counter
  {:added &quot;1.1&quot;}
  [name]
  (when *report-counters*
    (dosync (commute *report-counters* assoc name
                     (inc (or (*report-counters* name) 0))))))</pre></td></tr><tr><td class="docs"><p>TEST RESULT REPORTING</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Generic reporting function, may be overridden to plug in
   different report formats (e.g., TAP, JUnit).  Assertions such as
   'is' call 'report' to indicate results.  The argument given to
   'report' will be a map with a :type key.  See the documentation at
   the top of test_is.clj for more information on the types of
   arguments for 'report'.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti
  ^{:doc 
     :dynamic true
     :added &quot;1.1&quot;}
  report :type)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- file-and-line 
  [exception depth]
  (let [^StackTraceElement s (nth (.getStackTrace exception) depth)]
    {:file (.getFileName s) :line (.getLineNumber s)}))</pre></td></tr><tr><td class="docs"><p>Add file and line information to a test result and call report.
   If you are writing a custom assert-expr method, call this function
   to pass test results to report.</p>
</td><td class="codes"><pre class="brush: clojure">(defn do-report
  {:added &quot;1.2&quot;}
  [m]
  (report
   (case
    (:type m)
    :fail (merge (file-and-line (new java.lang.Throwable) 1) m)
    :error (merge (file-and-line (:actual m) 0) m) 
    m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :default [m]
  (with-test-out (prn m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :pass [m]
  (with-test-out (inc-report-counter :pass)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :fail [m]
  (with-test-out
    (inc-report-counter :fail)
    (println &quot;\nFAIL in&quot; (testing-vars-str m))
    (when (seq *testing-contexts*) (println (testing-contexts-str)))
    (when-let [message (:message m)] (println message))
    (println &quot;expected:&quot; (pr-str (:expected m)))
    (println &quot;  actual:&quot; (pr-str (:actual m)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :error [m]
  (with-test-out
   (inc-report-counter :error)
   (println &quot;\nERROR in&quot; (testing-vars-str m))
   (when (seq *testing-contexts*) (println (testing-contexts-str)))
   (when-let [message (:message m)] (println message))
   (println &quot;expected:&quot; (pr-str (:expected m)))
   (print &quot;  actual: &quot;)
   (let [actual (:actual m)]
     (if (instance? Throwable actual)
       (stack/print-cause-trace actual *stack-trace-depth*)
       (prn actual)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :summary [m]
  (with-test-out
   (println &quot;\nRan&quot; (:test m) &quot;tests containing&quot;
            (+ (:pass m) (:fail m) (:error m)) &quot;assertions.&quot;)
   (println (:fail m) &quot;failures,&quot; (:error m) &quot;errors.&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod report :begin-test-ns [m]
  (with-test-out
   (println &quot;\nTesting&quot; (ns-name (:ns m)))))</pre></td></tr><tr><td class="docs"><p>Ignore these message types:</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod report :end-test-ns [m])
(defmethod report :begin-test-var [m])
(defmethod report :end-test-var [m])</pre></td></tr><tr><td class="docs"><p>UTILITIES FOR ASSERTIONS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Like var-get but returns nil if the var is unbound.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-possibly-unbound-var
  {:added &quot;1.1&quot;}
  [v]
  (try (var-get v)
       (catch IllegalStateException e
         nil)))</pre></td></tr><tr><td class="docs"><p>Returns true if argument is a function or a symbol that resolves to
  a function (not a macro).</p>
</td><td class="codes"><pre class="brush: clojure">(defn function?
  {:added &quot;1.1&quot;}
  [x]
  (if (symbol? x)
    (when-let [v (resolve x)]
      (when-let [value (get-possibly-unbound-var v)]
        (and (fn? value)
             (not (:macro (meta v))))))
    (fn? x)))</pre></td></tr><tr><td class="docs"><p>Returns generic assertion code for any functional predicate.  The
  'expected' argument to 'report' will contains the original form, the
  'actual' argument will contain the form with all its sub-forms
  evaluated.  If the predicate returns false, the 'actual' form will
  be wrapped in (not...).</p>
</td><td class="codes"><pre class="brush: clojure">(defn assert-predicate
  {:added &quot;1.1&quot;}
  [msg form]
  (let [args (rest form)
        pred (first form)]
    `(let [values# (list ~@args)
           result# (apply ~pred values#)]
       (if result#
         (do-report {:type :pass, :message ~msg,
                  :expected '~form, :actual (cons ~pred values#)})
         (do-report {:type :fail, :message ~msg,
                  :expected '~form, :actual (list '~'not (cons '~pred values#))}))
       result#)))</pre></td></tr><tr><td class="docs"><p>Returns generic assertion code for any test, including macros, Java
  method calls, or isolated symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defn assert-any
  {:added &quot;1.1&quot;}
  [msg form]
  `(let [value# ~form]
     (if value#
       (do-report {:type :pass, :message ~msg,
                :expected '~form, :actual value#})
       (do-report {:type :fail, :message ~msg,
                :expected '~form, :actual value#}))
     value#))</pre></td></tr><tr><td class="docs"><p>ASSERTION METHODS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>You don't call these, but you can add methods to extend the 'is'
macro.  These define different kinds of tests, based on the first
symbol in the test expression.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti assert-expr 
  (fn [msg form]
    (cond
      (nil? form) :always-fail
      (seq? form) (first form)
      :else :default)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod assert-expr :always-fail [msg form]
  ;; nil test: always fail
  `(do-report {:type :fail, :message ~msg}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod assert-expr :default [msg form]
  (if (and (sequential? form) (function? (first form)))
    (assert-predicate msg form)
    (assert-any msg form)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod assert-expr 'instance? [msg form]
  ;; Test if x is an instance of y.
  `(let [klass# ~(nth form 1)
         object# ~(nth form 2)]
     (let [result# (instance? klass# object#)]
       (if result#
         (do-report {:type :pass, :message ~msg,
                  :expected '~form, :actual (class object#)})
         (do-report {:type :fail, :message ~msg,
                  :expected '~form, :actual (class object#)}))
       result#)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod assert-expr 'thrown? [msg form]
  ;; (is (thrown? c expr))
  ;; Asserts that evaluating expr throws an exception of class c.
  ;; Returns the exception thrown.
  (let [klass (second form)
        body (nthnext form 2)]
    `(try ~@body
          (do-report {:type :fail, :message ~msg,
                   :expected '~form, :actual nil})
          (catch ~klass e#
            (do-report {:type :pass, :message ~msg,
                     :expected '~form, :actual e#})
            e#))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod assert-expr 'thrown-with-msg? [msg form]
  ;; (is (thrown-with-msg? c re expr))
  ;; Asserts that evaluating expr throws an exception of class c.
  ;; Also asserts that the message string of the exception matches
  ;; (with re-find) the regular expression re.
  (let [klass (nth form 1)
        re (nth form 2)
        body (nthnext form 3)]
    `(try ~@body
          (do-report {:type :fail, :message ~msg, :expected '~form, :actual nil})
          (catch ~klass e#
            (let [m# (.getMessage e#)]
              (if (re-find ~re m#)
                (do-report {:type :pass, :message ~msg,
                         :expected '~form, :actual e#})
                (do-report {:type :fail, :message ~msg,
                         :expected '~form, :actual e#})))
            e#))))</pre></td></tr><tr><td class="docs"><p>Used by the 'is' macro to catch unexpected exceptions.
  You don't call this.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro try-expr
  {:added &quot;1.1&quot;}
  [msg form]
  `(try ~(assert-expr msg form)
        (catch Throwable t#
          (do-report {:type :error, :message ~msg,
                      :expected '~form, :actual t#}))))</pre></td></tr><tr><td class="docs"><p>ASSERTION MACROS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>You use these in your tests.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Generic assertion macro.  'form' is any predicate test.
  'msg' is an optional message to attach to the assertion.</p>

<p>  Example: (is (= 4 (+ 2 2)) "Two plus two should be 4")</p>

<p>  Special forms:</p>

<p>  (is (thrown? c body)) checks that an instance of c is thrown from
  body, fails if not; then returns the thing thrown.</p>

<p>  (is (thrown-with-msg? c re body)) checks that an instance of c is
  thrown AND that the message on the exception matches (with
  re-find) the regular expression re.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro is
  {:added &quot;1.1&quot;} 
  ([form] `(is ~form nil))
  ([form msg] `(try-expr ~msg ~form)))</pre></td></tr><tr><td class="docs"><p>Checks multiple assertions with a template expression.
  See clojure.template/do-template for an explanation of
  templates.</p>

<p>  Example: (are [x y] (= x y) <br />
                2 (+ 1 1)
                4 (* 2 2))
  Expands to: 
           (do (is (= 2 (+ 1 1)))
               (is (= 4 (* 2 2))))</p>

<p>  Note: This breaks some reporting features, such as line numbers.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro are
  {:added &quot;1.1&quot;}
  [argv expr &amp; args]
  (if (or
       ;; (are [] true) is meaningless but ok
       (and (empty? argv) (empty? args))
       ;; Catch wrong number of args
       (and (pos? (count argv))
            (pos? (count args))
            (zero? (mod (count args) (count argv)))))
    `(temp/do-template ~argv (is ~expr) ~@args)
    (throw (IllegalArgumentException. &quot;The number of args doesn't match are's argv.&quot;))))</pre></td></tr><tr><td class="docs"><p>Adds a new string to the list of testing contexts.  May be nested,
  but must occur inside a test function (deftest).</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro testing
  {:added &quot;1.1&quot;}
  [string &amp; body]
  `(binding [*testing-contexts* (conj *testing-contexts* ~string)]
     ~@body))</pre></td></tr><tr><td class="docs"><p>DEFINING TESTS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes any definition form (that returns a Var) as the first argument.
  Remaining body goes in the :test metadata function for that Var.</p>

<p>  When <em>load-tests</em> is false, only evaluates the definition, ignoring
  the tests.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-test
  {:added &quot;1.1&quot;}
  [definition &amp; body]
  (if *load-tests*
    `(doto ~definition (alter-meta! assoc :test (fn [] ~@body)))
    definition))</pre></td></tr><tr><td class="docs"><p>Defines a test function with no arguments.  Test functions may call
  other tests, so tests may be composed.  If you compose tests, you
  should also define a function named test-ns-hook; run-tests will
  call test-ns-hook instead of testing all vars.</p>

<p>  Note: Actually, the test body goes in the :test metadata on the var,
  and the real function (the value of the var) calls test-var on
  itself.</p>

<p>  When <em>load-tests</em> is false, deftest is ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro deftest
  {:added &quot;1.1&quot;}
  [name &amp; body]
  (when *load-tests*
    `(def ~(vary-meta name assoc :test `(fn [] ~@body))
          (fn [] (test-var (var ~name))))))</pre></td></tr><tr><td class="docs"><p>Like deftest but creates a private var.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro deftest-
  {:added &quot;1.1&quot;}
  [name &amp; body]
  (when *load-tests*
    `(def ~(vary-meta name assoc :test `(fn [] ~@body) :private true)
          (fn [] (test-var (var ~name))))))</pre></td></tr><tr><td class="docs"><p>Experimental.
  Sets :test metadata of the named var to a fn with the given body.
  The var must already exist.  Does not modify the value of the var.</p>

<p>  When <em>load-tests</em> is false, set-test is ignored.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro set-test
  {:added &quot;1.1&quot;}
  [name &amp; body]
  (when *load-tests*
    `(alter-meta! (var ~name) assoc :test (fn [] ~@body))))</pre></td></tr><tr><td class="docs"><p>DEFINING FIXTURES</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Adds elements in coll to the current namespace metadata as the
  value of key.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-ns-meta
  {:added &quot;1.1&quot;}
  [key coll]
  (alter-meta! *ns* assoc key coll))</pre></td></tr><tr><td class="docs"><p>Wrap test runs in a fixture function to perform setup and
  teardown. Using a fixture-type of :each wraps every test
  individually, while:once wraps the whole run in a single function.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti use-fixtures
  {:added &quot;1.1&quot;}
  (fn [fixture-type &amp; args] fixture-type))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod use-fixtures :each [fixture-type &amp; args]
  (add-ns-meta ::each-fixtures args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod use-fixtures :once [fixture-type &amp; args]
  (add-ns-meta ::once-fixtures args))</pre></td></tr><tr><td class="docs"><p>The default, empty, fixture function.  Just calls its argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- default-fixture
  {:added &quot;1.1&quot;}
  [f]
  (f))</pre></td></tr><tr><td class="docs"><p>Composes two fixture functions, creating a new fixture function
  that combines their behavior.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compose-fixtures
  {:added &quot;1.1&quot;}
  [f1 f2]
  (fn [g] (f1 (fn [] (f2 g)))))</pre></td></tr><tr><td class="docs"><p>Composes a collection of fixtures, in order.  Always returns a valid
  fixture function, even if the collection is empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defn join-fixtures
  {:added &quot;1.1&quot;}
  [fixtures]
  (reduce compose-fixtures default-fixture fixtures))</pre></td></tr><tr><td class="docs"><p>RUNNING TESTS: LOW-LEVEL FUNCTIONS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>If v has a function in its :test metadata, calls that function,
  with <em>testing-vars</em> bound to (conj <em>testing-vars</em> v).</p>
</td><td class="codes"><pre class="brush: clojure">(defn test-var
  {:dynamic true, :added &quot;1.1&quot;}
  [v]
  (when-let [t (:test (meta v))]
    (binding [*testing-vars* (conj *testing-vars* v)]
      (do-report {:type :begin-test-var, :var v})
      (inc-report-counter :test)
      (try (t)
           (catch Throwable e
             (do-report {:type :error, :message &quot;Uncaught exception, not in assertion.&quot;
                      :expected nil, :actual e})))
      (do-report {:type :end-test-var, :var v}))))</pre></td></tr><tr><td class="docs"><p>Calls test-var on every var interned in the namespace, with fixtures.</p>
</td><td class="codes"><pre class="brush: clojure">(defn test-all-vars
  {:added &quot;1.1&quot;}
  [ns]
  (let [once-fixture-fn (join-fixtures (::once-fixtures (meta ns)))
        each-fixture-fn (join-fixtures (::each-fixtures (meta ns)))]
    (once-fixture-fn
     (fn []
       (doseq [v (vals (ns-interns ns))]
         (when (:test (meta v))
           (each-fixture-fn (fn [] (test-var v)))))))))</pre></td></tr><tr><td class="docs"><p>If the namespace defines a function named test-ns-hook, calls that.
  Otherwise, calls test-all-vars on the namespace.  'ns' is a
  namespace object or a symbol.</p>

<p>  Internally binds <em>report-counters</em> to a ref initialized to
  <em>inital-report-counters</em>.  Returns the final, dereferenced state of
  <em>report-counters</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn test-ns
  {:added &quot;1.1&quot;}
  [ns]
  (binding [*report-counters* (ref *initial-report-counters*)]
    (let [ns-obj (the-ns ns)]
      (do-report {:type :begin-test-ns, :ns ns-obj})
      ;; If the namespace has a test-ns-hook function, call that:
      (if-let [v (find-var (symbol (str (ns-name ns-obj)) &quot;test-ns-hook&quot;))]
	((var-get v))
        ;; Otherwise, just test every var in the namespace.
        (test-all-vars ns-obj))
      (do-report {:type :end-test-ns, :ns ns-obj}))
    @*report-counters*))</pre></td></tr><tr><td class="docs"><p>RUNNING TESTS: HIGH-LEVEL FUNCTIONS</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Runs all tests in the given namespaces; prints results.
  Defaults to current namespace if none given.  Returns a map
  summarizing test results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-tests
  {:added &quot;1.1&quot;}
  ([] (run-tests *ns*))
  ([&amp; namespaces]
     (let [summary (assoc (apply merge-with + (map test-ns namespaces))
                     :type :summary)]
       (do-report summary)
       summary)))</pre></td></tr><tr><td class="docs"><p>Runs all tests in all namespaces; prints results.
  Optional argument is a regular expression; only namespaces with
  names matching the regular expression (with re-matches) will be
  tested.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-all-tests
  {:added &quot;1.1&quot;}
  ([] (apply run-tests (all-ns)))
  ([re] (apply run-tests (filter #(re-matches re (name (ns-name %))) (all-ns)))))</pre></td></tr><tr><td class="docs"><p>Returns true if the given test summary indicates all tests
  were successful, false otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn successful?
  {:added &quot;1.1&quot;}
  [summary]
  (and (zero? (:fail summary 0))
       (zero? (:error summary 0))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.test.junit" name="clojure.test.junit"><h1 class="project-name">clojure.test.junit</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>test/junit.clj: Extension to clojure.test for JUnit-compatible XML output</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>by Jason Sankey
June 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>DOCUMENTATION</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>clojure.test extension for JUnit-compatible XML output.</p>

<p>  JUnit (http://junit.org/) is the most popular unit-testing library
  for Java.  As such, tool support for JUnit output formats is
  common.  By producing compatible output from tests, this tool
  support can be exploited.</p>

<p>  To use, wrap any calls to clojure.test/run-tests in the
  with-junit-output macro, like this:</p>

<pre><code>(use 'clojure.test)
(use 'clojure.test.junit)

(with-junit-output
  (run-tests 'my.cool.library))
</code></pre>

<p>  To write the output to a file, rebind clojure.test/<em>test-out</em> to
  your own PrintWriter (perhaps opened using
  clojure.java.io/writer).</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
  :author &quot;Jason Sankey&quot;}
  clojure.test.junit
  (:require [clojure.stacktrace :as stack]
            [clojure.test :as t]))</pre></td></tr><tr><td class="docs"><p>copied from clojure.contrib.lazy-xml</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
     escape-xml-map
     (zipmap &quot;'&lt;&gt;\&quot;&amp;&quot; (map #(str \&amp; % \;) '[apos lt gt quot amp])))
(defn- escape-xml [text]
  (apply str (map #(escape-xml-map % %) text)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *var-context*)
(def ^:dynamic *depth*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn indent
  []
  (dotimes [n (* *depth* 4)] (print &quot; &quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-element
  [tag pretty &amp; [attrs]]
  (if pretty (indent))
  (print (str &quot;&lt;&quot; tag))
  (if (seq attrs)
    (doseq [[key value] attrs]
      (print (str &quot; &quot; (name key) &quot;=\ (escape-xml value) &quot;\))))
  (print &quot;&gt;&quot;)
  (if pretty (println))
  (set! *depth* (inc *depth*)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn element-content
  [content]
  (print (escape-xml content)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn finish-element
  [tag pretty]
  (set! *depth* (dec *depth*))
  (if pretty (indent))
  (print (str &quot;&lt;/&quot; tag &quot;&gt;&quot;))
  (if pretty (println)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn test-name
  [vars]
  (apply str (interpose &quot;.&quot;
                        (reverse (map #(:name (meta %)) vars)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn package-class
  [name]
  (let [i (.lastIndexOf name &quot;.&quot;)]
    (if (&lt; i 0)
      [nil name]
      [(.substring name 0 i) (.substring name (+ i 1))])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-case
  [name classname]
  (start-element 'testcase true {:name name :classname classname}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn finish-case
  []
  (finish-element 'testcase true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn suite-attrs
  [package classname]
  (let [attrs {:name classname}]
    (if package
      (assoc attrs :package package)
      attrs)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-suite
  [name]
  (let [[package classname] (package-class name)]
    (start-element 'testsuite true (suite-attrs package classname))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn finish-suite
  []
  (finish-element 'testsuite true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn message-el
  [tag message expected-str actual-str]
  (indent)
  (start-element tag false (if message {:message message} {}))
  (element-content
   (let [[file line] (t/file-position 5)
         detail (apply str (interpose
                            &quot;\n&quot;
                            [(str &quot;expected: &quot; expected-str)
                             (str &quot;  actual: &quot; actual-str)
                             (str &quot;      at: &quot; file &quot;:&quot; line)]))]
     (if message (str message &quot;\n&quot; detail) detail)))
  (finish-element tag false)
  (println))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn failure-el
  [message expected actual]
  (message-el 'failure message (pr-str expected) (pr-str actual)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn error-el
  [message expected actual]
  (message-el 'error
              message
              (pr-str expected)
              (if (instance? Throwable actual)
                (with-out-str (stack/print-cause-trace actual t/*stack-trace-depth*))
                (prn actual))))</pre></td></tr><tr><td class="docs"><p>This multimethod will override test-is/report</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti ^:dynamic junit-report :type)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :begin-test-ns [m]
  (t/with-test-out
   (start-suite (name (ns-name (:ns m))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :end-test-ns [_]
  (t/with-test-out
   (finish-suite)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :begin-test-var [m]
  (t/with-test-out
   (let [var (:var m)]
     (binding [*var-context* (conj *var-context* var)]
       (start-case (test-name *var-context*) (name (ns-name (:ns (meta var)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :end-test-var [m]
  (t/with-test-out
   (finish-case)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :pass [m]
  (t/with-test-out
   (t/inc-report-counter :pass)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :fail [m]
  (t/with-test-out
   (t/inc-report-counter :fail)
   (failure-el (:message m)
               (:expected m)
               (:actual m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :error [m]
  (t/with-test-out
   (t/inc-report-counter :error)
   (error-el (:message m)
             (:expected m)
             (:actual m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod junit-report :default [_])</pre></td></tr><tr><td class="docs"><p>Execute body with modified test-is reporting functions that write
  JUnit-compatible XML output.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-junit-output
  {:added &quot;1.1&quot;}
  [&amp; body]
  `(binding [t/report junit-report
             *var-context* (list)
             *depth* 1]
     (t/with-test-out
       (println &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;)
       (println &quot;&lt;testsuites&gt;&quot;))
     (let [result# ~@body]
       (t/with-test-out (println &quot;&lt;/testsuites&gt;&quot;))
       result#)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.test.tap" name="clojure.test.tap"><h1 class="project-name">clojure.test.tap</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>test_is/tap.clj: Extension to test for TAP output</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>by Stuart Sierra
March 31, 2009</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Inspired by ClojureCheck by Meikel Brandmeyer:
http://kotka.de/projects/clojure/clojurecheck.html</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>DOCUMENTATION</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>clojure.test extensions for the Test Anything Protocol (TAP)</p>

<p>  TAP is a simple text-based syntax for reporting test results.  TAP
  was originally developed for Perl, and now has implementations in
  several languages.  For more information on TAP, see
  http://testanything.org/ and
  http://search.cpan.org/~petdance/TAP-1.0.0/TAP.pm</p>

<p>  To use this library, wrap any calls to
  clojure.test/run-tests in the with-tap-output macro,
  like this:</p>

<pre><code>(use 'clojure.test)
(use 'clojure.test.tap)

(with-tap-output
 (run-tests 'my.cool.library))
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Stuart Sierra&quot;}
  clojure.test.tap
  (:require [clojure.test :as t]
            [clojure.stacktrace :as stack]))</pre></td></tr><tr><td class="docs"><p>Prints a TAP plan line like '1..n'.  n is the number of tests</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-tap-plan
  {:added &quot;1.1&quot;}
  [n]
  (println (str &quot;1..&quot; n)))</pre></td></tr><tr><td class="docs"><p>Prints a TAP diagnostic line.  data is a (possibly multi-line)
  string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-tap-diagnostic
  {:added &quot;1.1&quot;}
  [data]
  (doseq [line (.split ^String data &quot;\n&quot;)]
    (println &quot;#&quot; line)))</pre></td></tr><tr><td class="docs"><p>Prints a TAP 'ok' line.  msg is a string, with no line breaks</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-tap-pass
  {:added &quot;1.1&quot;}
  [msg]
  (println &quot;ok&quot; msg))</pre></td></tr><tr><td class="docs"><p>Prints a TAP 'not ok' line.  msg is a string, with no line breaks</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-tap-fail 
  {:added &quot;1.1&quot;}
  [msg]
  (println &quot;not ok&quot; msg))</pre></td></tr><tr><td class="docs"><p>This multimethod will override test/report</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti ^:dynamic tap-report :type)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod tap-report :default [data]
  (t/with-test-out
   (print-tap-diagnostic (pr-str data))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-diagnostics [data]
  (when (seq t/*testing-contexts*)
    (print-tap-diagnostic (t/testing-contexts-str)))
  (when (:message data)
    (print-tap-diagnostic (:message data)))
  (print-tap-diagnostic (str &quot;expected:&quot; (pr-str (:expected data))))
  (if (= :pass (:type data))
    (print-tap-diagnostic (str &quot;  actual:&quot; (pr-str (:actual data))))
    (do
      (print-tap-diagnostic
       (str &quot;  actual:&quot;
        (with-out-str
          (if (instance? Throwable (:actual data))
            (stack/print-cause-trace (:actual data) t/*stack-trace-depth*)
            (prn (:actual data)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod tap-report :pass [data]
  (t/with-test-out
   (t/inc-report-counter :pass)
   (print-tap-pass (t/testing-vars-str data))
   (print-diagnostics data)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod tap-report :error [data]
  (t/with-test-out
   (t/inc-report-counter :error)
   (print-tap-fail (t/testing-vars-str data))
   (print-diagnostics data)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod tap-report :fail [data]
  (t/with-test-out
   (t/inc-report-counter :fail)
   (print-tap-fail (t/testing-vars-str data))
   (print-diagnostics data)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod tap-report :summary [data]
  (t/with-test-out
   (print-tap-plan (+ (:pass data) (:fail data) (:error data)))))</pre></td></tr><tr><td class="docs"><p>Execute body with modified test reporting functions that produce
  TAP output</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-tap-output
  {:added &quot;1.1&quot;}
  [&amp; body]
  `(binding [t/report tap-report]
     ~@body))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.uuid" name="clojure.uuid"><h1 class="project-name">clojure.uuid</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns clojure.uuid)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- default-uuid-reader [form]
  {:pre [(string? form)]}
  (java.util.UUID/fromString form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method java.util.UUID [uuid ^java.io.Writer w]
  (.write w (str &quot;#uuid \&quot;&quot; (str uuid) &quot;\&quot;&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-dup java.util.UUID [o w]
  (print-method o w))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.walk" name="clojure.walk"><h1 class="project-name">clojure.walk</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>walk.clj - generic tree walker with replacement</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>by Stuart Sierra
December 15, 2008</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>CHANGE LOG:</p>

<ul>
<li><p>December 15, 2008: replaced 'walk' with 'prewalk' &amp; 'postwalk'</p></li>
<li><p>December 9, 2008: first version</p></li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This file defines a generic tree walker for Clojure data
structures.  It takes any data structure (list, vector, map, set,
seq), calls a function on every element, and uses the return value
of the function in place of the original.  This makes it fairly
easy to write recursive search-and-replace functions, as shown in
the examples.</p>

<p>Note: "walk" supports all Clojure data structures EXCEPT maps
created with sorted-map-by.  There is no (obvious) way to retrieve
the sorting function.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  ^{:author &quot;Stuart Sierra&quot;,
     :doc }
  clojure.walk)</pre></td></tr><tr><td class="docs"><p>Traverses form, an arbitrary data structure.  inner and outer are
  functions.  Applies inner to each element of form, building up a
  data structure of the same type, then applies outer to the result.
  Recognizes all Clojure data structures. Consumes seqs as with doall.</p>
</td><td class="codes"><pre class="brush: clojure">(defn walk
  {:added &quot;1.1&quot;}
  [inner outer form]
  (cond
   (list? form) (outer (apply list (map inner form)))
   (instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))
   (seq? form) (outer (doall (map inner form)))
   (coll? form) (outer (into (empty form) (map inner form)))
   :else (outer form)))</pre></td></tr><tr><td class="docs"><p>Performs a depth-first, post-order traversal of form.  Calls f on
  each sub-form, uses f's return value in place of the original.
  Recognizes all Clojure data structures. Consumes seqs as with doall.</p>
</td><td class="codes"><pre class="brush: clojure">(defn postwalk
  {:added &quot;1.1&quot;}
  [f form]
  (walk (partial postwalk f) f form))</pre></td></tr><tr><td class="docs"><p>Like postwalk, but does pre-order traversal.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prewalk
  {:added &quot;1.1&quot;}
  [f form]
  (walk (partial prewalk f) identity (f form)))</pre></td></tr><tr><td class="docs"><p>Note: I wanted to write:</p>

<p>(defn walk
  [f form]
  (let [pf (partial walk f)]
    (if (coll? form)
      (f (into (empty form) (map pf form)))
      (f form))))</p>

<p>but this throws a ClassCastException when applied to a map.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Demonstrates the behavior of postwalk by printing each form as it is
  walked.  Returns form.</p>
</td><td class="codes"><pre class="brush: clojure">(defn postwalk-demo
  {:added &quot;1.1&quot;}
  [form]
  (postwalk (fn [x] (print &quot;Walked: &quot;) (prn x) x) form))</pre></td></tr><tr><td class="docs"><p>Demonstrates the behavior of prewalk by printing each form as it is
  walked.  Returns form.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prewalk-demo
  {:added &quot;1.1&quot;}
  [form]
  (prewalk (fn [x] (print &quot;Walked: &quot;) (prn x) x) form))</pre></td></tr><tr><td class="docs"><p>Recursively transforms all map keys from strings to keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn keywordize-keys
  {:added &quot;1.1&quot;}
  [m]
  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]
    ;; only apply to maps
    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))</pre></td></tr><tr><td class="docs"><p>Recursively transforms all map keys from keywords to strings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn stringify-keys
  {:added &quot;1.1&quot;}
  [m]
  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]
    ;; only apply to maps
    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))</pre></td></tr><tr><td class="docs"><p>Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the root of the tree first.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prewalk-replace
  {:added &quot;1.1&quot;}
  [smap form]
  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))</pre></td></tr><tr><td class="docs"><p>Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the leaves of the tree first.</p>
</td><td class="codes"><pre class="brush: clojure">(defn postwalk-replace
  {:added &quot;1.1&quot;}
  [smap form]
  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))</pre></td></tr><tr><td class="docs"><p>Recursively performs all possible macroexpansions in form.</p>
</td><td class="codes"><pre class="brush: clojure">(defn macroexpand-all
  {:added &quot;1.1&quot;}
  [form]
  (prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.xml" name="clojure.xml"><h1 class="project-name">clojure.xml</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>XML reading/writing.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
  clojure.xml
  (:import (org.xml.sax ContentHandler Attributes SAXException)
           (javax.xml.parsers SAXParser SAXParserFactory)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *stack*)
(def ^:dynamic *current*)
(def ^:dynamic *state*) ; :element :chars :between</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *sb*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defstruct element :tag :attrs :content)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def tag (accessor element :tag))
(def attrs (accessor element :attrs))
(def content (accessor element :content))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def content-handler
  (let [push-content (fn [e c]
                       (assoc e :content (conj (or (:content e) []) c)))
        push-chars (fn []
                     (when (and (= *state* :chars)
                                (some (complement #(Character/isWhitespace (char %))) (str *sb*)))
                       (set! *current* (push-content *current* (str *sb*)))))]
    (new clojure.lang.XMLHandler
         (proxy [ContentHandler] []
           (startElement [uri local-name q-name ^Attributes atts]
             (let [attrs (fn [ret i]
                           (if (neg? i)
                             ret
                             (recur (assoc ret
                                           (clojure.lang.Keyword/intern (symbol (.getQName atts i)))
                                           (.getValue atts (int i)))
                                    (dec i))))
                   e (struct element
                             (. clojure.lang.Keyword (intern (symbol q-name)))
                             (when (pos? (.getLength atts))
                               (attrs {} (dec (.getLength atts)))))]
               (push-chars)
               (set! *stack* (conj *stack* *current*))
               (set! *current* e)
               (set! *state* :element))
             nil)
           (endElement [uri local-name q-name]
             (push-chars)
             (set! *current* (push-content (peek *stack*) *current*))
             (set! *stack* (pop *stack*))
             (set! *state* :between)
             nil)
           (characters [^chars ch start length]
             (when-not (= *state* :chars)
               (set! *sb* (new StringBuilder)))
             (let [^StringBuilder sb *sb*]
               (.append sb ch (int start) (int length))
               (set! *state* :chars))
             nil)
           (setDocumentLocator [locator])
           (startDocument [])
           (endDocument [])
           (startPrefixMapping [prefix uri])
           (endPrefixMapping [prefix])
           (ignorableWhitespace [ch start length])
           (processingInstruction [target data])
           (skippedEntity [name])))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn startparse-sax [s ch]
  (.. SAXParserFactory (newInstance) (newSAXParser) (parse s ch)))</pre></td></tr><tr><td class="docs"><p>Parses and loads the source s, which can be a File, InputStream or
  String naming a URI. Returns a tree of the xml/element struct-map,
  which has the keys :tag, :attrs, and :content. and accessor fns tag,
  attrs, and content. Other parsers can be supplied by passing
  startparse, a fn taking a source and a ContentHandler and returning
  a parser</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse
  {:added &quot;1.0&quot;}
  ([s] (parse s startparse-sax))
  ([s startparse]
    (binding [*stack* nil
              *current* (struct element)
              *state* :between
              *sb* nil]
      (startparse s content-handler)
      ((:content *current*) 0)))) </pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn emit-element [e]
  (if (instance? String e)
    (println e)
    (do
      (print (str &quot;&lt;&quot; (name (:tag e))))
      (when (:attrs e)
	(doseq [attr (:attrs e)]
	  (print (str &quot; &quot; (name (key attr)) &quot;='&quot; (val attr)&quot;'&quot;))))
      (if (:content e)
	(do
	  (println &quot;&gt;&quot;)
	  (doseq [c (:content e)]
	    (emit-element c))
	  (println (str &quot;&lt;/&quot; (name (:tag e)) &quot;&gt;&quot;)))
	(println &quot;/&gt;&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn emit [x]
  (println &quot;&lt;?xml version='1.0' encoding='UTF-8'?&gt;&quot;)
  (emit-element x))</pre></td></tr><tr><td class="docs"><p>(export '(tag attrs content parse element emit emit-element))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(load-file "/Users/rich/dev/clojure/src/xml.clj")
(def x (xml/parse "http://arstechnica.com/journals.rssx"))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.zip" name="clojure.zip"><h1 class="project-name">clojure.zip</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>functional hierarchical zipper, with navigation, editing and enumeration
see Huet</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Functional hierarchical zipper, with navigation, editing,
  and enumeration.  See Huet</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^{:doc 
       :author &quot;Rich Hickey&quot;}
  clojure.zip
  (:refer-clojure :exclude (replace remove next)))</pre></td></tr><tr><td class="docs"><p>Creates a new zipper structure. </p>

<p>  branch? is a fn that, given a node, returns true if can have
  children, even if it currently doesn't.</p>

<p>  children is a fn that, given a branch node, returns a seq of its
  children.</p>

<p>  make-node is a fn that, given an existing node and a seq of
  children, returns a new branch node with the supplied children.
  root is the root node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn zipper
  {:added &quot;1.0&quot;}
  [branch? children make-node root]
    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}
    [root nil])</pre></td></tr><tr><td class="docs"><p>Returns a zipper for nested sequences, given a root sequence</p>
</td><td class="codes"><pre class="brush: clojure">(defn seq-zip
  {:added &quot;1.0&quot;}
  [root]
    (zipper seq?
            identity
            (fn [node children] (with-meta children (meta node)))
            root))</pre></td></tr><tr><td class="docs"><p>Returns a zipper for nested vectors, given a root vector</p>
</td><td class="codes"><pre class="brush: clojure">(defn vector-zip
  {:added &quot;1.0&quot;}
  [root]
    (zipper vector?
            seq
            (fn [node children] (with-meta (vec children) (meta node)))
            root))</pre></td></tr><tr><td class="docs"><p>Returns a zipper for xml elements (as from xml/parse),
  given a root element</p>
</td><td class="codes"><pre class="brush: clojure">(defn xml-zip
  {:added &quot;1.0&quot;}
  [root]
    (zipper (complement string?) 
            (comp seq :content)
            (fn [node children]
              (assoc node :content (and children (apply vector children))))
            root))</pre></td></tr><tr><td class="docs"><p>Returns the node at loc</p>
</td><td class="codes"><pre class="brush: clojure">(defn node
  {:added &quot;1.0&quot;}
  [loc] (loc 0))</pre></td></tr><tr><td class="docs"><p>Returns true if the node at loc is a branch</p>
</td><td class="codes"><pre class="brush: clojure">(defn branch?
  {:added &quot;1.0&quot;}
  [loc]
    ((:zip/branch? (meta loc)) (node loc)))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the children of node at loc, which must be a branch</p>
</td><td class="codes"><pre class="brush: clojure">(defn children
  {:added &quot;1.0&quot;}
  [loc]
    (if (branch? loc)
      ((:zip/children (meta loc)) (node loc))
      (throw (Exception. &quot;called children on a leaf node&quot;))))</pre></td></tr><tr><td class="docs"><p>Returns a new branch node, given an existing node and new
  children. The loc is only used to supply the constructor.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-node
  {:added &quot;1.0&quot;}
  [loc node children]
    ((:zip/make-node (meta loc)) node children))</pre></td></tr><tr><td class="docs"><p>Returns a seq of nodes leading to this loc</p>
</td><td class="codes"><pre class="brush: clojure">(defn path
  {:added &quot;1.0&quot;}
  [loc]
    (:pnodes (loc 1)))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the left siblings of this loc</p>
</td><td class="codes"><pre class="brush: clojure">(defn lefts
  {:added &quot;1.0&quot;}
  [loc]
    (seq (:l (loc 1))))</pre></td></tr><tr><td class="docs"><p>Returns a seq of the right siblings of this loc</p>
</td><td class="codes"><pre class="brush: clojure">(defn rights
  {:added &quot;1.0&quot;}
  [loc]
    (:r (loc 1)))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the leftmost child of the node at this loc, or
  nil if no children</p>
</td><td class="codes"><pre class="brush: clojure">(defn down
  {:added &quot;1.0&quot;}
  [loc]
    (when (branch? loc)
      (let [[node path] loc
            [c &amp; cnext :as cs] (children loc)]
        (when cs
          (with-meta [c {:l [] 
                         :pnodes (if path (conj (:pnodes path) node) [node]) 
                         :ppath path 
                         :r cnext}] (meta loc))))))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the parent of the node at this loc, or nil if at
  the top</p>
</td><td class="codes"><pre class="brush: clojure">(defn up
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]
      (when pnodes
        (let [pnode (peek pnodes)]
          (with-meta (if changed?
                       [(make-node loc pnode (concat l (cons node r))) 
                        (and ppath (assoc ppath :changed? true))]
                       [pnode ppath])
                     (meta loc))))))</pre></td></tr><tr><td class="docs"><p>zips all the way up and returns the root node, reflecting any
 changes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn root
  {:added &quot;1.0&quot;}
  [loc]
    (if (= :end (loc 1))
      (node loc)
      (let [p (up loc)]
        (if p
          (recur p)
          (node loc)))))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the right sibling of the node at this loc, or nil</p>
</td><td class="codes"><pre class="brush: clojure">(defn right
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l  [r &amp; rnext :as rs] :r :as path}] loc]
      (when (and path rs)
        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the rightmost sibling of the node at this loc, or self</p>
</td><td class="codes"><pre class="brush: clojure">(defn rightmost
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l r :r :as path}] loc]
      (if (and path r)
        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))
        loc)))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the left sibling of the node at this loc, or nil</p>
</td><td class="codes"><pre class="brush: clojure">(defn left
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l r :r :as path}] loc]
      (when (and path (seq l))
        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))</pre></td></tr><tr><td class="docs"><p>Returns the loc of the leftmost sibling of the node at this loc, or self</p>
</td><td class="codes"><pre class="brush: clojure">(defn leftmost
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l r :r :as path}] loc]
      (if (and path (seq l))
        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))
        loc)))</pre></td></tr><tr><td class="docs"><p>Inserts the item as the left sibling of the node at this loc,
 without moving</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-left
  {:added &quot;1.0&quot;}
  [loc item]
    (let [[node {l :l :as path}] loc]
      (if (nil? path)
        (throw (new Exception &quot;Insert at top&quot;))
        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))</pre></td></tr><tr><td class="docs"><p>Inserts the item as the right sibling of the node at this loc,
  without moving</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-right
  {:added &quot;1.0&quot;}
  [loc item]
    (let [[node {r :r :as path}] loc]
      (if (nil? path)
        (throw (new Exception &quot;Insert at top&quot;))
        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))</pre></td></tr><tr><td class="docs"><p>Replaces the node at this loc, without moving</p>
</td><td class="codes"><pre class="brush: clojure">(defn replace
  {:added &quot;1.0&quot;}
  [loc node]
    (let [[_ path] loc]
      (with-meta [node (assoc path :changed? true)] (meta loc))))</pre></td></tr><tr><td class="docs"><p>Replaces the node at this loc with the value of (f node args)</p>
</td><td class="codes"><pre class="brush: clojure">(defn edit
  {:added &quot;1.0&quot;}
  [loc f &amp; args]
    (replace loc (apply f (node loc) args)))</pre></td></tr><tr><td class="docs"><p>Inserts the item as the leftmost child of the node at this loc,
  without moving</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-child
  {:added &quot;1.0&quot;}
  [loc item]
    (replace loc (make-node loc (node loc) (cons item (children loc)))))</pre></td></tr><tr><td class="docs"><p>Inserts the item as the rightmost child of the node at this loc,
  without moving</p>
</td><td class="codes"><pre class="brush: clojure">(defn append-child
  {:added &quot;1.0&quot;}
  [loc item]
    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))</pre></td></tr><tr><td class="docs"><p>Moves to the next loc in the hierarchy, depth-first. When reaching
  the end, returns a distinguished loc detectable via end?. If already
  at the end, stays there.</p>
</td><td class="codes"><pre class="brush: clojure">(defn next
  {:added &quot;1.0&quot;}
  [loc]
    (if (= :end (loc 1))
      loc
      (or 
       (and (branch? loc) (down loc))
       (right loc)
       (loop [p loc]
         (if (up p)
           (or (right (up p)) (recur (up p)))
           [(node p) :end])))))</pre></td></tr><tr><td class="docs"><p>Moves to the previous loc in the hierarchy, depth-first. If already
  at the root, returns nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn prev
  {:added &quot;1.0&quot;}
  [loc]
    (if-let [lloc (left loc)]
      (loop [loc lloc]
        (if-let [child (and (branch? loc) (down loc))]
          (recur (rightmost child))
          loc))
      (up loc)))</pre></td></tr><tr><td class="docs"><p>Returns true if loc represents the end of a depth-first walk</p>
</td><td class="codes"><pre class="brush: clojure">(defn end?
  {:added &quot;1.0&quot;}
  [loc]
    (= :end (loc 1)))</pre></td></tr><tr><td class="docs"><p>Removes the node at loc, returning the loc that would have preceded
  it in a depth-first walk.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove
  {:added &quot;1.0&quot;}
  [loc]
    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]
      (if (nil? path)
        (throw (new Exception &quot;Remove at top&quot;))
        (if (pos? (count l))
          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]
            (if-let [child (and (branch? loc) (down loc))]
              (recur (rightmost child))
              loc))
          (with-meta [(make-node loc (peek pnodes) rs) 
                      (and ppath (assoc ppath :changed? true))]
                     (meta loc))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
(load-file &quot;/Users/rich/dev/clojure/src/zip.clj&quot;)
(refer 'zip)
(def data '[[a * b] + [c * d]])
(def dz (vector-zip data))
(right (down (right (right (down dz)))))
(lefts (right (down (right (right (down dz))))))
(rights (right (down (right (right (down dz))))))
(up (up (right (down (right (right (down dz)))))))
(path (right (down (right (right (down dz))))))
(-&gt; dz down right right down right)
(-&gt; dz down right right down right (replace '/) root)
(-&gt; dz next next (edit str) next next next (replace '/) root)
(-&gt; dz next next next next next next next next next remove root)
(-&gt; dz next next next next next next next next next remove (insert-right 'e) root)
(-&gt; dz next next next next next next next next next remove up (append-child 'e) root)
(end? (-&gt; dz next next next next next next next next next remove next))
(-&gt; dz next remove next remove root)
(loop [loc dz]
  (if (end? loc)
    (root loc)
    (recur (next (if (= '* (node loc)) 
                   (replace loc '/)
                   loc)))))
(loop [loc dz]
  (if (end? loc)
    (root loc)
    (recur (next (if (= '* (node loc)) 
                   (remove loc)
                   loc))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#clojure.test-clojure" name="clojure.test-clojure"><h1 class="project-name">clojure.test-clojure</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns clojure.test-clojure (:require clojure.test))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def test-namespaces '[
clojure.test-clojure.agents
clojure.test-clojure.annotations
clojure.test-clojure.atoms
clojure.test-clojure.clojure-set
clojure.test-clojure.clojure-walk                       
clojure.test-clojure.clojure-xml
clojure.test-clojure.clojure-zip
clojure.test-clojure.compilation
clojure.test-clojure.control
clojure.test-clojure.data
clojure.test-clojure.data-structures
clojure.test-clojure.def
clojure.test-clojure.errors
clojure.test-clojure.evaluation
clojure.test-clojure.for
clojure.test-clojure.genclass.examples
clojure.test-clojure.genclass
clojure.test-clojure.java.io
clojure.test-clojure.java.javadoc
clojure.test-clojure.java.shell
clojure.test-clojure.java-interop
clojure.test-clojure.keywords
clojure.test-clojure.load
clojure.test-clojure.logic
clojure.test-clojure.macros
clojure.test-clojure.main
clojure.test-clojure.metadata
clojure.test-clojure.multimethods
clojure.test-clojure.ns-libs
clojure.test-clojure.numbers
clojure.test-clojure.other-functions
clojure.test-clojure.parallel
clojure.test-clojure.pprint
clojure.test-clojure.predicates
clojure.test-clojure.printer
clojure.test-clojure.protocols
clojure.test-clojure.protocols.hash-collisions
clojure.test-clojure.reader
clojure.test-clojure.reducers
clojure.test-clojure.reflect
clojure.test-clojure.refs
clojure.test-clojure.repl
clojure.test-clojure.rt
clojure.test-clojure.sequences
clojure.test-clojure.serialization
clojure.test-clojure.special
clojure.test-clojure.string
clojure.test-clojure.test
clojure.test-clojure.test-fixtures
clojure.test-clojure.transients
clojure.test-clojure.try-catch
clojure.test-clojure.vars
clojure.test-clojure.vectors
])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(apply require test-namespaces)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(let [results (apply clojure.test/run-tests test-namespaces)]
  (System/exit (+ (:error results) (:fail results))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>